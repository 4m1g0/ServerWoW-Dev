diff --git a/src/server/authserver/Server/RealmSocket.h b/src/server/authserver/Server/RealmSocket.h
index 9dbd0a4..9682b5e 100755
--- a/src/server/authserver/Server/RealmSocket.h
+++ b/src/server/authserver/Server/RealmSocket.h
@@ -24,7 +24,6 @@
 #include <ace/SOCK_Stream.h>
 #include <ace/Message_Block.h>
 #include <ace/Basic_Types.h>
-#include "Common.h"
 
 class RealmSocket : public ACE_Svc_Handler<ACE_SOCK_STREAM, ACE_NULL_SYNCH>
 {
diff --git a/src/server/collision/BoundingIntervalHierarchy.h b/src/server/collision/BoundingIntervalHierarchy.h
index ea70fc3..b0c3523 100755
--- a/src/server/collision/BoundingIntervalHierarchy.h
+++ b/src/server/collision/BoundingIntervalHierarchy.h
@@ -81,25 +81,13 @@ struct AABound
 
 class BIH
 {
-    private:
-        void init_empty()
-        {
-            tree.clear();
-            objects.clear();
-            // create space for the first node
-            tree.push_back(3 << 30); // dummy leaf
-            tree.insert(tree.end(), 2, 0);
-        }
     public:
-        BIH() { init_empty(); }
-        template< class BoundsFunc, class PrimArray >
-        void build(const PrimArray &primitives, BoundsFunc &getBounds, uint32 leafSize = 3, bool printStats=false)
+        BIH() {};
+        template< class T, class BoundsFunc >
+        void build(const std::vector<T> &primitives, BoundsFunc &getBounds, uint32 leafSize = 3, bool printStats=false)
         {
-            if (primitives.size() == 0)
-            {
-                init_empty();
+            if (primitives.empty())
                 return;
-            }
 
             buildData dat;
             dat.maxPrims = leafSize;
@@ -409,4 +397,4 @@ class BIH
         void subdivide(int left, int right, std::vector<uint32> &tempTree, buildData &dat, AABound &gridBox, AABound &nodeBox, int nodeIndex, int depth, BuildStats &stats);
 };
 
-#endif // _BIH_H
\ No newline at end of file
+#endif // _BIH_H
diff --git a/src/server/collision/BoundingIntervalHierarchyWrapper.h b/src/server/collision/BoundingIntervalHierarchyWrapper.h
deleted file mode 100644
index e54a4e6..0000000
--- a/src/server/collision/BoundingIntervalHierarchyWrapper.h
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
- * Copyright (C) 2005-2010 MaNGOS <http://getmangos.com/>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef _BIH_WRAP
-#define _BIH_WRAP
-
-#include "G3D/Table.h"
-#include "G3D/Array.h"
-#include "G3D/Set.h"
-#include "BoundingIntervalHierarchy.h"
-
-
-template<class T, class BoundsFunc = BoundsTrait<T> >
-class BIHWrap
-{
-    template<class RayCallback>
-    struct MDLCallback
-    {
-        const T* const* objects;
-        RayCallback& _callback;
-
-        MDLCallback(RayCallback& callback, const T* const* objects_array ) : _callback(callback), objects(objects_array){}
-
-        bool operator() (const Ray& ray, uint32 Idx, float& MaxDist, bool /*stopAtFirst*/)
-        {
-            if (const T* obj = objects[Idx])
-                return _callback(ray, *obj, MaxDist/*, stopAtFirst*/);
-            return false;
-        }
-
-        void operator() (const Vector3& p, uint32 Idx)
-        {
-            if (const T* obj = objects[Idx])
-                _callback(p, *obj);
-        }
-    };
-
-    typedef G3D::Array<const T*> ObjArray;
-
-    BIH m_tree;
-    ObjArray m_objects;
-    G3D::Table<const T*, uint32> m_obj2Idx;
-    G3D::Set<const T*> m_objects_to_push;
-    int unbalanced_times;
-
-public:
-    BIHWrap() : unbalanced_times(0) {}
-
-    void insert(const T& obj)
-    {
-        ++unbalanced_times;
-        m_objects_to_push.insert(&obj);
-    }
-
-    void remove(const T& obj)
-    {
-        ++unbalanced_times;
-        uint32 Idx = 0;
-        const T * temp;
-        if (m_obj2Idx.getRemove(&obj, temp, Idx))
-            m_objects[Idx] = NULL;
-        else
-            m_objects_to_push.remove(&obj);
-    }
-
-    void balance()
-    {
-        if (unbalanced_times == 0)
-            return;
-
-        unbalanced_times = 0;
-        m_objects.fastClear();
-        m_obj2Idx.getKeys(m_objects);
-        m_objects_to_push.getMembers(m_objects);
-
-        m_tree.build(m_objects, BoundsFunc::getBounds2);
-    }
-
-    template<typename RayCallback>
-    void intersectRay(const Ray& ray, RayCallback& intersectCallback, float& maxDist) const
-    {
-        MDLCallback<RayCallback> temp_cb(intersectCallback, m_objects.getCArray());
-        m_tree.intersectRay(ray, temp_cb, maxDist, true);
-    }
-
-    template<typename IsectCallback>
-    void intersectPoint(const Vector3& point, IsectCallback& intersectCallback) const
-    {
-        MDLCallback<IsectCallback> callback(intersectCallback, m_objects.getCArray());
-        m_tree.intersectPoint(point, callback);
-    }
-};
-
-#endif // _BIH_WRAP
\ No newline at end of file
diff --git a/src/server/collision/CMakeLists.txt b/src/server/collision/CMakeLists.txt
index 9fc696a..e2e1826 100644
--- a/src/server/collision/CMakeLists.txt
+++ b/src/server/collision/CMakeLists.txt
@@ -39,36 +39,9 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/shared/Database
   ${CMAKE_SOURCE_DIR}/src/server/shared/Debugging
   ${CMAKE_SOURCE_DIR}/src/server/shared/Dynamic
-  ${CMAKE_SOURCE_DIR}/src/server/shared/Dynamic/LinkedReference
   ${CMAKE_SOURCE_DIR}/src/server/shared/Logging
   ${CMAKE_SOURCE_DIR}/src/server/shared/Threading
-  ${CMAKE_SOURCE_DIR}/src/server/shared/Packets
-  ${CMAKE_SOURCE_DIR}/src/server/shared/Utilities
-  ${CMAKE_SOURCE_DIR}/src/server/shared/DataStores
-  ${CMAKE_SOURCE_DIR}/src/server/game/Addons
   ${CMAKE_SOURCE_DIR}/src/server/game/Conditions
-  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Item
-  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/GameObject
-  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Creature
-  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Object
-  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Object/Updates
-  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Unit
-  ${CMAKE_SOURCE_DIR}/src/server/game/Combat
-  ${CMAKE_SOURCE_DIR}/src/server/game/Loot
-  ${CMAKE_SOURCE_DIR}/src/server/game/Miscellaneous
-  ${CMAKE_SOURCE_DIR}/src/server/game/Grids
-  ${CMAKE_SOURCE_DIR}/src/server/game/Grids/Cells
-  ${CMAKE_SOURCE_DIR}/src/server/game/Grids/Notifiers
-  ${CMAKE_SOURCE_DIR}/src/server/game/Maps
-  ${CMAKE_SOURCE_DIR}/src/server/game/DataStores
-  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Waypoints
-  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Spline
-  ${CMAKE_SOURCE_DIR}/src/server/game/Movement
-  ${CMAKE_SOURCE_DIR}/src/server/game/Server
-  ${CMAKE_SOURCE_DIR}/src/server/game/Server/Protocol
-  ${CMAKE_SOURCE_DIR}/src/server/game/World
-  ${CMAKE_SOURCE_DIR}/src/server/game/Spells
-  ${CMAKE_SOURCE_DIR}/src/server/game/Spells/Auras
   ${CMAKE_CURRENT_SOURCE_DIR}
   ${CMAKE_CURRENT_SOURCE_DIR}/Management
   ${CMAKE_CURRENT_SOURCE_DIR}/Maps
diff --git a/src/server/collision/DynamicTree.cpp b/src/server/collision/DynamicTree.cpp
deleted file mode 100644
index 1d6877d..0000000
--- a/src/server/collision/DynamicTree.cpp
+++ /dev/null
@@ -1,206 +0,0 @@
-/*
- * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
- * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "DynamicTree.h"
-//#include "QuadTree.h"
-//#include "RegularGrid.h"
-#include "BoundingIntervalHierarchyWrapper.h"
-
-#include "Log.h"
-#include "RegularGrid.h"
-#include "Timer.h"
-#include "GameObjectModel.h"
-#include "ModelInstance.h"
-
-using VMAP::ModelInstance;
-using G3D::Ray;
-
-template<> struct HashTrait< GameObjectModel>{
-    static size_t hashCode(const GameObjectModel& g) { return (size_t)(void*)&g; }
-};
-
-template<> struct PositionTrait< GameObjectModel> {
-    static void getPosition(const GameObjectModel& g, Vector3& p) { p = g.getPosition(); }
-};
-
-template<> struct BoundsTrait< GameObjectModel> {
-    static void getBounds(const GameObjectModel& g, G3D::AABox& out) { out = g.getBounds();}
-    static void getBounds2(const GameObjectModel* g, G3D::AABox& out) { out = g->getBounds();}
-};
-
-static bool operator == (const GameObjectModel& mdl, const GameObjectModel& mdl2){
-    return &mdl == &mdl2;
-}
-
-
-int valuesPerNode = 5, numMeanSplits = 3;
-
-int UNBALANCED_TIMES_LIMIT = 5;
-int CHECK_TREE_PERIOD = 200;
-
-typedef RegularGrid2D<GameObjectModel, BIHWrap<GameObjectModel> > ParentTree;
-
-struct DynTreeImpl : public ParentTree/*, public Intersectable*/
-{
-    typedef GameObjectModel Model;
-    typedef ParentTree base;
-
-    DynTreeImpl() :
-        rebalance_timer(CHECK_TREE_PERIOD),
-        unbalanced_times(0)
-    {
-    }
-
-    void insert(const Model& mdl)
-    {
-        base::insert(mdl);
-        ++unbalanced_times;
-    }
-
-    void remove(const Model& mdl)
-    {
-        base::remove(mdl);
-        ++unbalanced_times;
-    }
-
-    void balance()
-    {
-        base::balance();
-        unbalanced_times = 0;
-    }
-
-    void update(uint32 difftime)
-    {
-        if (!size())
-            return;
-
-        rebalance_timer.Update(difftime);
-        if (rebalance_timer.Passed())
-        {
-            rebalance_timer.Reset(CHECK_TREE_PERIOD);
-            if (unbalanced_times > 0)
-                balance();
-        }
-    }
-
-    TimeTrackerSmall rebalance_timer;
-    int unbalanced_times;
-};
-
-DynamicMapTree::DynamicMapTree() : impl(*new DynTreeImpl())
-{
-}
-
-DynamicMapTree::~DynamicMapTree()
-{
-    delete &impl;
-}
-
-void DynamicMapTree::insert(const GameObjectModel& mdl)
-{
-    impl.insert(mdl);
-}
-
-void DynamicMapTree::remove(const GameObjectModel& mdl)
-{
-    impl.remove(mdl);
-}
-
-bool DynamicMapTree::contains(const GameObjectModel& mdl) const
-{
-    return impl.contains(mdl);
-}
-
-void DynamicMapTree::balance()
-{
-    impl.balance();
-}
-
-int DynamicMapTree::size() const
-{
-    return impl.size();
-}
-
-void DynamicMapTree::update(uint32 t_diff)
-{
-    impl.update(t_diff);
-}
-
-struct DynamicTreeIntersectionCallback
-{
-    bool did_hit;
-    uint32 phase_mask;
-    DynamicTreeIntersectionCallback(uint32 phasemask) : did_hit(false), phase_mask(phasemask) {}
-    bool operator()(const Ray& r, const GameObjectModel& obj, float& distance)
-    {
-        did_hit = obj.intersectRay(r, distance, true, phase_mask);
-        return did_hit;
-    }
-    bool didHit() const { return did_hit;}
-};
-
-struct DynamicTreeIntersectionCallback_WithLogger
-{
-    bool did_hit;
-    uint32 phase_mask;
-    DynamicTreeIntersectionCallback_WithLogger(uint32 phasemask) : did_hit(false), phase_mask(phasemask)
-    {
-        sLog->outDebug(LOG_FILTER_MAPS, "Dynamic Intersection log");
-    }
-    bool operator()(const Ray& r, const GameObjectModel& obj, float& distance)
-    {
-        sLog->outDebug(LOG_FILTER_MAPS, "testing intersection with %s", obj.name.c_str());
-        bool hit = obj.intersectRay(r, distance, true, phase_mask);
-        if (hit)
-        {
-            did_hit = true;
-            sLog->outDebug(LOG_FILTER_MAPS, "result: intersects");
-        }
-        return hit;
-    }
-    bool didHit() const { return did_hit;}
-};
-
-bool DynamicMapTree::isInLineOfSight(float x1, float y1, float z1, float x2, float y2, float z2, uint32 phasemask) const
-{
-    Vector3 v1(x1,y1,z1), v2(x2,y2,z2);
-
-    float maxDist = (v2 - v1).magnitude();
-
-    if (!G3D::fuzzyGt(maxDist, 0) )
-        return true;
-
-    Ray r(v1, (v2-v1) / maxDist);
-    DynamicTreeIntersectionCallback callback(phasemask);
-    impl.intersectRay(r, callback, maxDist, v2);
-
-    return !callback.did_hit;
-}
-
-float DynamicMapTree::getHeight(float x, float y, float z, float maxSearchDist, uint32 phasemask) const
-{
-    Vector3 v(x,y,z);
-    Ray r(v, Vector3(0,0,-1));
-    DynamicTreeIntersectionCallback callback(phasemask);
-    impl.intersectZAllignedRay(r, callback, maxSearchDist);
-
-    if (callback.didHit())
-        return v.z - maxSearchDist;
-    else
-        return -G3D::inf();
-}
\ No newline at end of file
diff --git a/src/server/collision/DynamicTree.h b/src/server/collision/DynamicTree.h
deleted file mode 100644
index ab28641..0000000
--- a/src/server/collision/DynamicTree.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
- * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
- 
-#ifndef _DYNTREE_H
-#define _DYNTREE_H
-
-#include <G3D/Matrix3.h>
-#include <G3D/Vector3.h>
-#include <G3D/AABox.h>
-#include <G3D/Ray.h>
-
-//#include "ModelInstance.h"
-#include "Define.h"
-//#include "GameObjectModel.h"
-
-namespace G3D
-{
-    class Vector3;
-}
-
-using G3D::Vector3;
-class GameObjectModel;
-
-class DynamicMapTree
-{
-    struct DynTreeImpl& impl;
-public:
-
-    DynamicMapTree();
-    ~DynamicMapTree();
-
-    bool isInLineOfSight(float x1, float y1, float z1, float x2, float y2, float z2, uint32 phasemask) const;
-    float getHeight(float x, float y, float z, float maxSearchDist, uint32 phasemask) const;
-
-    void insert(const GameObjectModel&);
-    void remove(const GameObjectModel&);
-    bool contains(const GameObjectModel&) const;
-    int size() const;
-
-    void balance();
-    void update(uint32 diff);
-};
-
-#endif // _DYNTREE_H
diff --git a/src/server/collision/Maps/TileAssembler.cpp b/src/server/collision/Maps/TileAssembler.cpp
index 62968e4..355ef6b 100644
--- a/src/server/collision/Maps/TileAssembler.cpp
+++ b/src/server/collision/Maps/TileAssembler.cpp
@@ -16,6 +16,7 @@
  * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include "WorldModel.h"
 #include "TileAssembler.h"
 #include "MapTree.h"
 #include "BoundingIntervalHierarchy.h"
@@ -70,6 +71,7 @@ namespace VMAP
 
     bool TileAssembler::convertWorld2()
     {
+        std::set<std::string> spawnedModelFiles;
         bool success = readMapSpawns();
         if (!success)
             return false;
@@ -176,8 +178,6 @@ namespace VMAP
             // break; //test, extract only first map; TODO: remvoe this line
         }
 
-        // add an object models, listed in temp_gameobject_models file
-        exportGameobjectModels();
         // export objects
         std::cout << "\nConverting Model Files" << std::endl;
         for (std::set<std::string>::iterator mfile = spawnedModelFiles.begin(); mfile != spawnedModelFiles.end(); ++mfile)
@@ -251,40 +251,99 @@ namespace VMAP
         modelPosition.iScale = spawn.iScale;
         modelPosition.init();
 
-        WorldModel_Raw raw_model;
-        if (!raw_model.Read(modelFilename.c_str()))
+        FILE* rf = fopen(modelFilename.c_str(), "rb");
+        if (!rf)
+        {
+            printf("ERROR: Can't open model file: %s\n", modelFilename.c_str());
             return false;
+        }
 
-        uint32 groups = raw_model.groupsArray.size();
-        if (groups != 1)
-            printf("Warning: '%s' does not seem to be a M2 model!\n", modelFilename.c_str());
-            
         AABox modelBound;
         bool boundEmpty=true;
+        char ident[8];
+
+        int readOperation = 1;
+
+        // temporary use defines to simplify read/check code (close file and return at fail)
+        #define READ_OR_RETURN(V, S) if (fread((V), (S), 1, rf) != 1) { \
+                                        fclose(rf); printf("readfail, op = %i\n", readOperation); return(false); }readOperation++;
+        // only use this for array deletes
+        #define READ_OR_RETURN_WITH_DELETE(V, S) if (fread((V), (S), 1, rf) != 1) { \
+                                        fclose(rf); printf("readfail, op = %i\n", readOperation); delete[] V; return(false); }readOperation++;
+
+        #define CMP_OR_RETURN(V, S)  if (strcmp((V), (S)) != 0)        { \
+                                        fclose(rf); printf("cmpfail, %s!=%s\n", V, S);return(false); }
+
+        READ_OR_RETURN(&ident, 8);
+        CMP_OR_RETURN(ident, "VMAP003");
+
+        // we have to read one int. This is needed during the export and we have to skip it here
+        uint32 tempNVectors;
+        READ_OR_RETURN(&tempNVectors, sizeof(tempNVectors));
+
+        uint32 groups, wmoRootId;
+        char blockId[5];
+        blockId[4] = 0;
+        int blocksize;
+        float *vectorarray = 0;
+
+        READ_OR_RETURN(&groups, sizeof(uint32));
+        READ_OR_RETURN(&wmoRootId, sizeof(uint32));
+        if (groups != 1) printf("Warning: '%s' does not seem to be a M2 model!\n", modelFilename.c_str());
 
         for (uint32 g=0; g<groups; ++g) // should be only one for M2 files...
         {
-            std::vector<Vector3>& vertices = raw_model.groupsArray[g].vertexArray;
+            fseek(rf, 3*sizeof(uint32) + 6*sizeof(float), SEEK_CUR);
+
+            READ_OR_RETURN(&blockId, 4);
+            CMP_OR_RETURN(blockId, "GRP ");
+            READ_OR_RETURN(&blocksize, sizeof(int));
+            fseek(rf, blocksize, SEEK_CUR);
+
+            // ---- indexes
+            READ_OR_RETURN(&blockId, 4);
+            CMP_OR_RETURN(blockId, "INDX");
+            READ_OR_RETURN(&blocksize, sizeof(int));
+            fseek(rf, blocksize, SEEK_CUR);
+
+            // ---- vectors
+            READ_OR_RETURN(&blockId, 4);
+            CMP_OR_RETURN(blockId, "VERT");
+            READ_OR_RETURN(&blocksize, sizeof(int));
+            uint32 nvectors;
+            READ_OR_RETURN(&nvectors, sizeof(uint32));
 
-            if (vertices.empty())
+            if (nvectors >0)
+            {
+                vectorarray = new float[nvectors*3];
+                READ_OR_RETURN_WITH_DELETE(vectorarray, nvectors*sizeof(float)*3);
+            }
+            else
             {
                 std::cout << "error: model '" << spawn.name << "' has no geometry!" << std::endl;
-                continue;
+                fclose(rf);
+                return false;
             }
 
-            uint32 nvectors = vertices.size();
-            for (uint32 i = 0; i < nvectors; ++i)
+            for (uint32 i=0, indexNo=0; indexNo<nvectors; indexNo++, i+=3)
             {
-                Vector3 v = modelPosition.transform(vertices[i]);
+                Vector3 v = Vector3(vectorarray[i+0], vectorarray[i+1], vectorarray[i+2]);
+                v = modelPosition.transform(v);
 
                 if (boundEmpty)
                     modelBound = AABox(v, v), boundEmpty=false;
                 else
                     modelBound.merge(v);
             }
+            delete[] vectorarray;
+            // drop of temporary use defines
+            #undef READ_OR_RETURN
+            #undef READ_OR_RETURN_WITH_DELETE
+            #undef CMP_OR_RETURN
         }
         spawn.iBound = modelBound + spawn.iPos;
         spawn.flags |= MOD_HAS_BOUND;
+        fclose(rf);
         return true;
     }
 
@@ -304,221 +363,150 @@ namespace VMAP
         if (filename.length() >0)
             filename.push_back('/');
         filename.append(pModelFilename);
+        FILE* rf = fopen(filename.c_str(), "rb");
 
-        WorldModel_Raw raw_model;
-        if (!raw_model.Read(filename.c_str()))
-            return false;
-            
-        // write WorldModel
-        WorldModel model;
-        model.setRootWmoID(raw_model.RootWMOID);
-        if (raw_model.groupsArray.size())
+        if (!rf)
         {
-            std::vector<GroupModel> groupsArray;
-
-            uint32 groups = raw_model.groupsArray.size();
-            for (uint32 g = 0; g < groups; ++g)
-            {
-                GroupModel_Raw& raw_group = raw_model.groupsArray[g];
-                groupsArray.push_back(GroupModel(raw_group.mogpflags, raw_group.GroupWMOID, raw_group.bounds ));
-                groupsArray.back().setMeshData(raw_group.vertexArray, raw_group.triangles);
-                groupsArray.back().setLiquidData(raw_group.liquid);
-            }
-
-            model.setGroupModels(groupsArray);
+            printf("ERROR: Can't open model file in form: %s", pModelFilename.c_str());
+            printf("...                          or form: %s", filename.c_str() );
+            return false;
         }
-        
-        success = model.writeFile(iDestDir + "/" + pModelFilename + ".vmo");
-        //std::cout << "readRawFile2: '" << pModelFilename << "' tris: " << nElements << " nodes: " << nNodes << std::endl;
-        return success;
-    }
-    
-    void TileAssembler::exportGameobjectModels()
-    {
-        FILE* model_list = fopen((iSrcDir + "/" + GAMEOBJECT_MODELS).c_str(), "rb");
-        FILE* model_list_copy = fopen((iDestDir + "/" + GAMEOBJECT_MODELS).c_str(), "wb");
-        if (!model_list || !model_list_copy)
-            return;
-
-        uint32 name_length, displayId;
-        char buff[500];
-        while (!feof(model_list))
-        {
-            fread(&displayId,sizeof(uint32),1,model_list);
-            fread(&name_length,sizeof(uint32),1,model_list);
-
-            if (name_length >= sizeof(buff))
-            {
-                std::cout << "\nFile 'temp_gameobject_models' seems to be corrupted" << std::endl;
-                break;
-            }
-
-            fread(&buff,sizeof(char),name_length,model_list);
-            std::string model_name(buff, name_length);
-
-            WorldModel_Raw raw_model;
-            if ( !raw_model.Read((iSrcDir + "/" + model_name).c_str()) )
-                continue;
 
-            spawnedModelFiles.insert(model_name);
-            AABox bounds;
-            bool boundEmpty = true;
-            for (uint32 g = 0; g < raw_model.groupsArray.size(); ++g)
-            {
-                std::vector<Vector3>& vertices = raw_model.groupsArray[g].vertexArray;
-
-                uint32 nvectors = vertices.size();
-                for (uint32 i = 0; i < nvectors; ++i)
-                {
-                    Vector3& v = vertices[i];
-                    if (boundEmpty)
-                        bounds = AABox(v, v), boundEmpty = false;
-                    else
-                        bounds.merge(v);
-                }
-            }
+        char ident[8];
 
-            fwrite(&displayId,sizeof(uint32),1,model_list_copy);
-            fwrite(&name_length,sizeof(uint32),1,model_list_copy);
-            fwrite(&buff,sizeof(char),name_length,model_list_copy);
-            fwrite(&bounds.low(),sizeof(Vector3),1,model_list_copy);
-            fwrite(&bounds.high(),sizeof(Vector3),1,model_list_copy);
-        }
+        int readOperation = 1;
 
-        fclose(model_list);
-        fclose(model_list_copy);
-    }
         // temporary use defines to simplify read/check code (close file and return at fail)
         #define READ_OR_RETURN(V, S) if (fread((V), (S), 1, rf) != 1) { \
-                                        fclose(rf); printf("readfail, op = %i\n", readOperation); return(false); }
+                                        fclose(rf); printf("readfail, op = %i\n", readOperation); return(false); }readOperation++;
         #define READ_OR_RETURN_WITH_DELETE(V, S) if (fread((V), (S), 1, rf) != 1) { \
-                                        fclose(rf); printf("readfail, op = %i\n", readOperation); delete[] V; return(false); };
+                                        fclose(rf); printf("readfail, op = %i\n", readOperation); delete[] V; return(false); }readOperation++;
         #define CMP_OR_RETURN(V, S)  if (strcmp((V), (S)) != 0)        { \
                                         fclose(rf); printf("cmpfail, %s!=%s\n", V, S);return(false); }
 
-    bool GroupModel_Raw::Read(FILE* rf)
-    {
+        READ_OR_RETURN(&ident, 8);
+        CMP_OR_RETURN(ident, "VMAP003");
+
+        // we have to read one int. This is needed during the export and we have to skip it here
+        uint32 tempNVectors;
+        READ_OR_RETURN(&tempNVectors, sizeof(tempNVectors));
+
+        uint32 groups;
+        uint32 RootWMOID;
         char blockId[5];
         blockId[4] = 0;
         int blocksize;
-        int readOperation = 0;
-
-        READ_OR_RETURN(&mogpflags, sizeof(uint32));
-        READ_OR_RETURN(&GroupWMOID, sizeof(uint32));
-
-            
-        Vector3 vec1, vec2;
-        READ_OR_RETURN(&vec1, sizeof(Vector3));
-
-        READ_OR_RETURN(&vec2, sizeof(Vector3));
-        bounds.set(vec1, vec2);
-        
-        READ_OR_RETURN(&liquidflags, sizeof(uint32));
-
-        // will this ever be used? what is it good for anyway??
-        uint32 branches;
-        READ_OR_RETURN(&blockId, 4);
-        CMP_OR_RETURN(blockId, "GRP ");
-        READ_OR_RETURN(&blocksize, sizeof(int));
-        READ_OR_RETURN(&branches, sizeof(uint32));
-        for (uint32 b=0; b<branches; ++b)
-        {
-            uint32 indexes;
-            // indexes for each branch (not used jet)
-            READ_OR_RETURN(&indexes, sizeof(uint32));
-        }
 
-        // ---- indexes
-        READ_OR_RETURN(&blockId, 4);
-        CMP_OR_RETURN(blockId, "INDX");
-        READ_OR_RETURN(&blocksize, sizeof(int));
-        uint32 nindexes;
-        READ_OR_RETURN(&nindexes, sizeof(uint32));
-        if (nindexes >0)
+        READ_OR_RETURN(&groups, sizeof(uint32));
+        READ_OR_RETURN(&RootWMOID, sizeof(uint32));
+
+        std::vector<GroupModel> groupsArray;
+
+        for (uint32 g=0; g<groups; ++g)
         {
-            uint16 *indexarray = new uint16[nindexes];
-            READ_OR_RETURN_WITH_DELETE(indexarray, nindexes*sizeof(uint16));
-            triangles.reserve(nindexes / 3);
-            for (uint32 i=0; i<nindexes; i+=3)
-                triangles.push_back(MeshTriangle(indexarray[i], indexarray[i+1], indexarray[i+2]));
+            std::vector<MeshTriangle> triangles;
+            std::vector<Vector3> vertexArray;
 
-            delete[] indexarray;
-        }
+            uint32 mogpflags, GroupWMOID;
+            READ_OR_RETURN(&mogpflags, sizeof(uint32));
+            READ_OR_RETURN(&GroupWMOID, sizeof(uint32));
 
-        // ---- vectors
-        READ_OR_RETURN(&blockId, 4);
-        CMP_OR_RETURN(blockId, "VERT");
-        READ_OR_RETURN(&blocksize, sizeof(int));
-        uint32 nvectors;
-        READ_OR_RETURN(&nvectors, sizeof(uint32));
+            float bbox1[3], bbox2[3];
+            READ_OR_RETURN(bbox1, sizeof(float)*3);
+            READ_OR_RETURN(bbox2, sizeof(float)*3);
 
-        if (nvectors >0)
-        {
-            float *vectorarray = new float[nvectors*3];
-            READ_OR_RETURN_WITH_DELETE(vectorarray, nvectors*sizeof(float)*3);
-            for (uint32 i=0; i<nvectors; ++i)
-                vertexArray.push_back( Vector3(vectorarray + 3*i) );
+            uint32 liquidflags;
+            READ_OR_RETURN(&liquidflags, sizeof(uint32));
 
-            delete[] vectorarray;
-        }
-        // ----- liquid
-        liquid = 0;
-        if (liquidflags& 1)
-        {
-            WMOLiquidHeader hlq;
+            // will this ever be used? what is it good for anyway??
+            uint32 branches;
             READ_OR_RETURN(&blockId, 4);
-            CMP_OR_RETURN(blockId, "LIQU");
+            CMP_OR_RETURN(blockId, "GRP ");
             READ_OR_RETURN(&blocksize, sizeof(int));
-            READ_OR_RETURN(&hlq, sizeof(WMOLiquidHeader));
-            liquid = new WmoLiquid(hlq.xtiles, hlq.ytiles, Vector3(hlq.pos_x, hlq.pos_y, hlq.pos_z), hlq.type);
-            uint32 size = hlq.xverts*hlq.yverts;
-            READ_OR_RETURN(liquid->GetHeightStorage(), size*sizeof(float));
-            size = hlq.xtiles*hlq.ytiles;
-            READ_OR_RETURN(liquid->GetFlagsStorage(), size);
-        }
-     
-        return true;
-    }
-
+            READ_OR_RETURN(&branches, sizeof(uint32));
+            for (uint32 b=0; b<branches; ++b)
+            {
+                uint32 indexes;
+                // indexes for each branch (not used jet)
+                READ_OR_RETURN(&indexes, sizeof(uint32));
+            }
 
-    GroupModel_Raw::~GroupModel_Raw()
-    {
-        delete liquid;
-    }
-    
-    bool WorldModel_Raw::Read(const char * path)
-    {
-        FILE* rf = fopen(path, "rb");
-        if (!rf)
-        {
-            printf("ERROR: Can't open raw model file: %s\n", path);
-            return false;
-        }
-        
-        char ident[8];
-        int readOperation = 0;
+            // ---- indexes
+            READ_OR_RETURN(&blockId, 4);
+            CMP_OR_RETURN(blockId, "INDX");
+            READ_OR_RETURN(&blocksize, sizeof(int));
+            uint32 nindexes;
+            READ_OR_RETURN(&nindexes, sizeof(uint32));
+            if (nindexes >0)
+            {
+                uint16 *indexarray = new uint16[nindexes];
+                READ_OR_RETURN_WITH_DELETE(indexarray, nindexes*sizeof(uint16));
+                for (uint32 i=0; i<nindexes; i+=3)
+                {
+                    triangles.push_back(MeshTriangle(indexarray[i], indexarray[i+1], indexarray[i+2]));
+                }
+                delete[] indexarray;
+            }
 
-        READ_OR_RETURN(&ident, 8);
-        CMP_OR_RETURN(ident, RAW_VMAP_MAGIC);
+            // ---- vectors
+            READ_OR_RETURN(&blockId, 4);
+            CMP_OR_RETURN(blockId, "VERT");
+            READ_OR_RETURN(&blocksize, sizeof(int));
+            uint32 nvectors;
+            READ_OR_RETURN(&nvectors, sizeof(uint32));
 
-        // we have to read one int. This is needed during the export and we have to skip it here
-        uint32 tempNVectors;
-        READ_OR_RETURN(&tempNVectors, sizeof(tempNVectors));
+            if (nvectors >0)
+            {
+                float *vectorarray = new float[nvectors*3];
+                READ_OR_RETURN_WITH_DELETE(vectorarray, nvectors*sizeof(float)*3);
+                for (uint32 i=0; i<nvectors; ++i)
+                {
+                    vertexArray.push_back( Vector3(vectorarray + 3*i) );
+                }
+                delete[] vectorarray;
+            }
+            // ----- liquid
+            WmoLiquid* liquid = 0;
+            if (liquidflags& 1)
+            {
+                WMOLiquidHeader hlq;
+                READ_OR_RETURN(&blockId, 4);
+                CMP_OR_RETURN(blockId, "LIQU");
+                READ_OR_RETURN(&blocksize, sizeof(int));
+                READ_OR_RETURN(&hlq, sizeof(WMOLiquidHeader));
+                liquid = new WmoLiquid(hlq.xtiles, hlq.ytiles, Vector3(hlq.pos_x, hlq.pos_y, hlq.pos_z), hlq.type);
+                uint32 size = hlq.xverts*hlq.yverts;
+                READ_OR_RETURN(liquid->GetHeightStorage(), size*sizeof(float));
+                size = hlq.xtiles*hlq.ytiles;
+                READ_OR_RETURN(liquid->GetFlagsStorage(), size);
+            }
 
-        uint32 groups;
-        READ_OR_RETURN(&groups, sizeof(uint32));
-        READ_OR_RETURN(&RootWMOID, sizeof(uint32));
+            groupsArray.push_back(GroupModel(mogpflags, GroupWMOID, AABox(Vector3(bbox1), Vector3(bbox2))));
+            groupsArray.back().setMeshData(vertexArray, triangles);
+            groupsArray.back().setLiquidData(liquid);
 
-        groupsArray.resize(groups);
-        bool succeed = true;
-        for (uint32 g = 0; g < groups && succeed; ++g)
-            succeed = groupsArray[g].Read(rf);
+            // drop of temporary use defines
+            #undef READ_OR_RETURN
+            #undef READ_OR_RETURN_WITH_DELETE
+            #undef CMP_OR_RETURN
 
+        }
         fclose(rf);
-        return succeed;
-    }
 
-    // drop of temporary use defines
-    #undef READ_OR_RETURN
-    #undef CMP_OR_RETURN
+        // write WorldModel
+        WorldModel model;
+        model.setRootWmoID(RootWMOID);
+        if (!groupsArray.empty())
+        {
+            model.setGroupModels(groupsArray);
+
+            std::string worldModelFileName(iDestDir);
+            worldModelFileName.push_back('/');
+            worldModelFileName.append(pModelFilename).append(".vmo");
+            success = model.writeFile(worldModelFileName);
+        }
+
+        //std::cout << "readRawFile2: '" << pModelFilename << "' tris: " << nElements << " nodes: " << nNodes << std::endl;
+        return success;
+    }
 }
diff --git a/src/server/collision/Maps/TileAssembler.h b/src/server/collision/Maps/TileAssembler.h
index 554940a..6128a0d 100755
--- a/src/server/collision/Maps/TileAssembler.h
+++ b/src/server/collision/Maps/TileAssembler.h
@@ -22,10 +22,8 @@
 #include <G3D/Vector3.h>
 #include <G3D/Matrix3.h>
 #include <map>
-#include <set>
 
 #include "ModelInstance.h"
-#include "WorldModel.h"
 
 namespace VMAP
 {
@@ -63,31 +61,6 @@ namespace VMAP
     typedef std::map<uint32, MapSpawns*> MapData;
     //===============================================
 
-    struct GroupModel_Raw
-    {
-        uint32 mogpflags;
-        uint32 GroupWMOID;
-
-        G3D::AABox bounds;
-        uint32 liquidflags;
-        std::vector<MeshTriangle> triangles;
-        std::vector<G3D::Vector3> vertexArray;
-        class WmoLiquid *liquid;
-
-        GroupModel_Raw() : liquid(0) {}
-        ~GroupModel_Raw();
-
-        bool Read(FILE * f);
-    };
-
-    struct WorldModel_Raw
-    {
-        uint32 RootWMOID;
-        std::vector<GroupModel_Raw> groupsArray;
-
-        bool Read(const char * path);
-    };
-
     class TileAssembler
     {
         private:
@@ -97,7 +70,6 @@ namespace VMAP
             G3D::Table<std::string, unsigned int > iUniqueNameIds;
             unsigned int iCurrentUniqueNameId;
             MapData mapData;
-            std::set<std::string> spawnedModelFiles;
 
         public:
             TileAssembler(const std::string& pSrcDirName, const std::string& pDestDirName);
@@ -106,7 +78,6 @@ namespace VMAP
             bool convertWorld2();
             bool readMapSpawns();
             bool calculateTransformedBound(ModelSpawn &spawn);
-            void exportGameobjectModels();
 
             bool convertRawFile(const std::string& pModelFilename);
             void setModelNameFilterMethod(bool (*pFilterMethod)(char *pName)) { iFilterMethod = pFilterMethod; }
diff --git a/src/server/collision/Models/GameObjectModel.cpp b/src/server/collision/Models/GameObjectModel.cpp
deleted file mode 100644
index 5ad984f..0000000
--- a/src/server/collision/Models/GameObjectModel.cpp
+++ /dev/null
@@ -1,175 +0,0 @@
-/*
- * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
- * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program. If not, see <http://www.gnu.org/licenses/>.
- */
- 
-#include "VMapFactory.h"
-#include "VMapManager2.h"
-#include "VMapDefinitions.h"
-#include "WorldModel.h"
-
-#include "GameObjectModel.h"
-#include "Log.h"
-#include "GameObject.h"
-#include "Creature.h"
-#include "TemporarySummon.h"
-#include "Object.h"
-#include "DBCStores.h"
-
-using G3D::Vector3;
-using G3D::Ray;
-using G3D::AABox;
-
-struct GameobjectModelData
-{
-    GameobjectModelData(const std::string& name_, const AABox& box) :
-        name(name_), bound(box) {}
-
-    AABox bound;
-    std::string name;
-};
-
-typedef UNORDERED_MAP<uint32, GameobjectModelData> ModelList;
-ModelList model_list;
-
-void LoadGameObjectModelList()
-{
-    FILE* model_list_file = fopen((sWorld->GetDataPath() + "vmaps/" + VMAP::GAMEOBJECT_MODELS).c_str(), "rb");
-    if (!model_list_file)
-        return;
-
-    uint32 name_length, displayId;
-    char buff[500];
-    while (!feof(model_list_file))
-    {
-        fread(&displayId,sizeof(uint32),1,model_list_file);
-        fread(&name_length,sizeof(uint32),1,model_list_file);
-
-        if (name_length >= sizeof(buff))
-        {
-            printf("\nFile '%s' seems to be corrupted", VMAP::GAMEOBJECT_MODELS);
-            break;
-        }
-
-        fread(&buff, sizeof(char), name_length,model_list_file);
-        Vector3 v1, v2;
-        fread(&v1, sizeof(Vector3), 1, model_list_file);
-        fread(&v2, sizeof(Vector3), 1, model_list_file);
-
-        model_list.insert
-        (
-            ModelList::value_type( displayId, GameobjectModelData(std::string(buff,name_length),AABox(v1,v2)) )
-        );
-    }
-    fclose(model_list_file);
-}
-
-GameObjectModel::~GameObjectModel()
-{
-    if (iModel)
-        ((VMAP::VMapManager2*)VMAP::VMapFactory::createOrGetVMapManager())->releaseModelInstance(name);
-}
-
-bool GameObjectModel::initialize(const GameObject& go, const GameObjectDisplayInfoEntry& info)
-{
-    ModelList::const_iterator it = model_list.find(info.Displayid);
-    if (it == model_list.end())
-        return false;
-
-    G3D::AABox mdl_box(it->second.bound);
-    // ignore models with no bounds
-    if (mdl_box == G3D::AABox::zero())
-    {
-        std::cout << "Model " << it->second.name << " has zero bounds, loading skipped" << std::endl;
-        return false;
-    }
-
-    iModel = ((VMAP::VMapManager2*)VMAP::VMapFactory::createOrGetVMapManager())->acquireModelInstance(sWorld->GetDataPath() + "vmaps/", it->second.name);
-
-    if (!iModel)
-        return false;
-
-    name = it->second.name;
-    //flags = VMAP::MOD_M2;
-    //adtId = 0;
-    //ID = 0;
-    iPos = Vector3(go.GetPositionX(), go.GetPositionY(), go.GetPositionZ());
-    phasemask = go.GetPhaseMask();
-    iScale = go.GetFloatValue(OBJECT_FIELD_SCALE_X);
-    iInvScale = 1.f / iScale;
-
-    G3D::Matrix3 iRotation = G3D::Matrix3::fromEulerAnglesZYX(go.GetOrientation(), 0, 0);
-    iInvRot = iRotation.inverse();
-    // transform bounding box:
-    mdl_box = AABox(mdl_box.low() * iScale, mdl_box.high() * iScale);
-    AABox rotated_bounds;
-    for (int i = 0; i < 8; ++i)
-        rotated_bounds.merge(iRotation * mdl_box.corner(i));
-
-    this->iBound = rotated_bounds + iPos;
-#ifdef SPAWN_CORNERS
-    // test:
-    for (int i = 0; i < 8; ++i)
-    {
-        Vector3 pos(iBound.corner(i));
-        if (Creature* c = const_cast<GameObject&>(go).SummonCreature(24440, pos.x, pos.y, pos.z, 0, TEMPSUMMON_MANUAL_DESPAWN))
-        {
-            c->setFaction(35);
-            c->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.1f);
-        }
-    }
-#endif
-
-    return true;
-}
-
-GameObjectModel* GameObjectModel::Create(const GameObject& go)
-{
-    const GameObjectDisplayInfoEntry* info = sGameObjectDisplayInfoStore.LookupEntry(go.GetGOInfo()->displayId);
-    if (!info)
-        return NULL;
-
-    GameObjectModel* mdl = new GameObjectModel();
-    if (!mdl->initialize(go, *info))
-    {
-        delete mdl;
-        return NULL;
-    }
-
-    return mdl;
-}
-
-bool GameObjectModel::intersectRay(const G3D::Ray& ray, float& MaxDist, bool StopAtFirstHit, uint32 ph_mask) const
-{
-    if (!(phasemask & ph_mask))
-        return false;
-
-    float time = ray.intersectionTime(iBound);
-    if (time == G3D::inf())
-        return false;
-
-    // child bounds are defined in object space:
-    Vector3 p = iInvRot * (ray.origin() - iPos) * iInvScale;
-    Ray modRay(p, iInvRot * ray.direction());
-    float distance = MaxDist * iInvScale;
-    bool hit = iModel->IntersectRay(modRay, distance, StopAtFirstHit);
-    if(hit)
-    {
-        distance *= iScale;
-        MaxDist = distance;
-    }
-    return hit;
-}
\ No newline at end of file
diff --git a/src/server/collision/Models/GameObjectModel.h b/src/server/collision/Models/GameObjectModel.h
deleted file mode 100644
index 413061c..0000000
--- a/src/server/collision/Models/GameObjectModel.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
- * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program. If not, see <http://www.gnu.org/licenses/>.
- */
- 
-#ifndef _GAMEOBJECT_MODEL_H
-#define _GAMEOBJECT_MODEL_H
-
-#include <G3D/Matrix3.h>
-#include <G3D/Vector3.h>
-#include <G3D/AABox.h>
-#include <G3D/Ray.h>
-
-#include "Define.h"
-
-namespace VMAP
-{
-    class WorldModel;
-}
-
-class GameObject;
-struct GameObjectDisplayInfoEntry;
-
-class GameObjectModel /*, public Intersectable*/
-{
-    uint32 phasemask;
-    G3D::AABox iBound;
-    G3D::Matrix3 iInvRot;
-    G3D::Vector3 iPos;
-    //G3D::Vector3 iRot;
-    float iInvScale;
-    float iScale;
-    VMAP::WorldModel* iModel;
-
-    GameObjectModel() : phasemask(0), iModel(NULL) {}
-    bool initialize(const GameObject& go, const GameObjectDisplayInfoEntry& info);
-
-public:
-    std::string name;
-
-    const G3D::AABox& getBounds() const { return iBound; }
-
-    ~GameObjectModel();
-
-    const G3D::Vector3& getPosition() const { return iPos;}
-
-    /**	Enables\disables collision. */
-    void disable() { phasemask = 0;}
-    void enable(uint32 ph_mask) { phasemask = ph_mask;}
-
-    bool intersectRay(const G3D::Ray& Ray, float& MaxDist, bool StopAtFirstHit, uint32 ph_mask) const;
-
-    static GameObjectModel* Create(const GameObject& go);
-};
-
-#endif // _GAMEOBJECT_MODEL_H
\ No newline at end of file
diff --git a/src/server/collision/Models/WorldModel.h b/src/server/collision/Models/WorldModel.h
index ebf828e..52ecf49 100755
--- a/src/server/collision/Models/WorldModel.h
+++ b/src/server/collision/Models/WorldModel.h
@@ -80,7 +80,7 @@ namespace VMAP
 
             //! pass mesh data to object and create BIH. Passed vectors get get swapped with old geometry!
             void setMeshData(std::vector<Vector3> &vert, std::vector<MeshTriangle> &tri);
-            void setLiquidData(WmoLiquid*& liquid) { iLiquid = liquid; liquid = NULL; }
+            void setLiquidData(WmoLiquid* liquid) { iLiquid = liquid; }
             bool IntersectRay(const G3D::Ray &ray, float &distance, bool stopAtFirstHit) const;
             bool IsInsideObject(const Vector3 &pos, const Vector3 &down, float &z_dist) const;
             bool GetLiquidLevel(const Vector3 &pos, float &liqHeight) const;
diff --git a/src/server/collision/RegularGrid.h b/src/server/collision/RegularGrid.h
deleted file mode 100644
index be61504..0000000
--- a/src/server/collision/RegularGrid.h
+++ /dev/null
@@ -1,218 +0,0 @@
-#ifndef _REGULAR_GRID_H
-#define _REGULAR_GRID_H
-
-
-#include <G3D/Ray.h>
-#include <G3D/AABox.h>
-#include <G3D/Table.h>
-#include <G3D/BoundsTrait.h>
-#include <G3D/PositionTrait.h>
-
-#include "Errors.h"
-
-using G3D::Vector2;
-using G3D::Vector3;
-using G3D::AABox;
-using G3D::Ray;
-
-template<class Node>
-struct NodeCreator{
-    static Node * makeNode(int x, int y) { return new Node();}
-};
-
-template<class T,
-class Node,
-class NodeCreatorFunc = NodeCreator<Node>,
-    /*class BoundsFunc = BoundsTrait<T>,*/
-class PositionFunc = PositionTrait<T>
->
-class RegularGrid2D
-{
-public:
-
-    enum{
-        CELL_NUMBER = 64,
-    };
-
-    #define HGRID_MAP_SIZE  (533.33333f * 64.f)     // shouldn't be changed
-    #define CELL_SIZE       float(HGRID_MAP_SIZE/(float)CELL_NUMBER)
-
-    typedef G3D::Table<const T*, Node*> MemberTable;
-
-    MemberTable memberTable;
-    Node* nodes[CELL_NUMBER][CELL_NUMBER];
-
-    RegularGrid2D(){
-        memset(nodes, 0, sizeof(nodes));
-    }
-
-    ~RegularGrid2D(){
-        for (int x = 0; x < CELL_NUMBER; ++x)
-            for (int y = 0; y < CELL_NUMBER; ++y)
-                delete nodes[x][y];
-    }
-
-    void insert(const T& value)
-    {
-        Vector3 pos;
-        PositionFunc::getPosition(value, pos);
-        Node& node = getGridFor(pos.x, pos.y);
-        node.insert(value);
-        memberTable.set(&value, &node);
-    }
-
-    void remove(const T& value)
-    {
-        memberTable[&value]->remove(value);
-        // Remove the member
-        memberTable.remove(&value);
-    }
-
-    void balance()
-    {
-        for (int x = 0; x < CELL_NUMBER; ++x)
-            for (int y = 0; y < CELL_NUMBER; ++y)
-                if (Node* n = nodes[x][y])
-                    n->balance();
-    }
-
-    bool contains(const T& value) const { return memberTable.containsKey(&value); }
-    int size() const { return memberTable.size(); }
-
-    struct Cell
-    {
-        int x, y;
-        bool operator == (const Cell& c2) const { return x == c2.x && y == c2.y;}
-
-        static Cell ComputeCell(float fx, float fy)
-        {
-            Cell c = {fx * (1.f/CELL_SIZE) + (CELL_NUMBER/2), fy * (1.f/CELL_SIZE) + (CELL_NUMBER/2)};
-            return c;
-        }
-
-        bool isValid() const { return x >= 0 && x < CELL_NUMBER && y >= 0 && y < CELL_NUMBER;}
-    };
-
-
-    Node& getGridFor(float fx, float fy)
-    {
-        Cell c = Cell::ComputeCell(fx, fy);
-        return getGrid(c.x, c.y);
-    }
-
-    Node& getGrid(int x, int y)
-    {
-        ASSERT(x < CELL_NUMBER && y < CELL_NUMBER);
-        if (!nodes[x][y])
-            nodes[x][y] = NodeCreatorFunc::makeNode(x,y);
-        return *nodes[x][y];
-    }
-
-    template<typename RayCallback>
-    void intersectRay(const Ray& ray, RayCallback& intersectCallback, float max_dist)
-    {
-        intersectRay(ray, intersectCallback, max_dist, ray.origin() + ray.direction() * max_dist);
-    }
-
-    template<typename RayCallback>
-    void intersectRay(const Ray& ray, RayCallback& intersectCallback, float& max_dist, const Vector3& end)
-    {
-        Cell cell = Cell::ComputeCell(ray.origin().x, ray.origin().y);
-        if (!cell.isValid())
-            return;
-
-        Cell last_cell = Cell::ComputeCell(end.x, end.y);
-
-        if (cell == last_cell)
-        {
-            if (Node* node = nodes[cell.x][cell.y])
-                node->intersectRay(ray, intersectCallback, max_dist);
-            return;
-        }
-
-        float voxel = (float)CELL_SIZE;
-        float kx_inv = ray.invDirection().x, bx = ray.origin().x;
-        float ky_inv = ray.invDirection().y, by = ray.origin().y;
-
-        int stepX, stepY;
-        float tMaxX, tMaxY; 
-        if (kx_inv >= 0)
-        {
-            stepX = 1;
-            float x_border = (cell.x+1) * voxel;
-            tMaxX = (x_border - bx) * kx_inv;
-        }
-        else
-        {
-            stepX = -1;
-            float x_border = (cell.x-1) * voxel;
-            tMaxX = (x_border - bx) * kx_inv;
-        }
-
-        if (ky_inv >= 0)
-        {
-            stepY = 1;
-            float y_border = (cell.y+1) * voxel;
-            tMaxY = (y_border - by) * ky_inv;
-        }
-        else
-        {
-            stepY = -1;
-            float y_border = (cell.y-1) * voxel;
-            tMaxY = (y_border - by) * ky_inv;
-        }
-
-        //int Cycles = std::max((int)ceilf(max_dist/tMaxX),(int)ceilf(max_dist/tMaxY));
-        //int i = 0;
-
-        float tDeltaX = voxel * fabs(kx_inv);
-        float tDeltaY = voxel * fabs(ky_inv);
-        do
-        {
-            if (Node* node = nodes[cell.x][cell.y])
-            {
-                //float enterdist = max_dist;
-                node->intersectRay(ray, intersectCallback, max_dist);
-            }
-            if (cell == last_cell)
-                break;
-            if(tMaxX < tMaxY)
-            {
-                tMaxX += tDeltaX;
-                cell.x += stepX;
-            }
-            else
-            {
-                tMaxY += tDeltaY;
-                cell.y += stepY;
-            }
-            //++i;
-        } while (cell.isValid());
-    }
-
-    template<typename IsectCallback>
-    void intersectPoint(const Vector3& point, IsectCallback& intersectCallback)
-    {
-        Cell cell = Cell::ComputeCell(point.x, point.y);
-        if (!cell.isValid())
-            return;
-        if (Node* node = nodes[cell.x][cell.y])
-            node->intersectPoint(point, intersectCallback);
-    }
-
-    // Optimized verson of intersectRay function for rays with vertical directions
-    template<typename RayCallback>
-    void intersectZAllignedRay(const Ray& ray, RayCallback& intersectCallback, float& max_dist)
-    {
-        Cell cell = Cell::ComputeCell(ray.origin().x, ray.origin().y);
-        if (!cell.isValid())
-            return;
-        if (Node* node = nodes[cell.x][cell.y])
-            node->intersectRay(ray, intersectCallback, max_dist);
-    }
-};
-
-#undef CELL_SIZE
-#undef HGRID_MAP_SIZE
-
-#endif 
\ No newline at end of file
diff --git a/src/server/collision/VMapDefinitions.h b/src/server/collision/VMapDefinitions.h
index b98d01c..f7d6f0d 100644
--- a/src/server/collision/VMapDefinitions.h
+++ b/src/server/collision/VMapDefinitions.h
@@ -25,8 +25,6 @@
 namespace VMAP
 {
     const char VMAP_MAGIC[] = "VMAP_3.0";
-    const char RAW_VMAP_MAGIC[] = "VMAP003";                // used in extracted vmap files with raw data
-    const char GAMEOBJECT_MODELS[] = "temp_gameobject_models";
 
     // defined in TileAssembler.cpp currently...
     bool readChunk(FILE* rf, char *dest, const char *compare, uint32 len);
diff --git a/src/server/game/AI/CoreAI/CombatAI.cpp b/src/server/game/AI/CoreAI/CombatAI.cpp
index a83fb6f..03d1b97 100755
--- a/src/server/game/AI/CoreAI/CombatAI.cpp
+++ b/src/server/game/AI/CoreAI/CombatAI.cpp
@@ -99,7 +99,7 @@ void CombatAI::UpdateAI(const uint32 diff)
 
     events.Update(diff);
 
-    if (me->HasUnitState(UNIT_STAT_CASTING))
+    if (me->HasUnitState(UNIT_STATE_CASTING))
         return;
 
     if (uint32 spellId = events.ExecuteEvent())
@@ -158,7 +158,13 @@ void CasterAI::UpdateAI(const uint32 diff)
 
     events.Update(diff);
 
-    if (me->HasUnitState(UNIT_STAT_CASTING))
+    if (me->getVictim()->HasBreakableByDamageCrowdControlAura())
+    {
+        me->InterruptNonMeleeSpells(false);
+        return;
+    }
+
+    if (me->HasUnitState(UNIT_STATE_CASTING))
         return;
 
     if (uint32 spellId = events.ExecuteEvent())
diff --git a/src/server/game/AI/CoreAI/PassiveAI.cpp b/src/server/game/AI/CoreAI/PassiveAI.cpp
index 1244e03..3738d5b 100755
--- a/src/server/game/AI/CoreAI/PassiveAI.cpp
+++ b/src/server/game/AI/CoreAI/PassiveAI.cpp
@@ -61,14 +61,14 @@ void PossessedAI::KilledUnit(Unit* victim)
 
 void CritterAI::DamageTaken(Unit* /*done_by*/, uint32&)
 {
-    if (!me->HasUnitState(UNIT_STAT_FLEEING))
-        me->SetControlled(true, UNIT_STAT_FLEEING);
+    if (!me->HasUnitState(UNIT_STATE_FLEEING))
+        me->SetControlled(true, UNIT_STATE_FLEEING);
 }
 
 void CritterAI::EnterEvadeMode()
 {
-    if (me->HasUnitState(UNIT_STAT_FLEEING))
-        me->SetControlled(false, UNIT_STAT_FLEEING);
+    if (me->HasUnitState(UNIT_STATE_FLEEING))
+        me->SetControlled(false, UNIT_STATE_FLEEING);
     CreatureAI::EnterEvadeMode();
 }
 
diff --git a/src/server/game/AI/CoreAI/PetAI.cpp b/src/server/game/AI/CoreAI/PetAI.cpp
index 015e204..e07042d 100755
--- a/src/server/game/AI/CoreAI/PetAI.cpp
+++ b/src/server/game/AI/CoreAI/PetAI.cpp
@@ -42,7 +42,6 @@ PetAI::PetAI(Creature* c) : CreatureAI(c), i_tracker(TIME_INTERVAL_LOOK)
 {
     m_AllySet.clear();
     UpdateAllies();
-    targetHasCC = false;
 }
 
 void PetAI::EnterEvadeMode()
@@ -55,9 +54,6 @@ bool PetAI::_needToStop()
     if (me->isCharmed() && me->getVictim() == me->GetCharmer())
         return true;
 
-    if (_CheckTargetCC(me->getVictim()) && !targetHasCC)
-        return true;
-
     return !me->IsValidAttackTarget(me->getVictim());
 }
 
@@ -95,13 +91,19 @@ void PetAI::UpdateAI(const uint32 diff)
     // me->getVictim() can't be used for check in case stop fighting, me->getVictim() clear at Unit death etc.
     if (me->getVictim())
     {
+        // is only necessary to stop casting, the pet must not exit combat
+        if (me->getVictim()->HasBreakableByDamageCrowdControlAura())
+        {
+            me->InterruptNonMeleeSpells(false);
+            return;
+        }
+
         if (_needToStop())
         {
             sLog->outStaticDebug("Pet AI stopped attacking [guid=%u]", me->GetGUIDLow());
             _stopAttack();
             return;
         }
-        targetHasCC = _CheckTargetCC(me->getVictim());
 
         DoMeleeAttackIfReady();
     }
@@ -116,14 +118,14 @@ void PetAI::UpdateAI(const uint32 diff)
         else
             HandleReturnMovement();
     }
-    else if (owner && !me->HasUnitState(UNIT_STAT_FOLLOW)) // no charm info and no victim
+    else if (owner && !me->HasUnitState(UNIT_STATE_FOLLOW)) // no charm info and no victim
         me->GetMotionMaster()->MoveFollow(owner, PET_FOLLOW_DIST, me->GetFollowAngle());
 
     if (!me->GetCharmInfo())
         return;
 
     // Autocast (casted only in combat or persistent spells in any state)
-    if (!me->HasUnitState(UNIT_STAT_CASTING))
+    if (!me->HasUnitState(UNIT_STATE_CASTING))
     {
         typedef std::vector<std::pair<Unit*, Spell*> > TargetSpellList;
         TargetSpellList targetSpellStore;
@@ -293,8 +295,6 @@ void PetAI::AttackStart(Unit* target)
     if (!CanAttack(target))
         return;
 
-    targetHasCC = _CheckTargetCC(target);
-
     if (Unit* owner = me->GetOwner())
         owner->SetInCombatWith(target);
 
@@ -310,22 +310,21 @@ Unit* PetAI::SelectNextTarget()
         return NULL;
 
     Unit* target = me->getAttackerForHelper();
-    targetHasCC = false;
 
     // Check pet's attackers first to prevent dragging mobs back to owner
-    if (target && !_CheckTargetCC(target))
+    if (target && !target->HasBreakableByDamageCrowdControlAura())
         return target;
 
     if (me->GetCharmerOrOwner())
     {
         // Check owner's attackers if pet didn't have any
         target = me->GetCharmerOrOwner()->getAttackerForHelper();
-        if (target && !_CheckTargetCC(target))
+        if (target && !target->HasBreakableByDamageCrowdControlAura())
             return target;
 
         // 3.0.2 - Pets now start attacking their owners target in defensive mode as soon as the hunter does
         target = me->GetCharmerOrOwner()->getVictim();
-        if (target && !_CheckTargetCC(target))
+        if (target && !target->HasBreakableByDamageCrowdControlAura())
             return target;
     }
 
@@ -467,11 +466,3 @@ bool PetAI::CanAttack(Unit* target)
     // default, though we shouldn't ever get here
     return false;
 }
-
-bool PetAI::_CheckTargetCC(Unit* target)
-{
-    if (me->GetCharmerOrOwnerGUID() && target->HasNegativeAuraWithAttribute(SPELL_ATTR0_BREAKABLE_BY_DAMAGE, me->GetCharmerOrOwnerGUID()))
-        return true;
-
-    return false;
-}
diff --git a/src/server/game/AI/CoreAI/PetAI.h b/src/server/game/AI/CoreAI/PetAI.h
index 847b414..730ab12 100755
--- a/src/server/game/AI/CoreAI/PetAI.h
+++ b/src/server/game/AI/CoreAI/PetAI.h
@@ -50,7 +50,6 @@ class PetAI : public CreatureAI
 
         TimeTracker i_tracker;
         bool inCombat;
-        bool targetHasCC;
         std::set<uint64> m_AllySet;
         uint32 m_updateAlliesTimer;
 
@@ -58,7 +57,6 @@ class PetAI : public CreatureAI
         void HandleReturnMovement();
         void DoAttack(Unit* target, bool chase);
         bool CanAttack(Unit* target);
-        bool _CheckTargetCC(Unit* target);
 };
 #endif
 
diff --git a/src/server/game/AI/CoreAI/UnitAI.cpp b/src/server/game/AI/CoreAI/UnitAI.cpp
index 38504b9..bf50909 100755
--- a/src/server/game/AI/CoreAI/UnitAI.cpp
+++ b/src/server/game/AI/CoreAI/UnitAI.cpp
@@ -40,7 +40,7 @@ void UnitAI::AttackStartCaster(Unit* victim, float dist)
 
 void UnitAI::DoMeleeAttackIfReady()
 {
-    if (me->HasUnitState(UNIT_STAT_CASTING))
+    if (me->HasUnitState(UNIT_STATE_CASTING))
         return;
 
     Unit* victim = me->getVictim();
@@ -60,7 +60,7 @@ void UnitAI::DoMeleeAttackIfReady()
 
 bool UnitAI::DoSpellAttackIfReady(uint32 spell)
 {
-    if (me->HasUnitState(UNIT_STAT_CASTING))
+    if (me->HasUnitState(UNIT_STATE_CASTING))
         return true;
 
     if (me->isAttackReady())
diff --git a/src/server/game/AI/CreatureAIImpl.h b/src/server/game/AI/CreatureAIImpl.h
index 147e829..f568da8 100755
--- a/src/server/game/AI/CreatureAIImpl.h
+++ b/src/server/game/AI/CreatureAIImpl.h
@@ -596,7 +596,7 @@ inline bool CreatureAI::_EnterEvadeMode()
 
 inline void UnitAI::DoCast(Unit* victim, uint32 spellId, bool triggered)
 {
-    if (!victim || (me->HasUnitState(UNIT_STAT_CASTING) && !triggered))
+    if (!victim || (me->HasUnitState(UNIT_STATE_CASTING) && !triggered))
         return;
 
     me->CastSpell(victim, spellId, triggered);
@@ -609,7 +609,7 @@ inline void UnitAI::DoCastVictim(uint32 spellId, bool triggered)
 
 inline void UnitAI::DoCastAOE(uint32 spellId, bool triggered)
 {
-    if (!triggered && me->HasUnitState(UNIT_STAT_CASTING))
+    if (!triggered && me->HasUnitState(UNIT_STATE_CASTING))
         return;
 
     me->CastSpell((Unit*)NULL, spellId, triggered);
diff --git a/src/server/game/AI/EventAI/CreatureEventAI.cpp b/src/server/game/AI/EventAI/CreatureEventAI.cpp
index c507262..5db9d0b 100755
--- a/src/server/game/AI/EventAI/CreatureEventAI.cpp
+++ b/src/server/game/AI/EventAI/CreatureEventAI.cpp
@@ -577,7 +577,7 @@ void CreatureEventAI::ProcessAction(CreatureEventAI_Action const& action, uint32
                 {
                     if (action.combat_movement.melee)
                     {
-                        me->AddUnitState(UNIT_STAT_MELEE_ATTACKING);
+                        me->AddUnitState(UNIT_STATE_MELEE_ATTACKING);
                         me->SendMeleeAttackStart(victim);
                     }
                     if (me->GetMotionMaster()->GetCurrentMovementGeneratorType() == IDLE_MOTION_TYPE)
@@ -591,7 +591,7 @@ void CreatureEventAI::ProcessAction(CreatureEventAI_Action const& action, uint32
                     Unit* victim = me->getVictim();
                     if (action.combat_movement.melee && victim)
                     {
-                        me->ClearUnitState(UNIT_STAT_MELEE_ATTACKING);
+                        me->ClearUnitState(UNIT_STATE_MELEE_ATTACKING);
                         me->SendMeleeAttackStop(victim);
                     }
                     if (me->GetMotionMaster()->GetCurrentMovementGeneratorType() == CHASE_MOTION_TYPE)
diff --git a/src/server/game/AI/ScriptedAI/ScriptedCreature.cpp b/src/server/game/AI/ScriptedAI/ScriptedCreature.cpp
index 1b6fde6..bd6c901 100644
--- a/src/server/game/AI/ScriptedAI/ScriptedCreature.cpp
+++ b/src/server/game/AI/ScriptedAI/ScriptedCreature.cpp
@@ -595,7 +595,7 @@ void BossAI::UpdateAI(uint32 const diff)
 
     events.Update(diff);
 
-    if (me->HasUnitState(UNIT_STAT_CASTING))
+    if (me->HasUnitState(UNIT_STATE_CASTING))
         return;
 
     while (uint32 eventId = events.ExecuteEvent())
@@ -654,7 +654,7 @@ void WorldBossAI::UpdateAI(uint32 const diff)
 
     events.Update(diff);
 
-    if (me->HasUnitState(UNIT_STAT_CASTING))
+    if (me->HasUnitState(UNIT_STATE_CASTING))
         return;
 
     while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/game/AI/ScriptedAI/ScriptedEscortAI.cpp b/src/server/game/AI/ScriptedAI/ScriptedEscortAI.cpp
index c5f04d4..048cc8b 100644
--- a/src/server/game/AI/ScriptedAI/ScriptedEscortAI.cpp
+++ b/src/server/game/AI/ScriptedAI/ScriptedEscortAI.cpp
@@ -90,7 +90,7 @@ bool npc_escortAI::AssistPlayerInCombat(Unit* who)
 
 void npc_escortAI::MoveInLineOfSight(Unit* who)
 {
-    if (!me->HasUnitState(UNIT_STAT_STUNNED) && who->isTargetableForAttack() && who->isInAccessiblePlaceFor(me))
+    if (!me->HasUnitState(UNIT_STATE_STUNNED) && who->isTargetableForAttack() && who->isInAccessiblePlaceFor(me))
     {
         if (HasEscortState(STATE_ESCORT_ESCORTING) && AssistPlayerInCombat(who))
             return;
diff --git a/src/server/game/AI/ScriptedAI/ScriptedFollowerAI.cpp b/src/server/game/AI/ScriptedAI/ScriptedFollowerAI.cpp
index 53747d0..d83ad9b 100644
--- a/src/server/game/AI/ScriptedAI/ScriptedFollowerAI.cpp
+++ b/src/server/game/AI/ScriptedAI/ScriptedFollowerAI.cpp
@@ -38,8 +38,8 @@ void FollowerAI::AttackStart(Unit* who)
         me->SetInCombatWith(who);
         who->SetInCombatWith(me);
 
-        if (me->HasUnitState(UNIT_STAT_FOLLOW))
-            me->ClearUnitState(UNIT_STAT_FOLLOW);
+        if (me->HasUnitState(UNIT_STATE_FOLLOW))
+            me->ClearUnitState(UNIT_STATE_FOLLOW);
 
         if (IsCombatMovementAllowed())
             me->GetMotionMaster()->MoveChase(who);
@@ -88,7 +88,7 @@ bool FollowerAI::AssistPlayerInCombat(Unit* who)
 
 void FollowerAI::MoveInLineOfSight(Unit* who)
 {
-    if (!me->HasUnitState(UNIT_STAT_STUNNED) && who->isTargetableForAttack() && who->isInAccessiblePlaceFor(me))
+    if (!me->HasUnitState(UNIT_STATE_STUNNED) && who->isTargetableForAttack() && who->isInAccessiblePlaceFor(me))
     {
         if (HasFollowState(STATE_FOLLOW_INPROGRESS) && AssistPlayerInCombat(who))
             return;
@@ -340,9 +340,9 @@ Player* FollowerAI::GetLeaderForFollower()
 
 void FollowerAI::SetFollowComplete(bool bWithEndEvent)
 {
-    if (me->HasUnitState(UNIT_STAT_FOLLOW))
+    if (me->HasUnitState(UNIT_STATE_FOLLOW))
     {
-        me->ClearUnitState(UNIT_STAT_FOLLOW);
+        me->ClearUnitState(UNIT_STATE_FOLLOW);
 
         me->StopMoving();
         me->GetMotionMaster()->Clear();
@@ -369,9 +369,9 @@ void FollowerAI::SetFollowPaused(bool paused)
     {
         AddFollowState(STATE_FOLLOW_PAUSED);
 
-        if (me->HasUnitState(UNIT_STAT_FOLLOW))
+        if (me->HasUnitState(UNIT_STATE_FOLLOW))
         {
-            me->ClearUnitState(UNIT_STAT_FOLLOW);
+            me->ClearUnitState(UNIT_STATE_FOLLOW);
 
             me->StopMoving();
             me->GetMotionMaster()->Clear();
diff --git a/src/server/game/AI/SmartScripts/SmartScript.cpp b/src/server/game/AI/SmartScripts/SmartScript.cpp
index 2b32946..a6923ea 100644
--- a/src/server/game/AI/SmartScripts/SmartScript.cpp
+++ b/src/server/game/AI/SmartScripts/SmartScript.cpp
@@ -2718,7 +2718,7 @@ void SmartScript::UpdateTimer(SmartScriptHolder& e, uint32 const diff)
         {
             if (!(e.action.cast.flags & SMARTCAST_INTERRUPT_PREVIOUS))
             {
-                if (me && me->HasUnitState(UNIT_STAT_CASTING))
+                if (me && me->HasUnitState(UNIT_STATE_CASTING))
                 {
                     e.timer = 1;
                     return;
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp
index 5e52976..1e12842 100755
--- a/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp
@@ -28,17 +28,6 @@
 #include "Player.h"
 #include "Util.h"
 
-// these variables aren't used outside of this file, so declare them only here
-uint32 BG_AB_HonorScoreTicks[BG_HONOR_MODE_NUM] = {
-    330, // normal honor
-    200  // holiday
-};
-
-uint32 BG_AB_ReputationScoreTicks[BG_HONOR_MODE_NUM] = {
-    200, // normal honor
-    150  // holiday
-};
-
 BattlegroundAB::BattlegroundAB()
 {
     m_BuffChange = true;
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundAB.h b/src/server/game/Battlegrounds/Zones/BattlegroundAB.h
index c86076f..50020a5 100755
--- a/src/server/game/Battlegrounds/Zones/BattlegroundAB.h
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundAB.h
@@ -176,10 +176,10 @@ enum BG_AB_Objectives
     AB_OBJECTIVE_DEFEND_BASE            = 123
 };
 
-#define BG_AB_NotABBGWeekendHonorTicks      330
-#define BG_AB_ABBGWeekendHonorTicks         200
-#define BG_AB_NotABBGWeekendReputationTicks 200
-#define BG_AB_ABBGWeekendReputationTicks    150
+#define BG_AB_NotABBGWeekendHonorTicks      260
+#define BG_AB_ABBGWeekendHonorTicks         160
+#define BG_AB_NotABBGWeekendReputationTicks 160
+#define BG_AB_ABBGWeekendReputationTicks    120
 
 #define AB_EVENT_START_BATTLE               9158 // Achievement: Let's Get This Done
 
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundEY.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundEY.cpp
index cbc3ec8..b7994d0 100755
--- a/src/server/game/Battlegrounds/Zones/BattlegroundEY.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundEY.cpp
@@ -30,8 +30,8 @@
 
 // these variables aren't used outside of this file, so declare them only here
 uint32 BG_EY_HonorScoreTicks[BG_HONOR_MODE_NUM] = {
-    330, // normal honor
-    200  // holiday
+    260, // normal honor
+    160  // holiday
 };
 
 BattlegroundEY::BattlegroundEY()
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundEY.h b/src/server/game/Battlegrounds/Zones/BattlegroundEY.h
index baa9ca3..026fbcc 100755
--- a/src/server/game/Battlegrounds/Zones/BattlegroundEY.h
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundEY.h
@@ -217,8 +217,8 @@ enum EYBattlegroundObjectTypes
     BG_EY_OBJECT_MAX                            = 59
 };
 
-#define BG_EY_NotEYWeekendHonorTicks    330
-#define BG_EY_EYWeekendHonorTicks       200
+#define BG_EY_NotEYWeekendHonorTicks    260
+#define BG_EY_EYWeekendHonorTicks       160
 
 #define EY_EVENT_START_BATTLE           13180 // Achievement: Flurry
 
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundIC.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundIC.cpp
index e3eefd4..40f31ce 100755
--- a/src/server/game/Battlegrounds/Zones/BattlegroundIC.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundIC.cpp
@@ -175,9 +175,9 @@ void BattlegroundIC::PostUpdateImpl(uint32 diff)
                     {
                         if (siege->isAlive())
                         {
-                            if (siege->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE|UNIT_FLAG_UNK_14|UNIT_FLAG_OOC_NOT_ATTACKABLE))
+                            if (siege->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE|UNIT_FLAG_UNK_14|UNIT_FLAG_IMMUNE_TO_PC))
                                 // following sniffs the vehicle always has UNIT_FLAG_UNK_14
-                                siege->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE|UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                                siege->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE|UNIT_FLAG_IMMUNE_TO_PC);
                             else
                                 siege->SetHealth(siege->GetMaxHealth());
                         }
@@ -793,7 +793,7 @@ void BattlegroundIC::HandleCapturedNodes(ICNodePoint* nodePoint, bool recapture)
 
                         if (Creature* siegeEngine = GetBGCreature(siegeType))
                         {
-                            siegeEngine->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE|UNIT_FLAG_UNK_14|UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                            siegeEngine->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE|UNIT_FLAG_UNK_14|UNIT_FLAG_IMMUNE_TO_PC);
                             siegeEngine->setFaction(BG_IC_Factions[(nodePoint->faction == TEAM_ALLIANCE ? 0 : 1)]);
                         }
                     }
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index cf24c92..ac1bb9e 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -110,8 +110,6 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/dep/zlib
   ${CMAKE_SOURCE_DIR}/src/server/collision
   ${CMAKE_SOURCE_DIR}/src/server/collision/Management
-  ${CMAKE_SOURCE_DIR}/src/server/collision/Models
-  ${CMAKE_SOURCE_DIR}/src/server/collision/Maps
   ${CMAKE_SOURCE_DIR}/src/server/shared
   ${CMAKE_SOURCE_DIR}/src/server/shared/Configuration
   ${CMAKE_SOURCE_DIR}/src/server/shared/Cryptography
diff --git a/src/server/game/Combat/ThreatManager.cpp b/src/server/game/Combat/ThreatManager.cpp
index 7833198..d82e43b 100755
--- a/src/server/game/Combat/ThreatManager.cpp
+++ b/src/server/game/Combat/ThreatManager.cpp
@@ -180,7 +180,7 @@ void HostileReference::updateOnlineStatus()
     // target is not in flight
     if (isValid()
         && (getTarget()->GetTypeId() != TYPEID_PLAYER || !getTarget()->ToPlayer()->isGameMaster())
-        && !getTarget()->HasUnitState(UNIT_STAT_IN_FLIGHT)
+        && !getTarget()->HasUnitState(UNIT_STATE_IN_FLIGHT)
         && getTarget()->IsInMap(getSourceUnit())
         )
     {
diff --git a/src/server/game/DataStores/DBCStructure.h b/src/server/game/DataStores/DBCStructure.h
index adb7f0a..15408ad 100755
--- a/src/server/game/DataStores/DBCStructure.h
+++ b/src/server/game/DataStores/DBCStructure.h
@@ -955,7 +955,7 @@ struct FactionTemplateEntry
 struct GameObjectDisplayInfoEntry
 {
     uint32      Displayid;                                  // 0        m_ID
-    char* filename;                                      // 1
+    // char* filename;                                      // 1
     //uint32  unk1[10];   //2-11
     float   minX;
     float   minY;
diff --git a/src/server/game/DataStores/DBCfmt.h b/src/server/game/DataStores/DBCfmt.h
index 150159f..c55fb79 100755
--- a/src/server/game/DataStores/DBCfmt.h
+++ b/src/server/game/DataStores/DBCfmt.h
@@ -52,7 +52,7 @@ const char EmotesEntryfmt[]="nxxiiix";
 const char EmotesTextEntryfmt[]="nxixxxxxxxxxxxxxxxx";
 const char FactionEntryfmt[]="niiiiiiiiiiiiiiiiiiffixssssssssssssssssxxxxxxxxxxxxxxxxxx";
 const char FactionTemplateEntryfmt[]="niiiiiiiiiiiii";
-const char GameObjectDisplayInfofmt[]="nsxxxxxxxxxxffffffx";
+const char GameObjectDisplayInfofmt[]="nxxxxxxxxxxxffffffx";
 const char GemPropertiesEntryfmt[]="nixxi";
 const char GlyphPropertiesfmt[]="niii";
 const char GlyphSlotfmt[]="nii";
diff --git a/src/server/game/DungeonFinding/LFGMgr.cpp b/src/server/game/DungeonFinding/LFGMgr.cpp
index ac7343e..cccb780 100755
--- a/src/server/game/DungeonFinding/LFGMgr.cpp
+++ b/src/server/game/DungeonFinding/LFGMgr.cpp
@@ -1762,7 +1762,7 @@ void LFGMgr::TeleportPlayer(Player* player, bool out, bool fromOpcode /*= false*
         error = LFG_TELEPORTERROR_INVALID_LOCATION;
     else if (!player->isAlive())
         error = LFG_TELEPORTERROR_PLAYER_DEAD;
-    else if (player->IsFalling() || player->HasUnitState(UNIT_STAT_JUMPING))
+    else if (player->IsFalling() || player->HasUnitState(UNIT_STATE_JUMPING))
         error = LFG_TELEPORTERROR_FALLING;
     else
     {
diff --git a/src/server/game/Entities/Creature/Creature.cpp b/src/server/game/Entities/Creature/Creature.cpp
index 7f767ea..eb29e68 100755
--- a/src/server/game/Entities/Creature/Creature.cpp
+++ b/src/server/game/Entities/Creature/Creature.cpp
@@ -685,7 +685,7 @@ void Creature::DoFleeToGetAssistance()
         if (!creature)
             //SetFeared(true, getVictim()->GetGUID(), 0, sWorld->getIntConfig(CONFIG_CREATURE_FAMILY_FLEE_DELAY));
             //TODO: use 31365
-            SetControlled(true, UNIT_STAT_FLEEING);
+            SetControlled(true, UNIT_STATE_FLEEING);
         else
             GetMotionMaster()->MoveSeekAssistance(creature->GetPositionX(), creature->GetPositionY(), creature->GetPositionZ());
     }
@@ -1289,7 +1289,7 @@ bool Creature::LoadCreatureFromDB(uint32 guid, Map* map, bool addToMap)
         m_deathState = DEAD;
         if (canFly())
         {
-            float tz = map->GetHeight(GetPhaseMask(), data->posX, data->posY, data->posZ, false);
+            float tz = map->GetHeight(data->posX, data->posY, data->posZ, false);
             if (data->posZ - tz > 0.1f)
                 Relocate(data->posX, data->posY, tz);
         }
@@ -1413,7 +1413,7 @@ bool Creature::canStartAttack(Unit const* who, bool force) const
     if (isCivilian())
         return false;
 
-    if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PASSIVE))
+    if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_NPC))
         return false;
         
     // Do not attack non-combat pets
@@ -1536,7 +1536,7 @@ void Creature::setDeathState(DeathState s)
         if (GetCreatureInfo()->InhabitType & INHABIT_WATER)
             AddUnitMovementFlag(MOVEMENTFLAG_SWIMMING);
         SetUInt32Value(UNIT_NPC_FLAGS, cinfo->npcflag);
-        ClearUnitState(uint32(UNIT_STAT_ALL_STATE));
+        ClearUnitState(uint32(UNIT_STATE_ALL_STATE));
         SetMeleeDamageSchool(SpellSchools(cinfo->dmgschool));
         LoadCreaturesAddon(true);
         Motion_Initialize();
@@ -1565,7 +1565,7 @@ void Creature::Respawn(bool force)
         if (m_DBTableGuid)
             sObjectMgr->RemoveCreatureRespawnTime(m_DBTableGuid, GetInstanceId());
 
-        sLog->outStaticDebug("Respawning...");
+        sLog->outStaticDebug("Respawning creature %s (GuidLow: %u, Full GUID: " UI64FMTD " Entry: %u)", GetName(), GetGUIDLow(), GetGUID(), GetEntry());
         m_respawnTime = 0;
         lootForPickPocketed = false;
         lootForBody         = false;
@@ -1905,7 +1905,7 @@ bool Creature::CanAssistTo(const Unit* u, const Unit* enemy, bool checkfaction /
     if (isCivilian())
         return false;
 
-    if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_PASSIVE))
+    if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_IMMUNE_TO_NPC))
         return false;
 
     // skip fighting creature
@@ -1947,7 +1947,7 @@ bool Creature::_IsTargetAcceptable(const Unit* target) const
         || (m_vehicle && (IsOnVehicle(target) || m_vehicle->GetBase()->IsOnVehicle(target))))
         return false;
 
-    if (target->HasUnitState(UNIT_STAT_DIED))
+    if (target->HasUnitState(UNIT_STATE_DIED))
     {
         // guards can detect fake death
         if (isGuard() && target->HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_FEIGN_DEATH))
diff --git a/src/server/game/Entities/Creature/Creature.h b/src/server/game/Entities/Creature/Creature.h
index 05339f1..e622c48 100755
--- a/src/server/game/Entities/Creature/Creature.h
+++ b/src/server/game/Entities/Creature/Creature.h
@@ -512,7 +512,7 @@ class Creature : public Unit, public GridObject<Creature>, public MapCreature
 
         uint8 getLevelForTarget(WorldObject const* target) const; // overwrite Unit::getLevelForTarget for boss level support
 
-        bool IsInEvadeMode() const { return HasUnitState(UNIT_STAT_EVADE); }
+        bool IsInEvadeMode() const { return HasUnitState(UNIT_STATE_EVADE); }
 
         bool AIM_Initialize(CreatureAI* ai = NULL);
         void Motion_Initialize();
diff --git a/src/server/game/Entities/GameObject/GameObject.cpp b/src/server/game/Entities/GameObject/GameObject.cpp
index 27d4afc..3548ef3 100755
--- a/src/server/game/Entities/GameObject/GameObject.cpp
+++ b/src/server/game/Entities/GameObject/GameObject.cpp
@@ -30,10 +30,7 @@
 #include "CreatureAISelector.h"
 #include "Group.h"
 
-#include "GameObjectModel.h"
-#include "DynamicTree.h"
-
-GameObject::GameObject() : WorldObject(false), m_goValue(new GameObjectValue), m_AI(NULL), m_model(NULL)
+GameObject::GameObject() : WorldObject(false), m_goValue(new GameObjectValue), m_AI(NULL)
 {
     m_objectType |= TYPEMASK_GAMEOBJECT;
     m_objectTypeId = TYPEID_GAMEOBJECT;
@@ -65,7 +62,6 @@ GameObject::~GameObject()
 {
     delete m_goValue;
     delete m_AI;
-    delete m_model;
     //if (m_uint32Values)                                      // field array can be not exist if GameOBject not loaded
     //    CleanupsBeforeDelete();
 }
@@ -131,11 +127,6 @@ void GameObject::AddToWorld()
             m_zoneScript->OnGameObjectCreate(this);
 
         sObjectAccessor->AddObject(this);
-        bool startOpen = (GetGoType() == GAMEOBJECT_TYPE_DOOR || GetGoType() == GAMEOBJECT_TYPE_BUTTON ? GetGOInfo()->door.startOpen : false);
-        if (m_model/* && (GetGoType() == GAMEOBJECT_TYPE_DOOR || GetGoType() == GAMEOBJECT_TYPE_BUTTON ? !GetGOInfo()->door.startOpen : true)*/)
-            GetMap()->Insert(*m_model);
-        if (startOpen)
-            EnableCollision(false);
         WorldObject::AddToWorld();
     }
 }
@@ -149,9 +140,6 @@ void GameObject::RemoveFromWorld()
             m_zoneScript->OnGameObjectRemove(this);
 
         RemoveFromOwner();
-        if (m_model)
-            if (GetMap()->Contains(*m_model))
-                GetMap()->Remove(*m_model);
         WorldObject::RemoveFromWorld();
         sObjectAccessor->RemoveObject(this);
     }
@@ -211,16 +199,14 @@ bool GameObject::Create(uint32 guidlow, uint32 name_id, Map* map, uint32 phaseMa
     // set name for logs usage, doesn't affect anything ingame
     SetName(goinfo->name);
 
-    SetDisplayId(goinfo->displayId);
+    SetUInt32Value(GAMEOBJECT_DISPLAYID, goinfo->displayId);
 
-    m_model = GameObjectModel::Create(*this);
     // GAMEOBJECT_BYTES_1, index at 0, 1, 2 and 3
-    SetGoType(GameobjectTypes(goinfo->type));
     SetGoState(go_state);
+    SetGoType(GameobjectTypes(goinfo->type));
 
     SetGoArtKit(0);                                         // unknown what this is
     SetByteValue(GAMEOBJECT_BYTES_1, 2, artKit);
-    
 
     switch (goinfo->type)
     {
@@ -1793,7 +1779,7 @@ void GameObject::SetDestructibleState(GameObjectDestructibleState state, Player*
     {
         case GO_DESTRUCTIBLE_INTACT:
             RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED | GO_FLAG_DESTROYED);
-            SetDisplayId(m_goInfo->displayId);
+            SetUInt32Value(GAMEOBJECT_DISPLAYID, m_goInfo->displayId);
             if (setHealth)
             {
                 m_goValue->Building.Health = m_goValue->Building.MaxHealth;
@@ -1815,7 +1801,7 @@ void GameObject::SetDestructibleState(GameObjectDestructibleState state, Player*
             if (DestructibleModelDataEntry const* modelData = sDestructibleModelDataStore.LookupEntry(m_goInfo->building.destructibleData))
                 if (modelData->DamagedDisplayId)
                     modelId = modelData->DamagedDisplayId;
-            SetDisplayId(modelId);
+            SetUInt32Value(GAMEOBJECT_DISPLAYID, modelId);
 
             if (setHealth)
             {
@@ -1848,7 +1834,7 @@ void GameObject::SetDestructibleState(GameObjectDestructibleState state, Player*
             if (DestructibleModelDataEntry const* modelData = sDestructibleModelDataStore.LookupEntry(m_goInfo->building.destructibleData))
                 if (modelData->DestroyedDisplayId)
                     modelId = modelData->DestroyedDisplayId;
-            SetDisplayId(modelId);
+            SetUInt32Value(GAMEOBJECT_DISPLAYID, modelId);
 
             if (setHealth)
             {
@@ -1866,7 +1852,7 @@ void GameObject::SetDestructibleState(GameObjectDestructibleState state, Player*
             if (DestructibleModelDataEntry const* modelData = sDestructibleModelDataStore.LookupEntry(m_goInfo->building.destructibleData))
                 if (modelData->RebuildingDisplayId)
                     modelId = modelData->RebuildingDisplayId;
-            SetDisplayId(modelId);
+            SetUInt32Value(GAMEOBJECT_DISPLAYID, modelId);
 
             // restores to full health
             if (setHealth)
@@ -1879,69 +1865,8 @@ void GameObject::SetDestructibleState(GameObjectDestructibleState state, Player*
     }
 }
 
-void GameObject::SetLootState(LootState state, Unit* unit)
-{
-    m_lootState = state;
-    AI()->OnStateChanged(state, unit);
-    if (m_model)
-    {
-        // startOpen determines whether we are going to add or remove the LoS on activation
-        bool startOpen = (GetGoType() == GAMEOBJECT_TYPE_DOOR || GetGoType() == GAMEOBJECT_TYPE_BUTTON ? GetGOInfo()->door.startOpen : false);
-        if (state == GO_ACTIVATED)
-            EnableCollision(startOpen);
-        else if (state == GO_READY)
-            EnableCollision(!startOpen);
-    }
-}
-
-void GameObject::SetGoState(GOState state)
-{
-    SetByteValue(GAMEOBJECT_BYTES_1, 0, state);
-    if (m_model)
-    {
-        if (!IsInWorld())
-            return;
-        // startOpen determines whether we are going to add or remove the LoS on activation
-        bool startOpen = (GetGoType() == GAMEOBJECT_TYPE_DOOR || GetGoType() == GAMEOBJECT_TYPE_BUTTON ? GetGOInfo()->door.startOpen : false);
-        if (state == GO_STATE_ACTIVE)
-            EnableCollision(startOpen);
-        else if (state == GO_STATE_READY)
-            EnableCollision(!startOpen);
-    }
-}
-
-void GameObject::SetDisplayId(uint32 displayid)
-{
-    SetUInt32Value(GAMEOBJECT_DISPLAYID, displayid);
-    UpdateModel();
-}
-
-void GameObject::SetPhaseMask(uint32 newPhaseMask, bool update)
+void GameObject::SetLootState(LootState s, Unit* unit)
 {
-    WorldObject::SetPhaseMask(newPhaseMask, update);
-    EnableCollision(true);
+    m_lootState = s;
+    AI()->OnStateChanged(s, unit);
 }
-
-void GameObject::EnableCollision(bool enable)
-{
-    if (!m_model)
-        return;
-    
-    /*if (enable && !GetMap()->Contains(*m_model))
-        GetMap()->Insert(*m_model);*/
-
-    m_model->enable(enable ? GetPhaseMask() : 0);
-}
-
-void GameObject::UpdateModel()
-{
-    if (!IsInWorld())
-        return;
-    if (m_model)
-        if (GetMap()->Contains(*m_model))
-            GetMap()->Remove(*m_model);
-    delete m_model;
-    m_model = GameObjectModel::Create(*this);
-    if (m_model)
-        GetMap()->Insert(*m_model);
-}
\ No newline at end of file
diff --git a/src/server/game/Entities/GameObject/GameObject.h b/src/server/game/Entities/GameObject/GameObject.h
index a4635ca..f677d48 100755
--- a/src/server/game/Entities/GameObject/GameObject.h
+++ b/src/server/game/Entities/GameObject/GameObject.h
@@ -609,7 +609,6 @@ enum LootState
 };
 
 class Unit;
-class GameObjectModel;
 
 // 5 sec for bobber catch
 #define FISHING_BOBBER_READY_TIME 5
@@ -704,15 +703,12 @@ class GameObject : public WorldObject, public GridObject<GameObject>
         GameobjectTypes GetGoType() const { return GameobjectTypes(GetByteValue(GAMEOBJECT_BYTES_1, 1)); }
         void SetGoType(GameobjectTypes type) { SetByteValue(GAMEOBJECT_BYTES_1, 1, type); }
         GOState GetGoState() const { return GOState(GetByteValue(GAMEOBJECT_BYTES_1, 0)); }
-        void SetGoState(GOState state);
+        void SetGoState(GOState state) { SetByteValue(GAMEOBJECT_BYTES_1, 0, state); }
         uint8 GetGoArtKit() const { return GetByteValue(GAMEOBJECT_BYTES_1, 2); }
         void SetGoArtKit(uint8 artkit);
         uint8 GetGoAnimProgress() const { return GetByteValue(GAMEOBJECT_BYTES_1, 3); }
         void SetGoAnimProgress(uint8 animprogress) { SetByteValue(GAMEOBJECT_BYTES_1, 3, animprogress); }
         static void SetGoArtKit(uint8 artkit, GameObject* go, uint32 lowguid = 0);
-        
-        void SetPhaseMask(uint32 newPhaseMask, bool update);
-        void EnableCollision(bool enable);
 
         void Use(Unit* user);
 
@@ -794,9 +790,6 @@ class GameObject : public WorldObject, public GridObject<GameObject>
         GameObjectAI* AI() const { return m_AI; }
 
         std::string GetAIName() const;
-        void SetDisplayId(uint32 displayid);
-        
-        GameObjectModel * m_model;
     protected:
         bool AIM_Initialize();
         uint32      m_spellId;
@@ -826,7 +819,6 @@ class GameObject : public WorldObject, public GridObject<GameObject>
     private:
         void RemoveFromOwner();
         void SwitchDoorOrButton(bool activate, bool alternative = false);
-        void UpdateModel();                                 // updates model in case displayId were changed
 
         //! Object distance/size - overridden from Object::_IsWithinDist. Needs to take in account proper GO size.
         bool _IsWithinDist(WorldObject const* obj, float dist2compare, bool /*is3D*/) const
diff --git a/src/server/game/Entities/Object/Object.cpp b/src/server/game/Entities/Object/Object.cpp
index 7113fe8..1a8eb8f 100755
--- a/src/server/game/Entities/Object/Object.cpp
+++ b/src/server/game/Entities/Object/Object.cpp
@@ -46,7 +46,6 @@
 #include "Totem.h"
 #include "OutdoorPvPMgr.h"
 #include "MovementPacketBuilder.h"
-#include "DynamicTree.h"
 
 uint32 GuidHigh2TypeId(uint32 guid_hi)
 {
@@ -1301,19 +1300,15 @@ bool WorldObject::IsWithinLOSInMap(const WorldObject* obj) const
 
     float ox, oy, oz;
     obj->GetPosition(ox, oy, oz);
-    return IsWithinLOS(ox, oy, oz);
+    return(IsWithinLOS(ox, oy, oz));
 }
 
 bool WorldObject::IsWithinLOS(float ox, float oy, float oz) const
 {
-    /*float x, y, z;
+    float x, y, z;
     GetPosition(x, y, z);
     VMAP::IVMapManager* vMapManager = VMAP::VMapFactory::createOrGetVMapManager();
-    return vMapManager->isInLineOfSight(GetMapId(), x, y, z+2.0f, ox, oy, oz+2.0f);*/
-    if (IsInWorld())
-        return GetMap()->isInLineOfSight(GetPositionX(), GetPositionY(), GetPositionZ()+2.f, ox, oy, oz+2.f, GetPhaseMask());
-
-    return true;
+    return vMapManager->isInLineOfSight(GetMapId(), x, y, z+2.0f, ox, oy, oz+2.0f);
 }
 
 bool WorldObject::GetDistanceOrder(WorldObject const* obj1, WorldObject const* obj2, bool is3D /* = true */) const
@@ -1535,7 +1530,7 @@ void WorldObject::GetRandomPoint(const Position &pos, float distance, float &ran
 
 void WorldObject::UpdateGroundPositionZ(float x, float y, float &z) const
 {
-    float new_z = GetBaseMap()->GetHeight(GetPhaseMask(), x, y, z, true);
+    float new_z = GetBaseMap()->GetHeight(x, y, z, true);
     if (new_z > INVALID_HEIGHT)
         z = new_z+ 0.05f;                                   // just to be sure that we are not a few pixel under the surface
 }
@@ -1554,7 +1549,7 @@ void WorldObject::UpdateAllowedPositionZ(float x, float y, float &z) const
                 float ground_z = z;
                 float max_z = canSwim
                     ? GetBaseMap()->GetWaterOrGroundLevel(x, y, z, &ground_z, !ToUnit()->HasAuraType(SPELL_AURA_WATER_WALK))
-                    : ((ground_z = GetBaseMap()->GetHeight(GetPhaseMask(), x, y, z, true)));
+                    : ((ground_z = GetBaseMap()->GetHeight(x, y, z, true)));
                 if (max_z > INVALID_HEIGHT)
                 {
                     if (z > max_z)
@@ -1565,7 +1560,7 @@ void WorldObject::UpdateAllowedPositionZ(float x, float y, float &z) const
             }
             else
             {
-                float ground_z = GetBaseMap()->GetHeight(GetPhaseMask(), x, y, z, true);
+                float ground_z = GetBaseMap()->GetHeight(x, y, z, true);
                 if (z < ground_z)
                     z = ground_z;
             }
@@ -1588,7 +1583,7 @@ void WorldObject::UpdateAllowedPositionZ(float x, float y, float &z) const
             }
             else
             {
-                float ground_z = GetBaseMap()->GetHeight(GetPhaseMask(), x, y, z, true);
+                float ground_z = GetBaseMap()->GetHeight(x, y, z, true);
                 if (z < ground_z)
                     z = ground_z;
             }
@@ -1596,7 +1591,7 @@ void WorldObject::UpdateAllowedPositionZ(float x, float y, float &z) const
         }
         default:
         {
-            float ground_z = GetBaseMap()->GetHeight(GetPhaseMask(), x, y, z, true);
+            float ground_z = GetBaseMap()->GetHeight(x, y, z, true);
             if(ground_z > INVALID_HEIGHT)
                 z = ground_z;
             break;
@@ -2463,7 +2458,7 @@ namespace Trinity
 
                 float x, y, z;
 
-                if (!c->isAlive() || c->HasUnitState(UNIT_STAT_ROOT | UNIT_STAT_STUNNED | UNIT_STAT_DISTRACTED) ||
+                if (!c->isAlive() || c->HasUnitState(UNIT_STATE_ROOT | UNIT_STATE_STUNNED | UNIT_STATE_DISTRACTED) ||
                     !c->GetMotionMaster()->GetDestination(x, y, z))
                 {
                     x = c->GetPositionX();
@@ -2670,8 +2665,8 @@ void WorldObject::MovePositionToFirstCollision(Position &pos, float dist, float
 
     destx = pos.m_positionX + dist * cos(angle);
     desty = pos.m_positionY + dist * sin(angle);
-    ground = GetMap()->GetHeight(GetPhaseMask(), destx, desty, MAX_HEIGHT, true);
-    floor = GetMap()->GetHeight(GetPhaseMask(), destx, desty, pos.m_positionZ, true);
+    ground = GetMap()->GetHeight(destx, desty, MAX_HEIGHT, true);
+    floor = GetMap()->GetHeight(destx, desty, pos.m_positionZ, true);
     destz = fabs(ground - pos.m_positionZ) <= fabs(floor - pos.m_positionZ) ? ground : floor;
 
     bool col = VMAP::VMapFactory::createOrGetVMapManager()->getObjectHitPos(GetMapId(), pos.m_positionX, pos.m_positionY, pos.m_positionZ+0.5f, destx, desty, destz+0.5f, destx, desty, destz, -0.5f);
@@ -2694,8 +2689,8 @@ void WorldObject::MovePositionToFirstCollision(Position &pos, float dist, float
         {
             destx -= step * cos(angle);
             desty -= step * sin(angle);
-            ground = GetMap()->GetHeight(GetPhaseMask(), destx, desty, MAX_HEIGHT, true);
-            floor = GetMap()->GetHeight(GetPhaseMask(), destx, desty, pos.m_positionZ, true);
+            ground = GetMap()->GetHeight(destx, desty, MAX_HEIGHT, true);
+            floor = GetMap()->GetHeight(destx, desty, pos.m_positionZ, true);
             destz = fabs(ground - pos.m_positionZ) <= fabs(floor - pos.m_positionZ) ? ground : floor;
         }
         // we have correct destz now
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index 9eece30..38af97f 100755
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -1589,7 +1589,7 @@ void Player::Update(uint32 p_time)
 
     GetAchievementMgr().UpdateTimedAchievements(p_time);
 
-    if (HasUnitState(UNIT_STAT_MELEE_ATTACKING) && !HasUnitState(UNIT_STAT_CASTING))
+    if (HasUnitState(UNIT_STATE_MELEE_ATTACKING) && !HasUnitState(UNIT_STATE_CASTING))
     {
         if (Unit* pVictim = getVictim())
         {
@@ -3251,7 +3251,7 @@ void Player::InitStatsForLevel(bool reapplyMods)
     // cleanup unit flags (will be re-applied if need at aura load).
     RemoveFlag(UNIT_FIELD_FLAGS,
         UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_DISABLE_MOVE | UNIT_FLAG_NOT_ATTACKABLE_1 |
-        UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_PASSIVE  | UNIT_FLAG_LOOTING          |
+        UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_IMMUNE_TO_NPC  | UNIT_FLAG_LOOTING          |
         UNIT_FLAG_PET_IN_COMBAT  | UNIT_FLAG_SILENCED     | UNIT_FLAG_PACIFIED         |
         UNIT_FLAG_STUNNED        | UNIT_FLAG_IN_COMBAT    | UNIT_FLAG_DISARMED         |
         UNIT_FLAG_CONFUSED       | UNIT_FLAG_FLEEING      | UNIT_FLAG_NOT_SELECTABLE   |
@@ -11385,7 +11385,7 @@ InventoryResult Player::CanEquipItem(uint8 slot, uint16 &dest, Item* pItem, bool
             {
                 // May be here should be more stronger checks; STUNNED checked
                 // ROOT, CONFUSED, DISTRACTED, FLEEING this needs to be checked.
-                if (HasUnitState(UNIT_STAT_STUNNED))
+                if (HasUnitState(UNIT_STATE_STUNNED))
                     return EQUIP_ERR_YOU_ARE_STUNNED;
 
                 // do not allow equipping gear except weapons, offhands, projectiles, relics in
@@ -11985,6 +11985,7 @@ Item* Player::StoreNewItem(ItemPosCountVec const& dest, uint32 item, bool update
     {
         ItemAddedQuestCheck(item, count);
         GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_RECEIVE_EPIC_ITEM, item, count);
+        GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_OWN_ITEM, item, 1);
         if (randomPropertyId)
             pItem->SetItemRandomProperties(randomPropertyId);
         pItem = StoreItem(dest, pItem, update);
@@ -12038,7 +12039,6 @@ Item* Player::StoreItem(ItemPosCountVec const& dest, Item* pItem, bool update)
 
         lastItem = _StoreItem(pos, pItem, count, true, update);
     }
-    GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_OWN_ITEM, entry, 1);
     return lastItem;
 }
 
@@ -14323,7 +14323,7 @@ void Player::OnGossipSelect(WorldObject* source, uint32 gossipListId, uint32 men
             break;
         case GOSSIP_OPTION_UNLEARNTALENTS:
             PlayerTalkClass->SendCloseGossip();
-            source->ToCreature()->CastSpell(this, 46331, true); // Trainer: Untrain Talents
+            SendTalentWipeConfirm(guid);
             break;
         case GOSSIP_OPTION_UNLEARNPETTALENTS:
             PlayerTalkClass->SendCloseGossip();
@@ -20265,7 +20265,7 @@ bool Player::ActivateTaxiPathTo(std::vector<uint32> const& nodes, Creature* npc
         return false;
 
     // not let cheating with start flight in time of logout process || while in combat || has type state: stunned || has type state: root
-    if (GetSession()->isLogingOut() || isInCombat() || HasUnitState(UNIT_STAT_STUNNED) || HasUnitState(UNIT_STAT_ROOT))
+    if (GetSession()->isLogingOut() || isInCombat() || HasUnitState(UNIT_STATE_STUNNED) || HasUnitState(UNIT_STATE_ROOT))
     {
         WorldPacket data(SMSG_ACTIVATETAXIREPLY, 4);
         data << uint32(ERR_TAXIPLAYERBUSY);
@@ -21560,7 +21560,7 @@ void Player::SendInitialVisiblePackets(Unit* target)
     SendAurasForTarget(target);
     if (target->isAlive())
     {
-        if (target->HasUnitState(UNIT_STAT_MELEE_ATTACKING) && target->getVictim())
+        if (target->HasUnitState(UNIT_STATE_MELEE_ATTACKING) && target->getVictim())
             target->SendMeleeAttackStart(target->getVictim());
     }
 }
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index 2fa171c..489b4ea 100755
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -1806,7 +1806,7 @@ class Player : public Unit, public GridObject<Player>
         void SetContestedPvPTimer(uint32 newTime) {m_contestedPvPTimer = newTime;}
         void ResetContestedPvP()
         {
-            ClearUnitState(UNIT_STAT_ATTACK_PLAYER);
+            ClearUnitState(UNIT_STATE_ATTACK_PLAYER);
             RemoveFlag(PLAYER_FLAGS, PLAYER_FLAGS_CONTESTED_PVP);
             m_contestedPvPTimer = 0;
         }
diff --git a/src/server/game/Entities/Transport/Transport.cpp b/src/server/game/Entities/Transport/Transport.cpp
index 891cf6b..67d1636 100755
--- a/src/server/game/Entities/Transport/Transport.cpp
+++ b/src/server/game/Entities/Transport/Transport.cpp
@@ -222,7 +222,7 @@ bool Transport::Create(uint32 guidlow, uint32 entry, uint32 mapid, float x, floa
     SetUInt32Value(GAMEOBJECT_LEVEL, m_period);
     SetEntry(goinfo->entry);
 
-    SetDisplayId(goinfo->displayId);
+    SetUInt32Value(GAMEOBJECT_DISPLAYID, goinfo->displayId);
 
     SetGoState(GO_STATE_READY);
     SetGoType(GameobjectTypes(goinfo->type));
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index 289a600..db36a14 100755
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -316,7 +316,7 @@ void Unit::Update(uint32 p_time)
     // update combat timer only for players and pets (only pets with PetAI)
     if (isInCombat() && (GetTypeId() == TYPEID_PLAYER || (ToCreature()->isPet() && IsControlledByPlayer())))
     {
-        // Check UNIT_STAT_MELEE_ATTACKING or UNIT_STAT_CHASE (without UNIT_STAT_FOLLOW in this case) so pets can reach far away
+        // Check UNIT_STATE_MELEE_ATTACKING or UNIT_STATE_CHASE (without UNIT_STATE_FOLLOW in this case) so pets can reach far away
         // targets without stopping half way there and running off.
         // These flags are reset after target dies or another command is given.
         if (m_HostileRefManager.isEmpty())
@@ -516,9 +516,27 @@ bool Unit::HasAuraTypeWithFamilyFlags(AuraType auraType, uint32 familyName, uint
     return false;
 }
 
+bool Unit::HasBreakableByDamageAuraType(AuraType type) const
+{
+    AuraEffectList const& auras = GetAuraEffectsByType(type);
+    for (AuraEffectList::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+        if ((*itr)->GetSpellInfo()->Attributes & SPELL_ATTR0_BREAKABLE_BY_DAMAGE || (*itr)->GetSpellInfo()->AuraInterruptFlags & AURA_INTERRUPT_FLAG_TAKE_DAMAGE)
+            return true;
+    return false;
+}
+
+bool Unit::HasBreakableByDamageCrowdControlAura() const
+{
+    return (   HasBreakableByDamageAuraType(SPELL_AURA_MOD_CONFUSE)
+            || HasBreakableByDamageAuraType(SPELL_AURA_MOD_FEAR)
+            || HasBreakableByDamageAuraType(SPELL_AURA_MOD_STUN)
+            || HasBreakableByDamageAuraType(SPELL_AURA_MOD_ROOT)
+            || HasBreakableByDamageAuraType(SPELL_AURA_TRANSFORM));
+}
+
 void Unit::DealDamageMods(Unit* victim, uint32 &damage, uint32* absorb)
 {
-    if (!victim || !victim->isAlive() || victim->HasUnitState(UNIT_STAT_IN_FLIGHT) || (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsInEvadeMode()))
+    if (!victim || !victim->isAlive() || victim->HasUnitState(UNIT_STATE_IN_FLIGHT) || (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsInEvadeMode()))
     {
         if (absorb)
             *absorb += damage;
@@ -1046,7 +1064,7 @@ void Unit::DealSpellDamage(SpellNonMeleeDamage* damageInfo, bool durabilityLoss)
     if (!victim)
         return;
 
-    if (!victim->isAlive() || victim->HasUnitState(UNIT_STAT_IN_FLIGHT) || (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsInEvadeMode()))
+    if (!victim->isAlive() || victim->HasUnitState(UNIT_STATE_IN_FLIGHT) || (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsInEvadeMode()))
         return;
 
     SpellInfo const* spellProto = sSpellMgr->GetSpellInfo(damageInfo->SpellID);
@@ -1263,14 +1281,14 @@ void Unit::DealMeleeDamage(CalcDamageInfo* damageInfo, bool durabilityLoss)
 {
     Unit* victim = damageInfo->target;
 
-    if (!victim->isAlive() || victim->HasUnitState(UNIT_STAT_IN_FLIGHT) || (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsInEvadeMode()))
+    if (!victim->isAlive() || victim->HasUnitState(UNIT_STATE_IN_FLIGHT) || (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsInEvadeMode()))
         return;
 
     // Hmmmm dont like this emotes client must by self do all animations
     if (damageInfo->HitInfo & HITINFO_CRITICALHIT)
-        victim->HandleEmoteCommand(EMOTE_ONESHOT_WOUNDCRITICAL);
+        victim->HandleEmoteCommand(EMOTE_ONESHOT_WOUND_CRITICAL);
     if (damageInfo->blocked_amount && damageInfo->TargetState != VICTIMSTATE_BLOCKS)
-        victim->HandleEmoteCommand(EMOTE_ONESHOT_PARRYSHIELD);
+        victim->HandleEmoteCommand(EMOTE_ONESHOT_PARRY_SHIELD);
 
     if (damageInfo->TargetState == VICTIMSTATE_PARRY)
     {
@@ -1839,7 +1857,7 @@ void Unit::CalcHealAbsorb(Unit* victim, const SpellInfo* healSpell, uint32 &heal
 
 void Unit::AttackerStateUpdate (Unit* victim, WeaponAttackType attType, bool extra)
 {
-    if (HasUnitState(UNIT_STAT_CANNOT_AUTOATTACK) || HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED))
+    if (HasUnitState(UNIT_STATE_CANNOT_AUTOATTACK) || HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED))
         return;
 
     if (!victim->isAlive())
@@ -2412,7 +2430,7 @@ SpellMissInfo Unit::MagicSpellHitResult(Unit* victim, SpellInfo const* spell)
         // Chance hit from victim SPELL_AURA_MOD_ATTACKER_SPELL_HIT_CHANCE auras
         modHitChance += victim->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_ATTACKER_SPELL_HIT_CHANCE, schoolMask);
         // Reduce spell hit chance for Area of effect spells from victim SPELL_AURA_MOD_AOE_AVOIDANCE aura
-        if (spell->IsAOE())
+        if (spell->IsTargetingArea())
             modHitChance -= victim->GetTotalAuraModifier(SPELL_AURA_MOD_AOE_AVOIDANCE);
 
         // Decrease hit chance from victim rating bonus
@@ -2557,7 +2575,7 @@ uint32 Unit::GetDefenseSkillValue(Unit const* target) const
 
 float Unit::GetUnitDodgeChance() const
 {
-    if (IsNonMeleeSpellCasted(false) || HasUnitState(UNIT_STAT_CONTROLLED))
+    if (IsNonMeleeSpellCasted(false) || HasUnitState(UNIT_STATE_CONTROLLED))
         return 0.0f;
 
     if (GetTypeId() == TYPEID_PLAYER)
@@ -2577,7 +2595,7 @@ float Unit::GetUnitDodgeChance() const
 
 float Unit::GetUnitParryChance() const
 {
-    if (IsNonMeleeSpellCasted(false) || HasUnitState(UNIT_STAT_CONTROLLED))
+    if (IsNonMeleeSpellCasted(false) || HasUnitState(UNIT_STATE_CONTROLLED))
         return 0.0f;
 
     float chance = 0.0f;
@@ -2623,7 +2641,7 @@ float Unit::GetUnitMissChance(WeaponAttackType attType) const
 
 float Unit::GetUnitBlockChance() const
 {
-    if (IsNonMeleeSpellCasted(false) || HasUnitState(UNIT_STAT_CONTROLLED))
+    if (IsNonMeleeSpellCasted(false) || HasUnitState(UNIT_STATE_CONTROLLED))
         return 0.0f;
 
     if (Player const* player = ToPlayer())
@@ -2875,7 +2893,7 @@ void Unit::SetCurrentCastedSpell(Spell* pSpell)
                     InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
                 m_AutoRepeatFirstCast = true;
             }
-            AddUnitState(UNIT_STAT_CASTING);
+            AddUnitState(UNIT_STATE_CASTING);
         } break;
 
         case CURRENT_CHANNELED_SPELL:
@@ -2888,7 +2906,7 @@ void Unit::SetCurrentCastedSpell(Spell* pSpell)
             if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL] &&
                 m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id != 75)
                 InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
-            AddUnitState(UNIT_STAT_CASTING);
+            AddUnitState(UNIT_STATE_CASTING);
         } break;
 
         case CURRENT_AUTOREPEAT_SPELL:
@@ -3334,19 +3352,19 @@ void Unit::_RemoveNoStackAurasDueToAura(Aura* aura)
         return;
 
     bool remove = false;
-    for (AuraMap::iterator i = m_ownedAuras.begin(); i != m_ownedAuras.end(); ++i)
+    for (AuraApplicationMap::iterator i = m_appliedAuras.begin(); i != m_appliedAuras.end(); ++i)
     {
         if (remove)
         {
             remove = false;
-            i = m_ownedAuras.begin();
+            i = m_appliedAuras.begin();
         }
 
-        if (aura->CanStackWith(i->second))
+        if (aura->CanStackWith(i->second->GetBase()))
             continue;
 
-        RemoveOwnedAura(i, AURA_REMOVE_BY_DEFAULT);
-        if (i == m_ownedAuras.end())
+        RemoveAura(i, AURA_REMOVE_BY_DEFAULT);
+        if (i == m_appliedAuras.end())
             break;
         remove = true;
     }
@@ -3520,17 +3538,25 @@ void Unit::RemoveAuraFromStack(uint32 spellId, uint64 casterGUID, AuraRemoveMode
     }
 }
 
-void Unit::RemoveAurasDueToSpellByDispel(uint32 spellId, uint64 casterGUID, Unit* dispeller, uint8 chargesRemoved/*= 1*/)
+void Unit::RemoveAurasDueToSpellByDispel(uint32 spellId, uint32 dispellerSpellId, uint64 casterGUID, Unit* dispeller, uint8 chargesRemoved/*= 1*/)
 {
     for (AuraMap::iterator iter = m_ownedAuras.lower_bound(spellId); iter != m_ownedAuras.upper_bound(spellId);)
     {
         Aura* aura = iter->second;
         if (aura->GetCasterGUID() == casterGUID)
         {
+            DispelInfo dispelInfo(dispeller, dispellerSpellId, chargesRemoved);
+
+            // Call OnDispel hook on AuraScript
+            aura->CallScriptDispel(&dispelInfo);
+
             if (aura->GetSpellInfo()->AttributesEx7 & SPELL_ATTR7_DISPEL_CHARGES)
-                aura->ModCharges(-chargesRemoved, AURA_REMOVE_BY_ENEMY_SPELL);
+                aura->ModCharges(-dispelInfo.GetRemovedCharges(), AURA_REMOVE_BY_ENEMY_SPELL);
             else
-                aura->ModStackAmount(-chargesRemoved, AURA_REMOVE_BY_ENEMY_SPELL);
+                aura->ModStackAmount(-dispelInfo.GetRemovedCharges(), AURA_REMOVE_BY_ENEMY_SPELL);
+
+            // Call AfterDispel hook on AuraScript
+            aura->CallScriptAfterDispel(&dispelInfo);
 
             switch (aura->GetSpellInfo()->SpellFamilyName)
             {
@@ -3560,7 +3586,7 @@ void Unit::RemoveAurasDueToSpellByDispel(uint32 spellId, uint64 casterGUID, Unit
                         {
                             // final heal
                             int32 healAmount = aurEff->GetAmount();
-                            int32 stack = chargesRemoved;
+                            int32 stack = dispelInfo.GetRemovedCharges();
                             CastCustomSpell(this, 33778, &healAmount, &stack, NULL, true, NULL, NULL, aura->GetCasterGUID());
 
                             // mana
@@ -4862,8 +4888,8 @@ bool Unit::HandleHasteAuraProc(Unit* victim, uint32 damage, AuraEffect* triggere
                 case 13877:
                 case 33735:
                 {
-                    target = SelectNearbyTarget();
-                    if (!target || target == victim)
+                    target = SelectNearbyTarget(victim);
+                    if (!target)
                         return false;
                     basepoints0 = damage;
                     triggered_spell_id = 22482;
@@ -5010,7 +5036,7 @@ bool Unit::HandleDummyAuraProc(Unit* victim, uint32 damage, AuraEffect* triggere
                 case 18765:
                 case 35429:
                 {
-                    target = SelectNearbyTarget();
+                    target = SelectNearbyTarget(victim);
                     if (!target)
                         return false;
 
@@ -5730,7 +5756,7 @@ bool Unit::HandleDummyAuraProc(Unit* victim, uint32 damage, AuraEffect* triggere
                 // Sweeping Strikes
                 case 12328:
                 {
-                    target = SelectNearbyTarget();
+                    target = SelectNearbyTarget(victim);
                     if (!target)
                         return false;
 
@@ -5806,12 +5832,12 @@ bool Unit::HandleDummyAuraProc(Unit* victim, uint32 damage, AuraEffect* triggere
                 if (!victim || !victim->isAlive() || !procSpell)
                     return false;
 
-                target = SelectNearbyTarget();
-                if (!target || target == victim)
+                target = SelectNearbyTarget(victim);
+                if (!target)
                     return false;
 
-                CastSpell(target, 58567, true);
-                return true;
+                triggered_spell_id = 58567;
+                break;
             }
             break;
         }
@@ -9347,16 +9373,16 @@ bool Unit::Attack(Unit* victim, bool meleeAttack)
             // switch to melee attack from ranged/magic
             if (meleeAttack)
             {
-                if (!HasUnitState(UNIT_STAT_MELEE_ATTACKING))
+                if (!HasUnitState(UNIT_STATE_MELEE_ATTACKING))
                 {
-                    AddUnitState(UNIT_STAT_MELEE_ATTACKING);
+                    AddUnitState(UNIT_STATE_MELEE_ATTACKING);
                     SendMeleeAttackStart(victim);
                     return true;
                 }
             }
-            else if (HasUnitState(UNIT_STAT_MELEE_ATTACKING))
+            else if (HasUnitState(UNIT_STATE_MELEE_ATTACKING))
             {
-                ClearUnitState(UNIT_STAT_MELEE_ATTACKING);
+                ClearUnitState(UNIT_STATE_MELEE_ATTACKING);
                 SendMeleeAttackStop(victim);
                 return true;
             }
@@ -9366,7 +9392,7 @@ bool Unit::Attack(Unit* victim, bool meleeAttack)
         // switch target
         InterruptSpell(CURRENT_MELEE_SPELL);
         if (!meleeAttack)
-            ClearUnitState(UNIT_STAT_MELEE_ATTACKING);
+            ClearUnitState(UNIT_STATE_MELEE_ATTACKING);
     }
 
     if (m_attacking)
@@ -9379,7 +9405,7 @@ bool Unit::Attack(Unit* victim, bool meleeAttack)
     SetTarget(victim->GetGUID());
 
     if (meleeAttack)
-        AddUnitState(UNIT_STAT_MELEE_ATTACKING);
+        AddUnitState(UNIT_STATE_MELEE_ATTACKING);
 
     // set position before any AI calls/assistance
     //if (GetTypeId() == TYPEID_UNIT)
@@ -9420,7 +9446,7 @@ bool Unit::AttackStop()
     // Clear our target
     SetTarget(0);
 
-    ClearUnitState(UNIT_STAT_MELEE_ATTACKING);
+    ClearUnitState(UNIT_STATE_MELEE_ATTACKING);
 
     InterruptSpell(CURRENT_MELEE_SPELL);
 
@@ -9463,7 +9489,7 @@ void Unit::CombatStopWithPets(bool includingCast)
 
 bool Unit::isAttackingPlayer() const
 {
-    if (HasUnitState(UNIT_STAT_ATTACK_PLAYER))
+    if (HasUnitState(UNIT_STATE_ATTACK_PLAYER))
         return true;
 
     for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
@@ -11899,7 +11925,7 @@ void Unit::Dismount()
     {
         if (Pet* pPet = player->GetPet())
         {
-            if (pPet->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED) && !pPet->HasUnitState(UNIT_STAT_STUNNED))
+            if (pPet->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED) && !pPet->HasUnitState(UNIT_STATE_STUNNED))
                 pPet->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
         }
         else
@@ -11968,7 +11994,7 @@ void Unit::SetInCombatState(bool PvP, Unit* enemy)
     if (PvP)
         m_CombatTimer = 5000;
 
-    if (isInCombat() || HasUnitState(UNIT_STAT_EVADE))
+    if (isInCombat() || HasUnitState(UNIT_STATE_EVADE))
         return;
 
     SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IN_COMBAT);
@@ -11986,7 +12012,7 @@ void Unit::SetInCombatState(bool PvP, Unit* enemy)
             if (IsAIEnabled)
             {
                 creature->AI()->EnterCombat(enemy);
-                RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE); // always remove Out of Combat Non Attackable flag if we enter combat and AI is enabled
+                RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC); // unit has engaged in combat, remove immunity so players can fight back
             }
             if (creature->GetFormation())
                 creature->GetFormation()->MemberAttackStart(creature, enemy);
@@ -12018,10 +12044,10 @@ void Unit::ClearInCombat()
     // Player's state will be cleared in Player::UpdateContestedPvP
     if (Creature* creature = ToCreature())
     {
-        if (creature->GetCreatureInfo() && creature->GetCreatureInfo()->unit_flags & UNIT_FLAG_OOC_NOT_ATTACKABLE)
-            SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE); // re-apply Out of Combat Non Attackable flag if we leave combat, can be overriden in scripts in EnterEvadeMode()
+        if (creature->GetCreatureInfo() && creature->GetCreatureInfo()->unit_flags & UNIT_FLAG_IMMUNE_TO_PC)
+            SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC); // set immunity state to the one from db on evade
 
-        ClearUnitState(UNIT_STAT_ATTACK_PLAYER);
+        ClearUnitState(UNIT_STATE_ATTACK_PLAYER);
         if (HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_TAPPED))
             SetUInt32Value(UNIT_DYNAMIC_FLAGS, creature->GetCreatureInfo()->dynamicflags);
 
@@ -12047,13 +12073,13 @@ bool Unit::isTargetableForAttack(bool checkFakeDeath) const
         return false;
 
     if (HasFlag(UNIT_FIELD_FLAGS,
-        UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE))
+        UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_IMMUNE_TO_PC))
         return false;
 
     if (GetTypeId() == TYPEID_PLAYER && ToPlayer()->isGameMaster())
         return false;
 
-    return !HasUnitState(UNIT_STAT_UNATTACKABLE) && (!checkFakeDeath || !HasUnitState(UNIT_STAT_DIED));
+    return !HasUnitState(UNIT_STATE_UNATTACKABLE) && (!checkFakeDeath || !HasUnitState(UNIT_STATE_DIED));
 }
 
 bool Unit::IsValidAttackTarget(Unit const* target) const
@@ -12071,7 +12097,7 @@ bool Unit::_IsValidAttackTarget(Unit const* target, SpellInfo const* bySpell) co
         return false;
 
     // can't attack unattackable units or GMs
-    if (target->HasUnitState(UNIT_STAT_UNATTACKABLE)
+    if (target->HasUnitState(UNIT_STATE_UNATTACKABLE)
         || (target->GetTypeId() == TYPEID_PLAYER && target->ToPlayer()->isGameMaster()))
         return false;
 
@@ -12081,7 +12107,7 @@ bool Unit::_IsValidAttackTarget(Unit const* target, SpellInfo const* bySpell) co
             return false;
 
     // can't attack invisible (ignore stealth for aoe spells)
-    if ((!bySpell || !(bySpell->AttributesEx6 & SPELL_ATTR6_CAN_TARGET_INVISIBLE)) && !canSeeOrDetect(target, bySpell && bySpell->IsAOE()))
+    if ((!bySpell || !(bySpell->AttributesEx6 & SPELL_ATTR6_CAN_TARGET_INVISIBLE)) && !canSeeOrDetect(target, bySpell && bySpell->IsAffectingArea()))
         return false;
 
     // can't attack dead
@@ -12100,10 +12126,11 @@ bool Unit::_IsValidAttackTarget(Unit const* target, SpellInfo const* bySpell) co
     }
     // check flags
     if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_TAXI_FLIGHT | UNIT_FLAG_NOT_ATTACKABLE_1 | UNIT_FLAG_UNK_16)
-        || (!HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PASSIVE))
-        || (!target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PASSIVE))
-        || (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE))
-        || (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE)))
+        || (!HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_NPC))
+        || (!target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_NPC))
+        || (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC))
+        // check if this is a world trigger cast - GOs are using world triggers to cast their spells, so we need to ignore their immunity flag here, this is a temp workaround, needs removal when go cast is implemented properly
+        || (GetEntry() != WORLD_TRIGGER && target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC)))
         return false;
 
     // CvC case - can attack each other only when one of them is hostile
@@ -12165,7 +12192,7 @@ bool Unit::_IsValidAssistTarget(Unit const* target, SpellInfo const* bySpell) co
         return true;
 
     // can't assist unattackable units or GMs
-    if (target->HasUnitState(UNIT_STAT_UNATTACKABLE)
+    if (target->HasUnitState(UNIT_STATE_UNATTACKABLE)
         || (target->GetTypeId() == TYPEID_PLAYER && target->ToPlayer()->isGameMaster()))
         return false;
 
@@ -12175,7 +12202,7 @@ bool Unit::_IsValidAssistTarget(Unit const* target, SpellInfo const* bySpell) co
             return false;
 
     // can't assist invisible
-    if ((!bySpell || !(bySpell->AttributesEx6 & SPELL_ATTR6_CAN_TARGET_INVISIBLE)) && !canSeeOrDetect(target, bySpell && bySpell->IsAOE()))
+    if ((!bySpell || !(bySpell->AttributesEx6 & SPELL_ATTR6_CAN_TARGET_INVISIBLE)) && !canSeeOrDetect(target, bySpell && bySpell->IsAffectingArea()))
         return false;
 
     // can't assist dead
@@ -12191,12 +12218,12 @@ bool Unit::_IsValidAssistTarget(Unit const* target, SpellInfo const* bySpell) co
     {
         if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE))
         {
-            if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE))
+            if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC))
                 return false;
         }
         else
         {
-            if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PASSIVE))
+            if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_NPC))
                 return false;
         }
     }
@@ -14596,7 +14623,7 @@ void Unit::SendPetAIReaction(uint64 guid)
 
 void Unit::StopMoving()
 {
-    ClearUnitState(UNIT_STAT_MOVING);
+    ClearUnitState(UNIT_STATE_MOVING);
 
     // not need send any packets if not in world
     if (!IsInWorld())
@@ -14771,7 +14798,7 @@ void Unit::UpdateReactives(uint32 p_time)
     }
 }
 
-Unit* Unit::SelectNearbyTarget(float dist) const
+Unit* Unit::SelectNearbyTarget(Unit* exclude, float dist) const
 {
     std::list<Unit*> targets;
     Trinity::AnyUnfriendlyUnitInObjectRangeCheck u_check(this, this, dist);
@@ -14781,6 +14808,9 @@ Unit* Unit::SelectNearbyTarget(float dist) const
     // remove current target
     if (getVictim())
         targets.remove(getVictim());
+        
+    if (exclude)
+        targets.remove(exclude);
 
     // remove not LoS targets
     for (std::list<Unit*>::iterator tIter = targets.begin(); tIter != targets.end();)
@@ -14870,7 +14900,7 @@ uint32 Unit::GetCastingTimeForBonus(SpellInfo const* spellProto, DamageEffectTyp
                 break;
         }
 
-        if (spellProto->Effects[i].IsArea())
+        if (spellProto->Effects[i].IsTargetingArea())
             AreaEffect = true;
     }
 
@@ -14978,16 +15008,16 @@ void Unit::SetContestedPvP(Player* attackedPlayer)
         return;
 
     player->SetContestedPvPTimer(30000);
-    if (!player->HasUnitState(UNIT_STAT_ATTACK_PLAYER))
+    if (!player->HasUnitState(UNIT_STATE_ATTACK_PLAYER))
     {
-        player->AddUnitState(UNIT_STAT_ATTACK_PLAYER);
+        player->AddUnitState(UNIT_STATE_ATTACK_PLAYER);
         player->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_CONTESTED_PVP);
         // call MoveInLineOfSight for nearby contested guards
         UpdateObjectVisibility();
     }
-    if (!HasUnitState(UNIT_STAT_ATTACK_PLAYER))
+    if (!HasUnitState(UNIT_STATE_ATTACK_PLAYER))
     {
-        AddUnitState(UNIT_STAT_ATTACK_PLAYER);
+        AddUnitState(UNIT_STATE_ATTACK_PLAYER);
         // call MoveInLineOfSight for nearby contested guards
         UpdateObjectVisibility();
     }
@@ -15555,28 +15585,28 @@ void Unit::SetControlled(bool apply, UnitState state)
         AddUnitState(state);
         switch (state)
         {
-            case UNIT_STAT_STUNNED:
+            case UNIT_STATE_STUNNED:
                 SetStunned(true);
                 CastStop();
                 break;
-            case UNIT_STAT_ROOT:
-                if (!HasUnitState(UNIT_STAT_STUNNED))
+            case UNIT_STATE_ROOT:
+                if (!HasUnitState(UNIT_STATE_STUNNED))
                     SetRooted(true);
                 break;
-            case UNIT_STAT_CONFUSED:
-                if (!HasUnitState(UNIT_STAT_STUNNED))
+            case UNIT_STATE_CONFUSED:
+                if (!HasUnitState(UNIT_STATE_STUNNED))
                 {
-                    ClearUnitState(UNIT_STAT_MELEE_ATTACKING);
+                    ClearUnitState(UNIT_STATE_MELEE_ATTACKING);
                     SendMeleeAttackStop();
                     // SendAutoRepeatCancel ?
                     SetConfused(true);
                     CastStop();
                 }
                 break;
-            case UNIT_STAT_FLEEING:
-                if (!HasUnitState(UNIT_STAT_STUNNED | UNIT_STAT_CONFUSED))
+            case UNIT_STATE_FLEEING:
+                if (!HasUnitState(UNIT_STATE_STUNNED | UNIT_STATE_CONFUSED))
                 {
-                    ClearUnitState(UNIT_STAT_MELEE_ATTACKING);
+                    ClearUnitState(UNIT_STATE_MELEE_ATTACKING);
                     SendMeleeAttackStop();
                     // SendAutoRepeatCancel ?
                     SetFeared(true);
@@ -15591,29 +15621,29 @@ void Unit::SetControlled(bool apply, UnitState state)
     {
         switch (state)
         {
-            case UNIT_STAT_STUNNED: if (HasAuraType(SPELL_AURA_MOD_STUN))    return;
+            case UNIT_STATE_STUNNED: if (HasAuraType(SPELL_AURA_MOD_STUN))    return;
                                     else    SetStunned(false);    break;
-            case UNIT_STAT_ROOT:    if (HasAuraType(SPELL_AURA_MOD_ROOT) || GetVehicle())    return;
+            case UNIT_STATE_ROOT:    if (HasAuraType(SPELL_AURA_MOD_ROOT) || GetVehicle())    return;
                                     else    SetRooted(false);     break;
-            case UNIT_STAT_CONFUSED:if (HasAuraType(SPELL_AURA_MOD_CONFUSE)) return;
+            case UNIT_STATE_CONFUSED:if (HasAuraType(SPELL_AURA_MOD_CONFUSE)) return;
                                     else    SetConfused(false);   break;
-            case UNIT_STAT_FLEEING: if (HasAuraType(SPELL_AURA_MOD_FEAR))    return;
+            case UNIT_STATE_FLEEING: if (HasAuraType(SPELL_AURA_MOD_FEAR))    return;
                                     else    SetFeared(false);     break;
             default: return;
         }
 
         ClearUnitState(state);
 
-        if (HasUnitState(UNIT_STAT_STUNNED))
+        if (HasUnitState(UNIT_STATE_STUNNED))
             SetStunned(true);
         else
         {
-            if (HasUnitState(UNIT_STAT_ROOT))
+            if (HasUnitState(UNIT_STATE_ROOT))
                 SetRooted(true);
 
-            if (HasUnitState(UNIT_STAT_CONFUSED))
+            if (HasUnitState(UNIT_STATE_CONFUSED))
                 SetConfused(true);
-            else if (HasUnitState(UNIT_STAT_FLEEING))
+            else if (HasUnitState(UNIT_STATE_FLEEING))
                 SetFeared(true);
         }
     }
@@ -15655,7 +15685,7 @@ void Unit::SetStunned(bool apply)
         if (!owner || (owner->GetTypeId() == TYPEID_PLAYER && !owner->ToPlayer()->IsMounted()))
             RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
 
-        if (!HasUnitState(UNIT_STAT_ROOT))         // prevent moving if it also has root effect
+        if (!HasUnitState(UNIT_STATE_ROOT))         // prevent moving if it also has root effect
         {
             WorldPacket data(SMSG_FORCE_MOVE_UNROOT, 8+4);
             data.append(GetPackGUID());
@@ -15697,7 +15727,7 @@ void Unit::SetRooted(bool apply)
     }
     else
     {
-        if (!HasUnitState(UNIT_STAT_STUNNED))      // prevent moving if it also has stun effect
+        if (!HasUnitState(UNIT_STATE_STUNNED))      // prevent moving if it also has stun effect
         {
             if (GetTypeId() == TYPEID_PLAYER)
             {
@@ -15789,7 +15819,7 @@ bool Unit::SetCharmedBy(Unit* charmer, CharmType type, AuraApplication const* au
         return false;
     }
 
-    //if (HasUnitState(UNIT_STAT_UNATTACKABLE))
+    //if (HasUnitState(UNIT_STATE_UNATTACKABLE))
     //    return false;
 
     if (GetTypeId() == TYPEID_PLAYER && ToPlayer()->GetTransport())
@@ -15882,7 +15912,7 @@ bool Unit::SetCharmedBy(Unit* charmer, CharmType type, AuraApplication const* au
                 charmer->ToPlayer()->VehicleSpellInitialize();
                 break;
             case CHARM_TYPE_POSSESS:
-                AddUnitState(UNIT_STAT_POSSESSED);
+                AddUnitState(UNIT_STATE_POSSESSED);
                 SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
                 charmer->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE);
                 charmer->ToPlayer()->SetClientControl(this, 1);
@@ -15933,7 +15963,7 @@ void Unit::RemoveCharmedBy(Unit* charmer)
     }
 
     CharmType type;
-    if (HasUnitState(UNIT_STAT_POSSESSED))
+    if (HasUnitState(UNIT_STATE_POSSESSED))
         type = CHARM_TYPE_POSSESS;
     else if (charmer && charmer->IsOnVehicle(this))
         type = CHARM_TYPE_VEHICLE;
@@ -15951,7 +15981,7 @@ void Unit::RemoveCharmedBy(Unit* charmer)
 
     if (type == CHARM_TYPE_POSSESS)
     {
-        ClearUnitState(UNIT_STAT_POSSESSED);
+        ClearUnitState(UNIT_STATE_POSSESSED);
         RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
     }
 
@@ -16990,7 +17020,7 @@ void Unit::_ExitVehicle(Position const* exitPosition)
     Vehicle* vehicle = m_vehicle;
     m_vehicle = NULL;
 
-    SetControlled(false, UNIT_STAT_ROOT);       // SMSG_MOVE_FORCE_UNROOT, ~MOVEMENTFLAG_ROOT
+    SetControlled(false, UNIT_STATE_ROOT);       // SMSG_MOVE_FORCE_UNROOT, ~MOVEMENTFLAG_ROOT
 
     Position pos;
     if (!exitPosition)                           // Exit position not specified
@@ -16998,7 +17028,7 @@ void Unit::_ExitVehicle(Position const* exitPosition)
     else
         pos = *exitPosition;
 
-    AddUnitState(UNIT_STAT_MOVE);
+    AddUnitState(UNIT_STATE_MOVE);
 
     if (GetTypeId() == TYPEID_PLAYER)
         ToPlayer()->SetFallInformation(0, GetPositionZ());
@@ -17390,7 +17420,7 @@ bool CharmInfo::IsReturning()
 
 void Unit::SetInFront(Unit const* target)
 {
-    if (!HasUnitState(UNIT_STAT_CANNOT_TURN))
+    if (!HasUnitState(UNIT_STATE_CANNOT_TURN))
         SetOrientation(GetAngle(target));
 }
 
diff --git a/src/server/game/Entities/Unit/Unit.h b/src/server/game/Entities/Unit/Unit.h
index b64a2e2..abcdf13 100755
--- a/src/server/game/Entities/Unit/Unit.h
+++ b/src/server/game/Entities/Unit/Unit.h
@@ -469,46 +469,46 @@ enum DeathState
 
 enum UnitState
 {
-    UNIT_STAT_DIED            = 0x00000001,                     // player has fake death aura
-    UNIT_STAT_MELEE_ATTACKING = 0x00000002,                     // player is melee attacking someone
-    //UNIT_STAT_MELEE_ATTACK_BY = 0x00000004,                     // player is melee attack by someone
-    UNIT_STAT_STUNNED         = 0x00000008,
-    UNIT_STAT_ROAMING         = 0x00000010,
-    UNIT_STAT_CHASE           = 0x00000020,
-    //UNIT_STAT_SEARCHING       = 0x00000040,
-    UNIT_STAT_FLEEING         = 0x00000080,
-    UNIT_STAT_IN_FLIGHT       = 0x00000100,                     // player is in flight mode
-    UNIT_STAT_FOLLOW          = 0x00000200,
-    UNIT_STAT_ROOT            = 0x00000400,
-    UNIT_STAT_CONFUSED        = 0x00000800,
-    UNIT_STAT_DISTRACTED      = 0x00001000,
-    UNIT_STAT_ISOLATED        = 0x00002000,                     // area auras do not affect other players
-    UNIT_STAT_ATTACK_PLAYER   = 0x00004000,
-    UNIT_STAT_CASTING         = 0x00008000,
-    UNIT_STAT_POSSESSED       = 0x00010000,
-    UNIT_STAT_CHARGING        = 0x00020000,
-    UNIT_STAT_JUMPING         = 0x00040000,
-    UNIT_STAT_ONVEHICLE       = 0x00080000,
-    UNIT_STAT_MOVE            = 0x00100000,
-    UNIT_STAT_ROTATING        = 0x00200000,
-    UNIT_STAT_EVADE           = 0x00400000,
-    UNIT_STAT_ROAMING_MOVE    = 0x00800000,
-    UNIT_STAT_CONFUSED_MOVE   = 0x01000000,
-    UNIT_STAT_FLEEING_MOVE    = 0x02000000,
-    UNIT_STAT_CHASE_MOVE      = 0x04000000,
-    UNIT_STAT_FOLLOW_MOVE     = 0x08000000,
-    UNIT_STAT_UNATTACKABLE    = (UNIT_STAT_IN_FLIGHT | UNIT_STAT_ONVEHICLE),
-    //UNIT_STAT_MOVING          = (UNIT_STAT_ROAMING | UNIT_STAT_CHASE),
+    UNIT_STATE_DIED            = 0x00000001,                     // player has fake death aura
+    UNIT_STATE_MELEE_ATTACKING = 0x00000002,                     // player is melee attacking someone
+    //UNIT_STATE_MELEE_ATTACK_BY = 0x00000004,                     // player is melee attack by someone
+    UNIT_STATE_STUNNED         = 0x00000008,
+    UNIT_STATE_ROAMING         = 0x00000010,
+    UNIT_STATE_CHASE           = 0x00000020,
+    //UNIT_STATE_SEARCHING       = 0x00000040,
+    UNIT_STATE_FLEEING         = 0x00000080,
+    UNIT_STATE_IN_FLIGHT       = 0x00000100,                     // player is in flight mode
+    UNIT_STATE_FOLLOW          = 0x00000200,
+    UNIT_STATE_ROOT            = 0x00000400,
+    UNIT_STATE_CONFUSED        = 0x00000800,
+    UNIT_STATE_DISTRACTED      = 0x00001000,
+    UNIT_STATE_ISOLATED        = 0x00002000,                     // area auras do not affect other players
+    UNIT_STATE_ATTACK_PLAYER   = 0x00004000,
+    UNIT_STATE_CASTING         = 0x00008000,
+    UNIT_STATE_POSSESSED       = 0x00010000,
+    UNIT_STATE_CHARGING        = 0x00020000,
+    UNIT_STATE_JUMPING         = 0x00040000,
+    UNIT_STATE_ONVEHICLE       = 0x00080000,
+    UNIT_STATE_MOVE            = 0x00100000,
+    UNIT_STATE_ROTATING        = 0x00200000,
+    UNIT_STATE_EVADE           = 0x00400000,
+    UNIT_STATE_ROAMING_MOVE    = 0x00800000,
+    UNIT_STATE_CONFUSED_MOVE   = 0x01000000,
+    UNIT_STATE_FLEEING_MOVE    = 0x02000000,
+    UNIT_STATE_CHASE_MOVE      = 0x04000000,
+    UNIT_STATE_FOLLOW_MOVE     = 0x08000000,
+    UNIT_STATE_UNATTACKABLE    = (UNIT_STATE_IN_FLIGHT | UNIT_STATE_ONVEHICLE),
+    //UNIT_STATE_MOVING          = (UNIT_STATE_ROAMING | UNIT_STATE_CHASE),
     // for real move using movegen check and stop (except unstoppable flight)
-    UNIT_STAT_MOVING          = UNIT_STAT_ROAMING_MOVE | UNIT_STAT_CONFUSED_MOVE | UNIT_STAT_FLEEING_MOVE| UNIT_STAT_CHASE_MOVE | UNIT_STAT_FOLLOW_MOVE ,
-    UNIT_STAT_CONTROLLED      = (UNIT_STAT_CONFUSED | UNIT_STAT_STUNNED | UNIT_STAT_FLEEING),
-    UNIT_STAT_LOST_CONTROL    = (UNIT_STAT_CONTROLLED | UNIT_STAT_JUMPING | UNIT_STAT_CHARGING),
-    UNIT_STAT_SIGHTLESS       = (UNIT_STAT_LOST_CONTROL | UNIT_STAT_EVADE),
-    UNIT_STAT_CANNOT_AUTOATTACK     = (UNIT_STAT_LOST_CONTROL | UNIT_STAT_CASTING),
-    UNIT_STAT_CANNOT_TURN     = (UNIT_STAT_LOST_CONTROL | UNIT_STAT_ROTATING),
+    UNIT_STATE_MOVING          = UNIT_STATE_ROAMING_MOVE | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE| UNIT_STATE_CHASE_MOVE | UNIT_STATE_FOLLOW_MOVE ,
+    UNIT_STATE_CONTROLLED      = (UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING),
+    UNIT_STATE_LOST_CONTROL    = (UNIT_STATE_CONTROLLED | UNIT_STATE_JUMPING | UNIT_STATE_CHARGING),
+    UNIT_STATE_SIGHTLESS       = (UNIT_STATE_LOST_CONTROL | UNIT_STATE_EVADE),
+    UNIT_STATE_CANNOT_AUTOATTACK     = (UNIT_STATE_LOST_CONTROL | UNIT_STATE_CASTING),
+    UNIT_STATE_CANNOT_TURN     = (UNIT_STATE_LOST_CONTROL | UNIT_STATE_ROTATING),
     // stay by different reasons
-    UNIT_STAT_NOT_MOVE        = UNIT_STAT_ROOT | UNIT_STAT_STUNNED | UNIT_STAT_DIED | UNIT_STAT_DISTRACTED,
-    UNIT_STAT_ALL_STATE       = 0xffffffff                      //(UNIT_STAT_STOPPED | UNIT_STAT_MOVING | UNIT_STAT_IN_COMBAT | UNIT_STAT_IN_FLIGHT)
+    UNIT_STATE_NOT_MOVE        = UNIT_STATE_ROOT | UNIT_STATE_STUNNED | UNIT_STATE_DIED | UNIT_STATE_DISTRACTED,
+    UNIT_STATE_ALL_STATE       = 0xffffffff                      //(UNIT_STATE_STOPPED | UNIT_STATE_MOVING | UNIT_STATE_IN_COMBAT | UNIT_STATE_IN_FLIGHT)
 };
 
 enum UnitMoveType
@@ -589,8 +589,8 @@ enum UnitFlags
     UNIT_FLAG_PREPARATION           = 0x00000020,           // don't take reagents for spells with SPELL_ATTR5_NO_REAGENT_WHILE_PREP
     UNIT_FLAG_UNK_6                 = 0x00000040,
     UNIT_FLAG_NOT_ATTACKABLE_1      = 0x00000080,           // ?? (UNIT_FLAG_PVP_ATTACKABLE | UNIT_FLAG_NOT_ATTACKABLE_1) is NON_PVP_ATTACKABLE
-    UNIT_FLAG_OOC_NOT_ATTACKABLE    = 0x00000100,           // 2.0.8 - (OOC Out Of Combat) Can not be attacked when not in combat. Removed if unit for some reason enter combat.
-    UNIT_FLAG_PASSIVE               = 0x00000200,           // makes you unable to attack everything. Almost identical to our "civilian"-term. Will ignore it's surroundings and not engage in combat unless "called upon" or engaged by another unit.
+    UNIT_FLAG_IMMUNE_TO_PC          = 0x00000100,           // disables combat/assistance with PlayerCharacters (PC) - see Unit::_IsValidAttackTarget, Unit::_IsValidAssistTarget
+    UNIT_FLAG_IMMUNE_TO_NPC         = 0x00000200,           // disables combat/assistance with NonPlayerCharacters (NPC) - see Unit::_IsValidAttackTarget, Unit::_IsValidAssistTarget
     UNIT_FLAG_LOOTING               = 0x00000400,           // loot animation
     UNIT_FLAG_PET_IN_COMBAT         = 0x00000800,           // in combat?, 2.0.8
     UNIT_FLAG_PVP                   = 0x00001000,           // changed in 3.0.3
@@ -788,6 +788,25 @@ enum MeleeHitOutcome
     MELEE_HIT_GLANCING, MELEE_HIT_CRIT, MELEE_HIT_CRUSHING, MELEE_HIT_NORMAL
 };
 
+class DispelInfo
+{
+private:
+    Unit* const m_dispeller;
+    uint32 const m_dispellerSpellId;
+    uint8 m_chargesRemoved;
+public:
+    explicit DispelInfo(Unit* _dispeller, uint32 _dispellerSpellId, uint8 _chargesRemoved) :
+    m_dispeller(_dispeller), m_dispellerSpellId(_dispellerSpellId), m_chargesRemoved(_chargesRemoved) {}
+
+    Unit* GetDispeller() { return m_dispeller; }
+    uint32 GetDispellerSpellId() { return m_dispellerSpellId; }
+    uint8 GetRemovedCharges() { return m_chargesRemoved; }
+    void SetRemovedCharges(uint8 amount)
+    {
+        m_chargesRemoved = amount;
+    }
+};
+
 struct CleanDamage
 {
     CleanDamage(uint32 mitigated, uint32 absorbed, WeaponAttackType _attackType, MeleeHitOutcome _hitOutCome) :
@@ -1280,7 +1299,7 @@ class Unit : public WorldObject
         void CombatStop(bool includingCast = false);
         void CombatStopWithPets(bool includingCast = false);
         void StopAttackFaction(uint32 faction_id);
-        Unit* SelectNearbyTarget(float dist = NOMINAL_MELEE_RANGE) const;
+        Unit* SelectNearbyTarget(Unit* exclude = NULL, float dist = NOMINAL_MELEE_RANGE) const;
         void SendMeleeAttackStop(Unit* victim = NULL);
         void SendMeleeAttackStart(Unit* pVictim);
 
@@ -1289,8 +1308,8 @@ class Unit : public WorldObject
         void ClearUnitState(uint32 f) { m_state &= ~f; }
         bool CanFreeMove() const
         {
-            return !HasUnitState(UNIT_STAT_CONFUSED | UNIT_STAT_FLEEING | UNIT_STAT_IN_FLIGHT |
-                UNIT_STAT_ROOT | UNIT_STAT_STUNNED | UNIT_STAT_DISTRACTED) && GetOwnerGUID() == 0;
+            return !HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_FLEEING | UNIT_STATE_IN_FLIGHT |
+                UNIT_STATE_ROOT | UNIT_STATE_STUNNED | UNIT_STATE_DISTRACTED) && GetOwnerGUID() == 0;
         }
 
         uint32 HasUnitTypeMask(uint32 mask) const { return mask & m_unitTypeMask; }
@@ -1525,7 +1544,7 @@ class Unit : public WorldObject
         }
         bool isSpiritService() const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_SPIRITHEALER | UNIT_NPC_FLAG_SPIRITGUIDE); }
 
-        bool isInFlight()  const { return HasUnitState(UNIT_STAT_IN_FLIGHT); }
+        bool isInFlight()  const { return HasUnitState(UNIT_STATE_IN_FLIGHT); }
 
         bool isInCombat()  const { return HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IN_COMBAT); }
         void CombatStart(Unit* target, bool initialAggro = true);
@@ -1536,6 +1555,8 @@ class Unit : public WorldObject
 
         bool HasAuraTypeWithFamilyFlags(AuraType auraType, uint32 familyName, uint32 familyFlags) const;
         bool virtual HasSpell(uint32 /*spellID*/) const { return false; }
+        bool HasBreakableByDamageAuraType(AuraType type) const;
+        bool HasBreakableByDamageCrowdControlAura() const;
 
         bool HasStealthAura()      const { return HasAuraType(SPELL_AURA_MOD_STEALTH); }
         bool HasInvisibilityAura() const { return HasAuraType(SPELL_AURA_MOD_INVISIBILITY); }
@@ -1682,8 +1703,8 @@ class Unit : public WorldObject
         void RemoveAllControlled();
 
         bool isCharmed() const { return GetCharmerGUID() != 0; }
-        bool isPossessed() const { return HasUnitState(UNIT_STAT_POSSESSED); }
-        bool isPossessedByPlayer() const { return HasUnitState(UNIT_STAT_POSSESSED) && IS_PLAYER_GUID(GetCharmerGUID()); }
+        bool isPossessed() const { return HasUnitState(UNIT_STATE_POSSESSED); }
+        bool isPossessedByPlayer() const { return HasUnitState(UNIT_STATE_POSSESSED) && IS_PLAYER_GUID(GetCharmerGUID()); }
         bool isPossessing() const
         {
             if (Unit* u = GetCharm())
@@ -1744,7 +1765,7 @@ class Unit : public WorldObject
 
         void RemoveAurasDueToSpell(uint32 spellId, uint64 casterGUID = 0, uint8 reqEffMask = 0, AuraRemoveMode removeMode = AURA_REMOVE_BY_DEFAULT);
         void RemoveAuraFromStack(uint32 spellId, uint64 casterGUID = 0, AuraRemoveMode removeMode = AURA_REMOVE_BY_DEFAULT);
-        void RemoveAurasDueToSpellByDispel(uint32 spellId, uint64 casterGUID, Unit* dispeller, uint8 chargesRemoved = 1);
+        void RemoveAurasDueToSpellByDispel(uint32 spellId, uint32 dispellerSpellId, uint64 casterGUID, Unit* dispeller, uint8 chargesRemoved = 1);
         void RemoveAurasDueToSpellBySteal(uint32 spellId, uint64 casterGUID, Unit* stealer);
         void RemoveAurasDueToItemSpell(Item* castItem, uint32 spellId);
         void RemoveAurasByType(AuraType auraType, uint64 casterGUID = 0, Aura* except = NULL, bool negative = true, bool positive = true);
@@ -2048,7 +2069,7 @@ class Unit : public WorldObject
         MotionMaster* GetMotionMaster() { return &i_motionMaster; }
         const MotionMaster* GetMotionMaster() const { return &i_motionMaster; }
 
-        bool IsStopped() const { return !(HasUnitState(UNIT_STAT_MOVING)); }
+        bool IsStopped() const { return !(HasUnitState(UNIT_STATE_MOVING)); }
         void StopMoving();
 
         void AddUnitMovementFlag(uint32 f) { m_movementInfo.flags |= f; }
diff --git a/src/server/game/Entities/Vehicle/Vehicle.cpp b/src/server/game/Entities/Vehicle/Vehicle.cpp
index 7e4beba..fc6c6cb 100755
--- a/src/server/game/Entities/Vehicle/Vehicle.cpp
+++ b/src/server/game/Entities/Vehicle/Vehicle.cpp
@@ -176,7 +176,7 @@ void Vehicle::ApplyAllImmunities()
         case 160: // Strand of the Ancients
         case 244: // Wintergrasp
         case 510: // Isle of Conquest
-            _me->SetControlled(true, UNIT_STAT_ROOT);
+            _me->SetControlled(true, UNIT_STATE_ROOT);
             // why we need to apply this? we can simple add immunities to slow mechanic in DB
             _me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DECREASE_SPEED, true);
             break;
@@ -342,7 +342,7 @@ bool Vehicle::AddPassenger(Unit* unit, int8 seatId)
     }
 
     if (seat->second.SeatInfo->m_flags && !(seat->second.SeatInfo->m_flags & VEHICLE_SEAT_FLAG_UNK1))
-        unit->AddUnitState(UNIT_STAT_ONVEHICLE);
+        unit->AddUnitState(UNIT_STATE_ONVEHICLE);
 
     unit->AddUnitMovementFlag(MOVEMENTFLAG_ONTRANSPORT);
     VehicleSeatEntry const* veSeat = seat->second.SeatInfo;
@@ -364,7 +364,7 @@ bool Vehicle::AddPassenger(Unit* unit, int8 seatId)
     if (_me->IsInWorld())
     {
         unit->SendClearTarget();                                // SMSG_BREAK_TARGET
-        unit->SetControlled(true, UNIT_STAT_ROOT);              // SMSG_FORCE_ROOT - In some cases we send SMSG_SPLINE_MOVE_ROOT here (for creatures)
+        unit->SetControlled(true, UNIT_STATE_ROOT);              // SMSG_FORCE_ROOT - In some cases we send SMSG_SPLINE_MOVE_ROOT here (for creatures)
                                                                 // also adds MOVEMENTFLAG_ROOT
         unit->SendMonsterMoveTransport(_me);                     // SMSG_MONSTER_MOVE_TRANSPORT
 
@@ -407,7 +407,7 @@ void Vehicle::RemovePassenger(Unit* unit)
         ++_usableSeatNum;
     }
 
-    unit->ClearUnitState(UNIT_STAT_ONVEHICLE);
+    unit->ClearUnitState(UNIT_STATE_ONVEHICLE);
 
     if (_me->GetTypeId() == TYPEID_UNIT && unit->GetTypeId() == TYPEID_PLAYER && seat->first == 0 && seat->second.SeatInfo->m_flags & VEHICLE_SEAT_FLAG_CAN_CONTROL)
         _me->RemoveCharmedBy(unit);
diff --git a/src/server/game/Grids/Notifiers/GridNotifiers.cpp b/src/server/game/Grids/Notifiers/GridNotifiers.cpp
index 5e5fbf4..2446e9d 100755
--- a/src/server/game/Grids/Notifiers/GridNotifiers.cpp
+++ b/src/server/game/Grids/Notifiers/GridNotifiers.cpp
@@ -113,7 +113,7 @@ inline void CreatureUnitRelocationWorker(Creature* c, Unit* u)
     if (!u->isAlive() || !c->isAlive() || c == u || u->isInFlight())
         return;
 
-    if (c->HasReactState(REACT_AGGRESSIVE) && !c->HasUnitState(UNIT_STAT_SIGHTLESS))
+    if (c->HasReactState(REACT_AGGRESSIVE) && !c->HasUnitState(UNIT_STATE_SIGHTLESS))
         if (c->IsAIEnabled && c->canSeeOrDetect(u, false, true))
             c->AI()->MoveInLineOfSight_Safe(u);
 }
diff --git a/src/server/game/Grids/Notifiers/GridNotifiers.h b/src/server/game/Grids/Notifiers/GridNotifiers.h
index dd73cdc..e3029a1 100755
--- a/src/server/game/Grids/Notifiers/GridNotifiers.h
+++ b/src/server/game/Grids/Notifiers/GridNotifiers.h
@@ -746,7 +746,7 @@ namespace Trinity
             bool operator()(Unit* u)
             {
                 if (u->isAlive() && u->isInCombat() && !i_obj->IsHostileTo(u) && i_obj->IsWithinDistInMap(u, i_range) &&
-                    (u->isFeared() || u->isCharmed() || u->isFrozen() || u->HasUnitState(UNIT_STAT_STUNNED) || u->HasUnitState(UNIT_STAT_CONFUSED)))
+                    (u->isFeared() || u->isCharmed() || u->isFrozen() || u->HasUnitState(UNIT_STATE_STUNNED) || u->HasUnitState(UNIT_STATE_CONFUSED)))
                 {
                     return true;
                 }
diff --git a/src/server/game/Handlers/AuctionHouseHandler.cpp b/src/server/game/Handlers/AuctionHouseHandler.cpp
index 59eefb9..8a98b03 100755
--- a/src/server/game/Handlers/AuctionHouseHandler.cpp
+++ b/src/server/game/Handlers/AuctionHouseHandler.cpp
@@ -46,7 +46,7 @@ void WorldSession::HandleAuctionHelloOpcode(WorldPacket & recv_data)
     }
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     SendAuctionHello(guid, unit);
@@ -161,7 +161,7 @@ void WorldSession::HandleAuctionSellItem(WorldPacket & recv_data)
     }
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     Item* it = player->GetItemByGuid(item);
@@ -274,7 +274,7 @@ void WorldSession::HandleAuctionPlaceBid(WorldPacket & recv_data)
     }
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     AuctionHouseObject* auctionHouse = sAuctionMgr->GetAuctionsMap(creature->getFaction());
@@ -394,7 +394,7 @@ void WorldSession::HandleAuctionRemoveItem(WorldPacket & recv_data)
     }
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     AuctionHouseObject* auctionHouse = sAuctionMgr->GetAuctionsMap(creature->getFaction());
@@ -482,7 +482,7 @@ void WorldSession::HandleAuctionListBidderItems(WorldPacket & recv_data)
     }
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     AuctionHouseObject* auctionHouse = sAuctionMgr->GetAuctionsMap(creature->getFaction());
@@ -531,7 +531,7 @@ void WorldSession::HandleAuctionListOwnerItems(WorldPacket & recv_data)
     }
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     AuctionHouseObject* auctionHouse = sAuctionMgr->GetAuctionsMap(creature->getFaction());
@@ -586,7 +586,7 @@ void WorldSession::HandleAuctionListItems(WorldPacket & recv_data)
     }
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     AuctionHouseObject* auctionHouse = sAuctionMgr->GetAuctionsMap(creature->getFaction());
diff --git a/src/server/game/Handlers/CharacterHandler.cpp b/src/server/game/Handlers/CharacterHandler.cpp
index bd9668c..0094c20 100644
--- a/src/server/game/Handlers/CharacterHandler.cpp
+++ b/src/server/game/Handlers/CharacterHandler.cpp
@@ -1004,7 +1004,7 @@ void WorldSession::HandlePlayerLogin(LoginQueryHolder* holder)
     sLog->outChar("Account: %d (IP: %s) Login Character:[%s] (GUID: %u)",
         GetAccountId(), IP_str.c_str(), pCurrChar->GetName(), pCurrChar->GetGUIDLow());
 
-    if (!pCurrChar->IsStandState() && !pCurrChar->HasUnitState(UNIT_STAT_STUNNED))
+    if (!pCurrChar->IsStandState() && !pCurrChar->HasUnitState(UNIT_STATE_STUNNED))
         pCurrChar->SetStandState(UNIT_STAND_STATE_STAND);
 
     m_playerLoading = false;
diff --git a/src/server/game/Handlers/ChatHandler.cpp b/src/server/game/Handlers/ChatHandler.cpp
index 3d68919..966eae5 100755
--- a/src/server/game/Handlers/ChatHandler.cpp
+++ b/src/server/game/Handlers/ChatHandler.cpp
@@ -481,7 +481,7 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket & recv_data)
 
 void WorldSession::HandleEmoteOpcode(WorldPacket & recv_data)
 {
-    if (!GetPlayer()->isAlive() || GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (!GetPlayer()->isAlive() || GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         return;
 
     uint32 emote;
@@ -558,7 +558,7 @@ void WorldSession::HandleTextEmoteOpcode(WorldPacket & recv_data)
             break;
         default:
             // Only allow text-emotes for "dead" entities (feign death included)
-            if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+            if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
                 break;
              GetPlayer()->HandleEmoteCommand(emote_anim);
              break;
diff --git a/src/server/game/Handlers/GuildHandler.cpp b/src/server/game/Handlers/GuildHandler.cpp
index d2a5f80..9115f8f 100755
--- a/src/server/game/Handlers/GuildHandler.cpp
+++ b/src/server/game/Handlers/GuildHandler.cpp
@@ -303,7 +303,7 @@ void WorldSession::HandleSaveGuildEmblemOpcode(WorldPacket& recvPacket)
     if (GetPlayer()->GetNPCIfCanInteractWith(vendorGuid, UNIT_NPC_FLAG_TABARDDESIGNER))
     {
         // Remove fake death
-        if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+        if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
             GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
         if (Guild* guild = _GetPlayerGuild(this))
diff --git a/src/server/game/Handlers/ItemHandler.cpp b/src/server/game/Handlers/ItemHandler.cpp
index 47700fd..802597e 100755
--- a/src/server/game/Handlers/ItemHandler.cpp
+++ b/src/server/game/Handlers/ItemHandler.cpp
@@ -503,7 +503,7 @@ void WorldSession::HandleSellItemOpcode(WorldPacket & recv_data)
     }
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     Item* pItem = _player->GetItemByGuid(itemguid);
@@ -614,7 +614,7 @@ void WorldSession::HandleBuybackItem(WorldPacket & recv_data)
     }
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     Item* pItem = _player->GetItemFromBuyBackSlot(slot);
@@ -732,11 +732,11 @@ void WorldSession::SendListInventory(uint64 vendorGuid)
     }
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     // Stop the npc if moving
-    if (vendor->HasUnitState(UNIT_STAT_MOVING))
+    if (vendor->HasUnitState(UNIT_STATE_MOVING))
         vendor->StopMoving();
 
     VendorItemData const* items = vendor->GetVendorItems();
diff --git a/src/server/game/Handlers/MiscHandler.cpp b/src/server/game/Handlers/MiscHandler.cpp
index d1227c9..f109332 100755
--- a/src/server/game/Handlers/MiscHandler.cpp
+++ b/src/server/game/Handlers/MiscHandler.cpp
@@ -122,7 +122,7 @@ void WorldSession::HandleGossipSelectOptionOpcode(WorldPacket & recv_data)
     }
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     if ((unit && unit->GetCreatureInfo()->ScriptID != unit->LastUsedScriptID) || (go && go->GetGOInfo()->ScriptId != go->LastUsedScriptID))
diff --git a/src/server/game/Handlers/NPCHandler.cpp b/src/server/game/Handlers/NPCHandler.cpp
index ef49b33..1f286a0 100755
--- a/src/server/game/Handlers/NPCHandler.cpp
+++ b/src/server/game/Handlers/NPCHandler.cpp
@@ -60,7 +60,7 @@ void WorldSession::HandleTabardVendorActivateOpcode(WorldPacket & recv_data)
     }
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     SendTabardVendorActivate(guid);
@@ -89,7 +89,7 @@ void WorldSession::HandleBankerActivateOpcode(WorldPacket & recv_data)
     }
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     SendShowBank(guid);
@@ -128,7 +128,7 @@ void WorldSession::SendTrainerList(uint64 guid, const std::string& strTitle)
     }
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     // trainer list loaded at check;
@@ -250,7 +250,7 @@ void WorldSession::HandleTrainerBuySpellOpcode(WorldPacket & recv_data)
     }
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     if (!unit->isCanTrainingOf(_player, true))
@@ -314,7 +314,7 @@ void WorldSession::HandleGossipHelloOpcode(WorldPacket & recv_data)
 
     GetPlayer()->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TALK);
     // remove fake death
-    //if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    //if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
     //    GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     if (unit->isArmorer() || unit->isCivilian() || unit->isQuestGiver() || unit->isServiceProvider() || unit->isGuard())
@@ -369,7 +369,7 @@ void WorldSession::HandleGossipHelloOpcode(WorldPacket & recv_data)
     }
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     if (!code.empty())
@@ -400,7 +400,7 @@ void WorldSession::HandleSpiritHealerActivateOpcode(WorldPacket & recv_data)
     }
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     SendSpiritResurrect();
@@ -455,7 +455,7 @@ void WorldSession::HandleBinderActivateOpcode(WorldPacket & recv_data)
     }
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     SendBindPoint(unit);
@@ -507,7 +507,7 @@ void WorldSession::HandleListStabledPetsOpcode(WorldPacket & recv_data)
         return;
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     // remove mounts this fix bug where getting pet from stable while mounted deletes pet.
@@ -609,7 +609,7 @@ void WorldSession::HandleStablePet(WorldPacket & recv_data)
     }
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     Pet* pet = _player->GetPet();
@@ -679,7 +679,7 @@ void WorldSession::HandleUnstablePet(WorldPacket & recv_data)
     }
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PET_ENTRY);
@@ -759,7 +759,7 @@ void WorldSession::HandleBuyStableSlot(WorldPacket & recv_data)
     }
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     if (GetPlayer()->m_stableSlots < MAX_PET_STABLES)
@@ -798,7 +798,7 @@ void WorldSession::HandleStableSwapPet(WorldPacket & recv_data)
     }
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     Pet* pet = _player->GetPet();
@@ -886,7 +886,7 @@ void WorldSession::HandleRepairItemOpcode(WorldPacket & recv_data)
     }
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     // reputation discount
diff --git a/src/server/game/Handlers/PetHandler.cpp b/src/server/game/Handlers/PetHandler.cpp
index 68ce315..16b6a4b 100755
--- a/src/server/game/Handlers/PetHandler.cpp
+++ b/src/server/game/Handlers/PetHandler.cpp
@@ -202,7 +202,7 @@ void WorldSession::HandlePetActionHelper(Unit* pet, uint64 guid1, uint16 spellid
                             return;
                     }
 
-                    pet->ClearUnitState(UNIT_STAT_FOLLOW);
+                    pet->ClearUnitState(UNIT_STATE_FOLLOW);
                     // This is true if pet has no target or has target but targets differs.
                     if (pet->getVictim() != TargetUnit || (pet->getVictim() == TargetUnit && !pet->GetCharmInfo()->IsCommandAttack()))
                     {
@@ -777,7 +777,7 @@ void WorldSession::HandlePetCastSpellOpcode(WorldPacket& recvPacket)
     targets.Read(recvPacket, caster);
     HandleClientCastFlags(recvPacket, castFlags, targets);
 
-    caster->ClearUnitState(UNIT_STAT_FOLLOW);
+    caster->ClearUnitState(UNIT_STATE_FOLLOW);
 
     Spell* spell = new Spell(caster, spellInfo, TRIGGERED_NONE);
     spell->m_cast_count = castCount;                    // probably pending spell cast
diff --git a/src/server/game/Handlers/PetitionsHandler.cpp b/src/server/game/Handlers/PetitionsHandler.cpp
index 26185d3..b4c0781 100755
--- a/src/server/game/Handlers/PetitionsHandler.cpp
+++ b/src/server/game/Handlers/PetitionsHandler.cpp
@@ -98,7 +98,7 @@ void WorldSession::HandlePetitionBuyOpcode(WorldPacket & recv_data)
     }
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     uint32 charterid = 0;
diff --git a/src/server/game/Handlers/QueryHandler.cpp b/src/server/game/Handlers/QueryHandler.cpp
index c907620..5702eef 100755
--- a/src/server/game/Handlers/QueryHandler.cpp
+++ b/src/server/game/Handlers/QueryHandler.cpp
@@ -251,7 +251,7 @@ void WorldSession::HandleCorpseQueryOpcode(WorldPacket & /*recv_data*/)
                     mapid = corpseMapEntry->entrance_map;
                     x = corpseMapEntry->entrance_x;
                     y = corpseMapEntry->entrance_y;
-                    z = entranceMap->GetHeight(GetPlayer()->GetPhaseMask(), x, y, MAX_HEIGHT);
+                    z = entranceMap->GetHeight(x, y, MAX_HEIGHT);
                 }
             }
         }
diff --git a/src/server/game/Handlers/QuestHandler.cpp b/src/server/game/Handlers/QuestHandler.cpp
index 7e80c78..f9aa40c 100755
--- a/src/server/game/Handlers/QuestHandler.cpp
+++ b/src/server/game/Handlers/QuestHandler.cpp
@@ -95,7 +95,7 @@ void WorldSession::HandleQuestgiverHelloOpcode(WorldPacket & recv_data)
     }
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
     // Stop the npc if moving
     creature->StopMoving();
diff --git a/src/server/game/Handlers/SkillHandler.cpp b/src/server/game/Handlers/SkillHandler.cpp
index 520cd89..355effb 100755
--- a/src/server/game/Handlers/SkillHandler.cpp
+++ b/src/server/game/Handlers/SkillHandler.cpp
@@ -68,7 +68,7 @@ void WorldSession::HandleTalentWipeConfirmOpcode(WorldPacket & recv_data)
     }
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     if (!(_player->resetTalents()))
diff --git a/src/server/game/Handlers/TaxiHandler.cpp b/src/server/game/Handlers/TaxiHandler.cpp
index 3533b15..8eb1eab 100755
--- a/src/server/game/Handlers/TaxiHandler.cpp
+++ b/src/server/game/Handlers/TaxiHandler.cpp
@@ -79,7 +79,7 @@ void WorldSession::HandleTaxiQueryAvailableNodes(WorldPacket & recv_data)
     }
 
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     // unknown taxi node case
@@ -118,7 +118,7 @@ void WorldSession::SendTaxiMenu(Creature* unit)
 void WorldSession::SendDoFlight(uint32 mountDisplayId, uint32 path, uint32 pathNode)
 {
     // remove fake death
-    if (GetPlayer()->HasUnitState(UNIT_STAT_DIED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     while (GetPlayer()->GetMotionMaster()->GetCurrentMovementGeneratorType() == FLIGHT_MOTION_TYPE)
diff --git a/src/server/game/Handlers/TradeHandler.cpp b/src/server/game/Handlers/TradeHandler.cpp
index ebe54eb..4c39992 100755
--- a/src/server/game/Handlers/TradeHandler.cpp
+++ b/src/server/game/Handlers/TradeHandler.cpp
@@ -561,7 +561,7 @@ void WorldSession::HandleInitiateTradeOpcode(WorldPacket& recvPacket)
         return;
     }
 
-    if (GetPlayer()->HasUnitState(UNIT_STAT_STUNNED))
+    if (GetPlayer()->HasUnitState(UNIT_STATE_STUNNED))
     {
         SendTradeStatus(TRADE_STATUS_YOU_STUNNED);
         return;
@@ -611,7 +611,7 @@ void WorldSession::HandleInitiateTradeOpcode(WorldPacket& recvPacket)
         return;
     }
 
-    if (pOther->HasUnitState(UNIT_STAT_STUNNED))
+    if (pOther->HasUnitState(UNIT_STATE_STUNNED))
     {
         SendTradeStatus(TRADE_STATUS_TARGET_STUNNED);
         return;
diff --git a/src/server/game/Maps/Map.cpp b/src/server/game/Maps/Map.cpp
index 71fc2ef..df5ec54 100755
--- a/src/server/game/Maps/Map.cpp
+++ b/src/server/game/Maps/Map.cpp
@@ -31,7 +31,6 @@
 #include "ObjectMgr.h"
 #include "Group.h"
 #include "LFGMgr.h"
-#include "DynamicTree.h"
 
 union u_map_magic
 {
@@ -369,7 +368,6 @@ bool Map::EnsureGridLoaded(const Cell &cell)
 
         // Add resurrectable corpses to world object list in grid
         sObjectAccessor->AddCorpsesToGrid(GridCoord(cell.GridX(), cell.GridY()), grid->GetGridType(cell.CellX(), cell.CellY()), this);
-        Balance();
         return true;
     }
 
@@ -500,7 +498,6 @@ void Map::VisitNearbyCellsOf(WorldObject* obj, TypeContainerVisitor<Trinity::Obj
 
 void Map::Update(const uint32 t_diff)
 {
-    m_dyn_tree.update(t_diff);
     /// update worldsessions for existing players
     for (m_mapRefIter = m_mapRefManager.begin(); m_mapRefIter != m_mapRefManager.end(); ++m_mapRefIter)
     {
@@ -1547,7 +1544,7 @@ float Map::GetWaterOrGroundLevel(float x, float y, float z, float* ground /*= NU
     if (const_cast<Map*>(this)->GetGrid(x, y))
     {
         // we need ground level (including grid height version) for proper return water level in point
-        float ground_z = GetHeight(PHASEMASK_NORMAL, x, y, z, true, 50.0f);
+        float ground_z = GetHeight(x, y, z, true, 50.0f);
         if (ground)
             *ground = ground_z;
 
@@ -1796,17 +1793,6 @@ void Map::GetZoneAndAreaIdByAreaFlag(uint32& zoneid, uint32& areaid, uint16 area
     zoneid = entry ? ((entry->zone != 0) ? entry->zone : entry->ID) : 0;
 }
 
-bool Map::isInLineOfSight(float x1, float y1, float z1, float x2, float y2, float z2, uint32 phasemask) const
-{
-    return VMAP::VMapFactory::createOrGetVMapManager()->isInLineOfSight(GetId(), x1, y1, z1, x2, y2, z2)
-        && m_dyn_tree.isInLineOfSight(x1, y1, z1, x2, y2, z2, phasemask);
-}
-
-float Map::GetHeight(uint32 phasemask, float x, float y, float z, bool vmap/*=true*/, float maxSearchDist/*=DEFAULT_HEIGHT_SEARCH*/) const
-{
-    return std::max<float>(GetHeight(x, y, z, vmap, maxSearchDist), m_dyn_tree.getHeight(x, y, z, maxSearchDist, phasemask));
-}
-
 bool Map::IsInWater(float x, float y, float pZ, LiquidData* data) const
 {
     // Check surface in x, y point for liquid
diff --git a/src/server/game/Maps/Map.h b/src/server/game/Maps/Map.h
index 7d234d5..f3b45bd 100755
--- a/src/server/game/Maps/Map.h
+++ b/src/server/game/Maps/Map.h
@@ -30,8 +30,6 @@
 #include "SharedDefines.h"
 #include "GridRefManager.h"
 #include "MapRefManager.h"
-#include "DynamicTree.h"
-#include "GameObjectModel.h"
 
 #include <bitset>
 #include <list>
@@ -427,12 +425,7 @@ class Map : public GridRefManager<NGridType>
         InstanceMap* ToInstanceMap(){ if (IsDungeon())  return reinterpret_cast<InstanceMap*>(this); else return NULL;  }
         const InstanceMap* ToInstanceMap() const { if (IsDungeon())  return (const InstanceMap*)((InstanceMap*)this); else return NULL;  }
         float GetWaterOrGroundLevel(float x, float y, float z, float* ground = NULL, bool swim = false) const;
-        float GetHeight(uint32 phasemask, float x, float y, float z, bool vmap = true, float maxSearchDist = DEFAULT_HEIGHT_SEARCH) const;
-        bool isInLineOfSight(float x1, float y1, float z1, float x2, float y2, float z2, uint32 phasemask) const;
-        void Balance() { m_dyn_tree.balance(); }
-        void Remove(const GameObjectModel& mdl) { m_dyn_tree.remove(mdl); }
-        void Insert(const GameObjectModel& mdl) { m_dyn_tree.insert(mdl); }
-        bool Contains(const GameObjectModel& mdl) const { return m_dyn_tree.contains(mdl);}
+
     private:
         void LoadMapAndVMap(int gx, int gy);
         void LoadVMap(int gx, int gy);
@@ -488,7 +481,6 @@ class Map : public GridRefManager<NGridType>
         uint32 i_InstanceId;
         uint32 m_unloadTimer;
         float m_VisibleDistance;
-        DynamicMapTree m_dyn_tree;
 
         MapRefManager m_mapRefManager;
         MapRefManager::iterator m_mapRefIter;
diff --git a/src/server/game/Miscellaneous/SharedDefines.h b/src/server/game/Miscellaneous/SharedDefines.h
index 81b1b14..da4f022 100755
--- a/src/server/game/Miscellaneous/SharedDefines.h
+++ b/src/server/game/Miscellaneous/SharedDefines.h
@@ -95,6 +95,7 @@ enum Races
 // Class value is index in ChrClasses.dbc
 enum Classes
 {
+    CLASS_NONE          = 0,
     CLASS_WARRIOR       = 1,
     CLASS_PALADIN       = 2,
     CLASS_HUNTER        = 3,
@@ -1502,6 +1503,7 @@ enum GameObjectDestructibleState
     GO_DESTRUCTIBLE_REBUILDING  = 3,
 };
 
+// EmotesText.dbc
 enum TextEmotes
 {
     TEXT_EMOTE_AGREE                = 1,
@@ -1665,7 +1667,7 @@ enum TextEmotes
     TEXT_EMOTE_ATTACKMYTARGET       = 307,
     TEXT_EMOTE_OOM                  = 323,
     TEXT_EMOTE_FOLLOW               = 324,
-    TEXT_EMOTE_HELP                 = 325,
+    TEXT_EMOTE_WAIT                 = 325,
     TEXT_EMOTE_HEALME               = 326,
     TEXT_EMOTE_OPENFIRE             = 327,
     TEXT_EMOTE_FLIRT                = 328,
@@ -1674,7 +1676,7 @@ enum TextEmotes
     TEXT_EMOTE_WINK                 = 363,
     TEXT_EMOTE_PAT                  = 364,
     TEXT_EMOTE_SERIOUS              = 365,
-    TEXT_EMOTE_MOUNTSPECIAL         = 366,
+    TEXT_EMOTE_MOUNT_SPECIAL        = 366,
     TEXT_EMOTE_GOODLUCK             = 367,
     TEXT_EMOTE_BLAME                = 368,
     TEXT_EMOTE_BLANK                = 369,
@@ -1687,6 +1689,7 @@ enum TextEmotes
     TEXT_EMOTE_ENEMY                = 376,
     TEXT_EMOTE_EYEBROW              = 377,
     TEXT_EMOTE_TOAST                = 378,
+    TEXT_EMOTE_FAIL                 = 379,
     TEXT_EMOTE_HIGHFIVE             = 380,
     TEXT_EMOTE_ABSENT               = 381,
     TEXT_EMOTE_ARM                  = 382,
@@ -1741,6 +1744,7 @@ enum TextEmotes
     TEXT_EMOTE_SNEEZE               = 436,
     TEXT_EMOTE_SNORT                = 437,
     TEXT_EMOTE_SQUEAL               = 438,
+    TEXT_EMOTE_STOPATTACK           = 439,
     TEXT_EMOTE_SUSPICIOUS           = 440,
     TEXT_EMOTE_THINK                = 441,
     TEXT_EMOTE_TRUCE                = 442,
@@ -1756,402 +1760,695 @@ enum TextEmotes
     TEXT_EMOTE_YW                   = 453,
 };
 
+// Emotes.dbc
 enum Emote
 {
-    EMOTE_ONESHOT_NONE                 = 0,
-    EMOTE_ONESHOT_TALK                 = 1,
-    EMOTE_ONESHOT_BOW                  = 2,
-    EMOTE_ONESHOT_WAVE                 = 3,
-    EMOTE_ONESHOT_CHEER                = 4,
-    EMOTE_ONESHOT_EXCLAMATION          = 5,
-    EMOTE_ONESHOT_QUESTION             = 6,
-    EMOTE_ONESHOT_EAT                  = 7,
-    EMOTE_STATE_DANCE                  = 10,
-    EMOTE_ONESHOT_LAUGH                = 11,
-    EMOTE_STATE_SLEEP                  = 12,
-    EMOTE_STATE_SIT                    = 13,
-    EMOTE_ONESHOT_RUDE                 = 14,
-    EMOTE_ONESHOT_ROAR                 = 15,
-    EMOTE_ONESHOT_KNEEL                = 16,
-    EMOTE_ONESHOT_KISS                 = 17,
-    EMOTE_ONESHOT_CRY                  = 18,
-    EMOTE_ONESHOT_CHICKEN              = 19,
-    EMOTE_ONESHOT_BEG                  = 20,
-    EMOTE_ONESHOT_APPLAUD              = 21,
-    EMOTE_ONESHOT_SHOUT                = 22,
-    EMOTE_ONESHOT_FLEX                 = 23,
-    EMOTE_ONESHOT_SHY                  = 24,
-    EMOTE_ONESHOT_POINT                = 25,
-    EMOTE_STATE_STAND                  = 26,
-    EMOTE_STATE_READYUNARMED           = 27,
-    EMOTE_STATE_WORK_SHEATHED          = 28,
-    EMOTE_STATE_POINT                  = 29,
-    EMOTE_STATE_NONE                   = 30,
-    EMOTE_ONESHOT_WOUND                = 33,
-    EMOTE_ONESHOT_WOUNDCRITICAL        = 34,
-    EMOTE_ONESHOT_ATTACKUNARMED        = 35,
-    EMOTE_ONESHOT_ATTACK1H             = 36,
-    EMOTE_ONESHOT_ATTACK2HTIGHT        = 37,
-    EMOTE_ONESHOT_ATTACK2HLOOSE        = 38,
-    EMOTE_ONESHOT_PARRYUNARMED         = 39,
-    EMOTE_ONESHOT_PARRYSHIELD          = 43,
-    EMOTE_ONESHOT_READYUNARMED         = 44,
-    EMOTE_ONESHOT_READY1H              = 45,
-    EMOTE_ONESHOT_READYBOW             = 48,
-    EMOTE_ONESHOT_SPELLPRECAST         = 50,
-    EMOTE_ONESHOT_SPELLCAST            = 51,
-    EMOTE_ONESHOT_BATTLEROAR           = 53,
-    EMOTE_ONESHOT_SPECIALATTACK1H      = 54,
-    EMOTE_ONESHOT_KICK                 = 60,
-    EMOTE_ONESHOT_ATTACKTHROWN         = 61,
-    EMOTE_STATE_STUN                   = 64,
-    EMOTE_STATE_DEAD                   = 65,
-    EMOTE_ONESHOT_SALUTE               = 66,
-    EMOTE_STATE_KNEEL                  = 68,
-    EMOTE_STATE_USESTANDING            = 69,
-    EMOTE_ONESHOT_WAVE_NOSHEATHE       = 70,
-    EMOTE_ONESHOT_CHEER_NOSHEATHE      = 71,
-    EMOTE_ONESHOT_EAT_NOSHEATHE        = 92,
-    EMOTE_STATE_STUN_NOSHEATHE         = 93,
-    EMOTE_ONESHOT_DANCE                = 94,
-    EMOTE_ONESHOT_SALUTE_NOSHEATH      = 113,
-    EMOTE_STATE_USESTANDING_NOSHEATHE  = 133,
-    EMOTE_ONESHOT_LAUGH_NOSHEATHE      = 153,
-    EMOTE_STATE_WORK                   = 173,
-    EMOTE_STATE_SPELLPRECAST           = 193,
-    EMOTE_ONESHOT_READYRIFLE           = 213,
-    EMOTE_STATE_READYRIFLE             = 214,
-    EMOTE_STATE_WORK_MINING            = 233,
-    EMOTE_STATE_WORK_CHOPWOOD          = 234,
-    EMOTE_STATE_APPLAUD                = 253,
-    EMOTE_ONESHOT_LIFTOFF              = 254,
-    EMOTE_ONESHOT_YES                  = 273,
-    EMOTE_ONESHOT_NO                   = 274,
-    EMOTE_ONESHOT_TRAIN                = 275,
-    EMOTE_ONESHOT_LAND                 = 293,
-    EMOTE_STATE_AT_EASE                = 313,
-    EMOTE_STATE_READY1H                = 333,
-    EMOTE_STATE_SPELLKNEELSTART        = 353,
-    EMOTE_STATE_SUBMERGED              = 373,
-    EMOTE_ONESHOT_SUBMERGE             = 374,
-    EMOTE_STATE_READY2H                = 375,
-    EMOTE_STATE_READYBOW               = 376,
-    EMOTE_ONESHOT_MOUNTSPECIAL         = 377,
-    EMOTE_STATE_TALK                   = 378,
-    EMOTE_STATE_FISHING                = 379,
-    EMOTE_ONESHOT_FISHING              = 380,
-    EMOTE_ONESHOT_LOOT                 = 381,
-    EMOTE_STATE_WHIRLWIND              = 382,
-    EMOTE_STATE_DROWNED                = 383,
-    EMOTE_STATE_HOLD_BOW               = 384,
-    EMOTE_STATE_HOLD_RIFLE             = 385,
-    EMOTE_STATE_HOLD_THROWN            = 386,
-    EMOTE_ONESHOT_DROWN                = 387,
-    EMOTE_ONESHOT_STOMP                = 388,
-    EMOTE_ONESHOT_ATTACKOFF            = 389,
-    EMOTE_ONESHOT_ATTACKOFFPIERCE      = 390,
-    EMOTE_STATE_ROAR                   = 391,
-    EMOTE_STATE_LAUGH                  = 392,
-    EMOTE_ONESHOT_CREATURE_SPECIAL     = 393,
-    EMOTE_ONESHOT_JUMPLANDRUN          = 394,
-    EMOTE_ONESHOT_JUMPEND              = 395,
-    EMOTE_ONESHOT_TALK_NOSHEATHE       = 396,
-    EMOTE_ONESHOT_POINT_NOSHEATHE      = 397,
-    EMOTE_STATE_CANNIBALIZE            = 398,
-    EMOTE_ONESHOT_JUMPSTART            = 399,
-    EMOTE_STATE_DANCESPECIAL           = 400,
-    EMOTE_ONESHOT_DANCESPECIAL         = 401,
-    EMOTE_ONESHOT_CUSTOMSPELL01        = 402,
-    EMOTE_ONESHOT_CUSTOMSPELL02        = 403,
-    EMOTE_ONESHOT_CUSTOMSPELL03        = 404,
-    EMOTE_ONESHOT_CUSTOMSPELL04        = 405,
-    EMOTE_ONESHOT_CUSTOMSPELL05        = 406,
-    EMOTE_ONESHOT_CUSTOMSPELL06        = 407,
-    EMOTE_ONESHOT_CUSTOMSPELL07        = 408,
-    EMOTE_ONESHOT_CUSTOMSPELL08        = 409,
-    EMOTE_ONESHOT_CUSTOMSPELL09        = 410,
-    EMOTE_ONESHOT_CUSTOMSPELL10        = 411,
-    EMOTE_STATE_EXCLAIM                = 412,
-    EMOTE_STATE_DANCE_CUSTOM           = 413,
-    EMOTE_STATE_SIT_CHAIR_MED          = 415,
-    EMOTE_STATE_CUSTOM_SPELL_01        = 416,
-    EMOTE_STATE_CUSTOM_SPELL_02        = 417,
-    EMOTE_STATE_EAT                    = 418,
-    EMOTE_STATE_CUSTOM_SPELL_04        = 419,
-    EMOTE_STATE_CUSTOM_SPELL_03        = 420,
-    EMOTE_STATE_CUSTOM_SPELL_05        = 421,
-    EMOTE_STATE_SPELLEFFECT_HOLD       = 422,
-    EMOTE_STATE_EAT_NO_SHEATHE         = 423,
-    EMOTE_STATE_MOUNT                  = 424,
-    EMOTE_STATE_READY2HL               = 425,
-    EMOTE_STATE_SIT_CHAIR_HIGH         = 426,
-    EMOTE_STATE_FALL                   = 427,
-    EMOTE_STATE_LOOT                   = 428,
-    EMOTE_STATE_SUBMERGED_NEW          = 429,
-    EMOTE_ONESHOT_COWER                = 430,
-    EMOTE_STATE_COWER                  = 431,
-    EMOTE_ONESHOT_USESTANDING          = 432,
-    EMOTE_STATE_STEALTH_STAND          = 433,
-    EMOTE_ONESHOT_OMNICAST_GHOUL       = 434,
-    EMOTE_ONESHOT_ATTACKBOW            = 435,
-    EMOTE_ONESHOT_ATTACKRIFLE          = 436,
-    EMOTE_STATE_SWIM_IDLE              = 437,
-    EMOTE_STATE_ATTACK_UNARMED         = 438,
-    EMOTE_ONESHOT_SPELLCAST_W_SOUND    = 439,
-    EMOTE_ONESHOT_DODGE                = 440,
-    EMOTE_ONESHOT_PARRY1H              = 441,
-    EMOTE_ONESHOT_PARRY2H              = 442,
-    EMOTE_ONESHOT_PARRY2HL             = 443,
-    EMOTE_STATE_FLYFALL                = 444,
-    EMOTE_ONESHOT_FLYDEATH             = 445,
-    EMOTE_STATE_FLY_FALL               = 446,
-    EMOTE_ONESHOT_FLY_SIT_GROUND_DOWN  = 447,
-    EMOTE_ONESHOT_FLY_SIT_GROUND_UP    = 448,
-    EMOTE_ONESHOT_EMERGE               = 449,
-    EMOTE_ONESHOT_DRAGONSPIT           = 450,
-    EMOTE_STATE_SPECIALUNARMED         = 451,
-    EMOTE_ONESHOT_FLYGRAB              = 452,
-    EMOTE_STATE_FLYGRABCLOSED          = 453,
-    EMOTE_ONESHOT_FLYGRABTHROWN        = 454,
-    EMOTE_STATE_FLY_SIT_GROUND         = 455,
-    EMOTE_STATE_WALKBACKWARDS          = 456,
-    EMOTE_ONESHOT_FLYTALK              = 457,
-    EMOTE_ONESHOT_FLYATTACK1H          = 458,
-    EMOTE_STATE_CUSTOMSPELL08          = 459,
-    EMOTE_ONESHOT_FLY_DRAGONSPIT       = 460,
-    EMOTE_STATE_SIT_CHAIR_LOW          = 461,
-    EMOTE_ONE_SHOT_STUN                = 462,
-    EMOTE_ONESHOT_SPELLCAST_OMNI       = 463,
-    EMOTE_STATE_READYTHROWN            = 464
-};
-
+    EMOTE_ONESHOT_NONE                  = 0,
+    EMOTE_ONESHOT_TALK                  = 1,
+    EMOTE_ONESHOT_BOW                   = 2,
+    EMOTE_ONESHOT_WAVE                  = 3,
+    EMOTE_ONESHOT_CHEER                 = 4,
+    EMOTE_ONESHOT_EXCLAMATION           = 5,
+    EMOTE_ONESHOT_QUESTION              = 6,
+    EMOTE_ONESHOT_EAT                   = 7,
+    EMOTE_STATE_DANCE                   = 10,
+    EMOTE_ONESHOT_LAUGH                 = 11,
+    EMOTE_STATE_SLEEP                   = 12,
+    EMOTE_STATE_SIT                     = 13,
+    EMOTE_ONESHOT_RUDE                  = 14,
+    EMOTE_ONESHOT_ROAR                  = 15,
+    EMOTE_ONESHOT_KNEEL                 = 16,
+    EMOTE_ONESHOT_KISS                  = 17,
+    EMOTE_ONESHOT_CRY                   = 18,
+    EMOTE_ONESHOT_CHICKEN               = 19,
+    EMOTE_ONESHOT_BEG                   = 20,
+    EMOTE_ONESHOT_APPLAUD               = 21,
+    EMOTE_ONESHOT_SHOUT                 = 22,
+    EMOTE_ONESHOT_FLEX                  = 23,
+    EMOTE_ONESHOT_SHY                   = 24,
+    EMOTE_ONESHOT_POINT                 = 25,
+    EMOTE_STATE_STAND                   = 26,
+    EMOTE_STATE_READY_UNARMED           = 27,
+    EMOTE_STATE_WORK_SHEATHED           = 28,
+    EMOTE_STATE_POINT                   = 29,
+    EMOTE_STATE_NONE                    = 30,
+    EMOTE_ONESHOT_WOUND                 = 33,
+    EMOTE_ONESHOT_WOUND_CRITICAL        = 34,
+    EMOTE_ONESHOT_ATTACK_UNARMED        = 35,
+    EMOTE_ONESHOT_ATTACK1H              = 36,
+    EMOTE_ONESHOT_ATTACK2HTIGHT         = 37,
+    EMOTE_ONESHOT_ATTACK2H_LOOSE        = 38,
+    EMOTE_ONESHOT_PARRY_UNARMED         = 39,
+    EMOTE_ONESHOT_PARRY_SHIELD          = 43,
+    EMOTE_ONESHOT_READY_UNARMED         = 44,
+    EMOTE_ONESHOT_READY1H               = 45,
+    EMOTE_ONESHOT_READY_BOW             = 48,
+    EMOTE_ONESHOT_SPELL_PRECAST         = 50,
+    EMOTE_ONESHOT_SPELL_CAST            = 51,
+    EMOTE_ONESHOT_BATTLE_ROAR           = 53,
+    EMOTE_ONESHOT_SPECIALATTACK1H       = 54,
+    EMOTE_ONESHOT_KICK                  = 60,
+    EMOTE_ONESHOT_ATTACK_THROWN         = 61,
+    EMOTE_STATE_STUN                    = 64,
+    EMOTE_STATE_DEAD                    = 65,
+    EMOTE_ONESHOT_SALUTE                = 66,
+    EMOTE_STATE_KNEEL                   = 68,
+    EMOTE_STATE_USE_STANDING            = 69,
+    EMOTE_ONESHOT_WAVE_NO_SHEATHE       = 70,
+    EMOTE_ONESHOT_CHEER_NO_SHEATHE      = 71,
+    EMOTE_ONESHOT_EAT_NO_SHEATHE        = 92,
+    EMOTE_STATE_STUN_NO_SHEATHE         = 93,
+    EMOTE_ONESHOT_DANCE                 = 94,
+    EMOTE_ONESHOT_SALUTE_NO_SHEATH      = 113,
+    EMOTE_STATE_USE_STANDING_NO_SHEATHE = 133,
+    EMOTE_ONESHOT_LAUGH_NO_SHEATHE      = 153,
+    EMOTE_STATE_WORK                    = 173,
+    EMOTE_STATE_SPELL_PRECAST           = 193,
+    EMOTE_ONESHOT_READY_RIFLE           = 213,
+    EMOTE_STATE_READY_RIFLE             = 214,
+    EMOTE_STATE_WORK_MINING             = 233,
+    EMOTE_STATE_WORK_CHOPWOOD           = 234,
+    EMOTE_STATE_APPLAUD                 = 253,
+    EMOTE_ONESHOT_LIFTOFF               = 254,
+    EMOTE_ONESHOT_YES                   = 273,
+    EMOTE_ONESHOT_NO                    = 274,
+    EMOTE_ONESHOT_TRAIN                 = 275,
+    EMOTE_ONESHOT_LAND                  = 293,
+    EMOTE_STATE_AT_EASE                 = 313,
+    EMOTE_STATE_READY1H                 = 333,
+    EMOTE_STATE_SPELL_KNEEL_START       = 353,
+    EMOTE_STATE_SUBMERGED               = 373,
+    EMOTE_ONESHOT_SUBMERGE              = 374,
+    EMOTE_STATE_READY2H                 = 375,
+    EMOTE_STATE_READY_BOW               = 376,
+    EMOTE_ONESHOT_MOUNT_SPECIAL         = 377,
+    EMOTE_STATE_TALK                    = 378,
+    EMOTE_STATE_FISHING                 = 379,
+    EMOTE_ONESHOT_FISHING               = 380,
+    EMOTE_ONESHOT_LOOT                  = 381,
+    EMOTE_STATE_WHIRLWIND               = 382,
+    EMOTE_STATE_DROWNED                 = 383,
+    EMOTE_STATE_HOLD_BOW                = 384,
+    EMOTE_STATE_HOLD_RIFLE              = 385,
+    EMOTE_STATE_HOLD_THROWN             = 386,
+    EMOTE_ONESHOT_DROWN                 = 387,
+    EMOTE_ONESHOT_STOMP                 = 388,
+    EMOTE_ONESHOT_ATTACK_OFF            = 389,
+    EMOTE_ONESHOT_ATTACK_OFF_PIERCE     = 390,
+    EMOTE_STATE_ROAR                    = 391,
+    EMOTE_STATE_LAUGH                   = 392,
+    EMOTE_ONESHOT_CREATURE_SPECIAL      = 393,
+    EMOTE_ONESHOT_JUMPLANDRUN           = 394,
+    EMOTE_ONESHOT_JUMPEND               = 395,
+    EMOTE_ONESHOT_TALK_NO_SHEATHE       = 396,
+    EMOTE_ONESHOT_POINT_NO_SHEATHE      = 397,
+    EMOTE_STATE_CANNIBALIZE             = 398,
+    EMOTE_ONESHOT_JUMPSTART             = 399,
+    EMOTE_STATE_DANCESPECIAL            = 400,
+    EMOTE_ONESHOT_DANCESPECIAL          = 401,
+    EMOTE_ONESHOT_CUSTOM_SPELL_01       = 402,
+    EMOTE_ONESHOT_CUSTOM_SPELL_02       = 403,
+    EMOTE_ONESHOT_CUSTOM_SPELL_03       = 404,
+    EMOTE_ONESHOT_CUSTOM_SPELL_04       = 405,
+    EMOTE_ONESHOT_CUSTOM_SPELL_05       = 406,
+    EMOTE_ONESHOT_CUSTOM_SPELL_06       = 407,
+    EMOTE_ONESHOT_CUSTOM_SPELL_07       = 408,
+    EMOTE_ONESHOT_CUSTOM_SPELL_08       = 409,
+    EMOTE_ONESHOT_CUSTOM_SPELL_09       = 410,
+    EMOTE_ONESHOT_CUSTOM_SPELL_10       = 411,
+    EMOTE_STATE_EXCLAIM                 = 412,
+    EMOTE_STATE_DANCE_CUSTOM            = 413,
+    EMOTE_STATE_SIT_CHAIR_MED           = 415,
+    EMOTE_STATE_CUSTOM_SPELL_01         = 416,
+    EMOTE_STATE_CUSTOM_SPELL_02         = 417,
+    EMOTE_STATE_EAT                     = 418,
+    EMOTE_STATE_CUSTOM_SPELL_04         = 419,
+    EMOTE_STATE_CUSTOM_SPELL_03         = 420,
+    EMOTE_STATE_CUSTOM_SPELL_05         = 421,
+    EMOTE_STATE_SPELLEFFECT_HOLD        = 422,
+    EMOTE_STATE_EAT_NO_SHEATHE          = 423,
+    EMOTE_STATE_MOUNT                   = 424,
+    EMOTE_STATE_READY2HL                = 425,
+    EMOTE_STATE_SIT_CHAIR_HIGH          = 426,
+    EMOTE_STATE_FALL                    = 427,
+    EMOTE_STATE_LOOT                    = 428,
+    EMOTE_STATE_SUBMERGED_NEW           = 429,
+    EMOTE_ONESHOT_COWER                 = 430,
+    EMOTE_STATE_COWER                   = 431,
+    EMOTE_ONESHOT_USE_STANDING          = 432,
+    EMOTE_STATE_STEALTH_STAND           = 433,
+    EMOTE_ONESHOT_OMNICAST_GHOUL        = 434,
+    EMOTE_ONESHOT_ATTACK_BOW            = 435,
+    EMOTE_ONESHOT_ATTACK_RIFLE          = 436,
+    EMOTE_STATE_SWIM_IDLE               = 437,
+    EMOTE_STATE_ATTACK_UNARMED          = 438,
+    EMOTE_ONESHOT_SPELL_CAST_W_SOUND    = 439,
+    EMOTE_ONESHOT_DODGE                 = 440,
+    EMOTE_ONESHOT_PARRY1H               = 441,
+    EMOTE_ONESHOT_PARRY2H               = 442,
+    EMOTE_ONESHOT_PARRY2HL              = 443,
+    EMOTE_STATE_FLYFALL                 = 444,
+    EMOTE_ONESHOT_FLYDEATH              = 445,
+    EMOTE_STATE_FLY_FALL                = 446,
+    EMOTE_ONESHOT_FLY_SIT_GROUND_DOWN   = 447,
+    EMOTE_ONESHOT_FLY_SIT_GROUND_UP     = 448,
+    EMOTE_ONESHOT_EMERGE                = 449,
+    EMOTE_ONESHOT_DRAGON_SPIT           = 450,
+    EMOTE_STATE_SPECIAL_UNARMED         = 451,
+    EMOTE_ONESHOT_FLYGRAB               = 452,
+    EMOTE_STATE_FLYGRABCLOSED           = 453,
+    EMOTE_ONESHOT_FLYGRABTHROWN         = 454,
+    EMOTE_STATE_FLY_SIT_GROUND          = 455,
+    EMOTE_STATE_WALK_BACKWARDS          = 456,
+    EMOTE_ONESHOT_FLYTALK               = 457,
+    EMOTE_ONESHOT_FLYATTACK1H           = 458,
+    EMOTE_STATE_CUSTOM_SPELL_08         = 459,
+    EMOTE_ONESHOT_FLY_DRAGON_SPIT       = 460,
+    EMOTE_STATE_SIT_CHAIR_LOW           = 461,
+    EMOTE_ONESHOT_STUN                  = 462,
+    EMOTE_ONESHOT_SPELL_CAST_OMNI       = 463,
+    EMOTE_STATE_READY_THROWN            = 465,
+    EMOTE_ONESHOT_WORK_CHOPWOOD         = 466,
+    EMOTE_ONESHOT_WORK_MINING           = 467,
+    EMOTE_STATE_SPELL_CHANNEL_OMNI      = 468,
+    EMOTE_STATE_SPELL_CHANNEL_DIRECTED  = 469,
+    EMOTE_STAND_STATE_NONE              = 470,
+    EMOTE_STATE_READYJOUST              = 471,
+    EMOTE_STATE_STRANGULATE             = 473,
+    EMOTE_STATE_READY_SPELL_OMNI        = 474,
+    EMOTE_STATE_HOLD_JOUST              = 475,
+    EMOTE_ONESHOT_CRY_JAINA             = 476
+};
+
+// AnimationData.dbc
 enum Anim
 {
-    ANIM_STAND                     = 0x0,
-    ANIM_DEATH                     = 0x1,
-    ANIM_SPELL                     = 0x2,
-    ANIM_STOP                      = 0x3,
-    ANIM_WALK                      = 0x4,
-    ANIM_RUN                       = 0x5,
-    ANIM_DEAD                      = 0x6,
-    ANIM_RISE                      = 0x7,
-    ANIM_STANDWOUND                = 0x8,
-    ANIM_COMBATWOUND               = 0x9,
-    ANIM_COMBATCRITICAL            = 0xA,
-    ANIM_SHUFFLE_LEFT              = 0xB,
-    ANIM_SHUFFLE_RIGHT             = 0xC,
-    ANIM_WALK_BACKWARDS            = 0xD,
-    ANIM_STUN                      = 0xE,
-    ANIM_HANDS_CLOSED              = 0xF,
-    ANIM_ATTACKUNARMED             = 0x10,
-    ANIM_ATTACK1H                  = 0x11,
-    ANIM_ATTACK2HTIGHT             = 0x12,
-    ANIM_ATTACK2HLOOSE             = 0x13,
-    ANIM_PARRYUNARMED              = 0x14,
-    ANIM_PARRY1H                   = 0x15,
-    ANIM_PARRY2HTIGHT              = 0x16,
-    ANIM_PARRY2HLOOSE              = 0x17,
-    ANIM_PARRYSHIELD               = 0x18,
-    ANIM_READYUNARMED              = 0x19,
-    ANIM_READY1H                   = 0x1A,
-    ANIM_READY2HTIGHT              = 0x1B,
-    ANIM_READY2HLOOSE              = 0x1C,
-    ANIM_READYBOW                  = 0x1D,
-    ANIM_DODGE                     = 0x1E,
-    ANIM_SPELLPRECAST              = 0x1F,
-    ANIM_SPELLCAST                 = 0x20,
-    ANIM_SPELLCASTAREA             = 0x21,
-    ANIM_NPCWELCOME                = 0x22,
-    ANIM_NPCGOODBYE                = 0x23,
-    ANIM_BLOCK                     = 0x24,
-    ANIM_JUMPSTART                 = 0x25,
-    ANIM_JUMP                      = 0x26,
-    ANIM_JUMPEND                   = 0x27,
-    ANIM_FALL                      = 0x28,
-    ANIM_SWIMIDLE                  = 0x29,
-    ANIM_SWIM                      = 0x2A,
-    ANIM_SWIM_LEFT                 = 0x2B,
-    ANIM_SWIM_RIGHT                = 0x2C,
-    ANIM_SWIM_BACKWARDS            = 0x2D,
-    ANIM_ATTACKBOW                 = 0x2E,
-    ANIM_FIREBOW                   = 0x2F,
-    ANIM_READYRIFLE                = 0x30,
-    ANIM_ATTACKRIFLE               = 0x31,
-    ANIM_LOOT                      = 0x32,
-    ANIM_SPELL_PRECAST_DIRECTED    = 0x33,
-    ANIM_SPELL_PRECAST_OMNI        = 0x34,
-    ANIM_SPELL_CAST_DIRECTED       = 0x35,
-    ANIM_SPELL_CAST_OMNI           = 0x36,
-    ANIM_SPELL_BATTLEROAR          = 0x37,
-    ANIM_SPELL_READYABILITY        = 0x38,
-    ANIM_SPELL_SPECIAL1H           = 0x39,
-    ANIM_SPELL_SPECIAL2H           = 0x3A,
-    ANIM_SPELL_SHIELDBASH          = 0x3B,
-    ANIM_EMOTE_TALK                = 0x3C,
-    ANIM_EMOTE_EAT                 = 0x3D,
-    ANIM_EMOTE_WORK                = 0x3E,
-    ANIM_EMOTE_USE_STANDING        = 0x3F,
-    ANIM_EMOTE_EXCLAMATION         = 0x40,
-    ANIM_EMOTE_QUESTION            = 0x41,
-    ANIM_EMOTE_BOW                 = 0x42,
-    ANIM_EMOTE_WAVE                = 0x43,
-    ANIM_EMOTE_CHEER               = 0x44,
-    ANIM_EMOTE_DANCE               = 0x45,
-    ANIM_EMOTE_LAUGH               = 0x46,
-    ANIM_EMOTE_SLEEP               = 0x47,
-    ANIM_EMOTE_SIT_GROUND          = 0x48,
-    ANIM_EMOTE_RUDE                = 0x49,
-    ANIM_EMOTE_ROAR                = 0x4A,
-    ANIM_EMOTE_KNEEL               = 0x4B,
-    ANIM_EMOTE_KISS                = 0x4C,
-    ANIM_EMOTE_CRY                 = 0x4D,
-    ANIM_EMOTE_CHICKEN             = 0x4E,
-    ANIM_EMOTE_BEG                 = 0x4F,
-    ANIM_EMOTE_APPLAUD             = 0x50,
-    ANIM_EMOTE_SHOUT               = 0x51,
-    ANIM_EMOTE_FLEX                = 0x52,
-    ANIM_EMOTE_SHY                 = 0x53,
-    ANIM_EMOTE_POINT               = 0x54,
-    ANIM_ATTACK1HPIERCE            = 0x55,
-    ANIM_ATTACK2HLOOSEPIERCE       = 0x56,
-    ANIM_ATTACKOFF                 = 0x57,
-    ANIM_ATTACKOFFPIERCE           = 0x58,
-    ANIM_SHEATHE                   = 0x59,
-    ANIM_HIPSHEATHE                = 0x5A,
-    ANIM_MOUNT                     = 0x5B,
-    ANIM_RUN_LEANRIGHT             = 0x5C,
-    ANIM_RUN_LEANLEFT              = 0x5D,
-    ANIM_MOUNT_SPECIAL             = 0x5E,
-    ANIM_KICK                      = 0x5F,
-    ANIM_SITDOWN                   = 0x60,
-    ANIM_SITTING                   = 0x61,
-    ANIM_SITUP                     = 0x62,
-    ANIM_SLEEPDOWN                 = 0x63,
-    ANIM_SLEEPING                  = 0x64,
-    ANIM_SLEEPUP                   = 0x65,
-    ANIM_SITCHAIRLOW               = 0x66,
-    ANIM_SITCHAIRMEDIUM            = 0x67,
-    ANIM_SITCHAIRHIGH              = 0x68,
-    ANIM_LOADBOW                   = 0x69,
-    ANIM_LOADRIFLE                 = 0x6A,
-    ANIM_ATTACKTHROWN              = 0x6B,
-    ANIM_READYTHROWN               = 0x6C,
-    ANIM_HOLDBOW                   = 0x6D,
-    ANIM_HOLDRIFLE                 = 0x6E,
-    ANIM_HOLDTHROWN                = 0x6F,
-    ANIM_LOADTHROWN                = 0x70,
-    ANIM_EMOTE_SALUTE              = 0x71,
-    ANIM_KNEELDOWN                 = 0x72,
-    ANIM_KNEELING                  = 0x73,
-    ANIM_KNEELUP                   = 0x74,
-    ANIM_ATTACKUNARMEDOFF          = 0x75,
-    ANIM_SPECIALUNARMED            = 0x76,
-    ANIM_STEALTHWALK               = 0x77,
-    ANIM_STEALTHSTAND              = 0x78,
-    ANIM_KNOCKDOWN                 = 0x79,
-    ANIM_EATING                    = 0x7A,
-    ANIM_USESTANDINGLOOP           = 0x7B,
-    ANIM_CHANNELCASTDIRECTED       = 0x7C,
-    ANIM_CHANNELCASTOMNI           = 0x7D,
-    ANIM_WHIRLWIND                 = 0x7E,
-    ANIM_BIRTH                     = 0x7F,
-    ANIM_USESTANDINGSTART          = 0x80,
-    ANIM_USESTANDINGEND            = 0x81,
-    ANIM_HOWL                      = 0x82,
-    ANIM_DROWN                     = 0x83,
-    ANIM_DROWNED                   = 0x84,
-    ANIM_FISHINGCAST               = 0x85,
-    ANIM_FISHINGLOOP               = 0x86,
-    ANIM_FLY                       = 0x87,
-    ANIM_EMOTE_WORK_NO_SHEATHE     = 0x88,
-    ANIM_EMOTE_STUN_NO_SHEATHE     = 0x89,
-    ANIM_EMOTE_USE_STANDING_NO_SHEATHE= 0x8A,
-    ANIM_SPELL_SLEEP_DOWN          = 0x8B,
-    ANIM_SPELL_KNEEL_START         = 0x8C,
-    ANIM_SPELL_KNEEL_LOOP          = 0x8D,
-    ANIM_SPELL_KNEEL_END           = 0x8E,
-    ANIM_SPRINT                    = 0x8F,
-    ANIM_IN_FIGHT                  = 0x90,
-
-    ANIM_GAMEOBJ_SPAWN             = 145,
-    ANIM_GAMEOBJ_CLOSE             = 146,
-    ANIM_GAMEOBJ_CLOSED            = 147,
-    ANIM_GAMEOBJ_OPEN              = 148,
-    ANIM_GAMEOBJ_OPENED            = 149,
-    ANIM_GAMEOBJ_DESTROY           = 150,
-    ANIM_GAMEOBJ_DESTROYED         = 151,
-    ANIM_GAMEOBJ_REBUILD           = 152,
-    ANIM_GAMEOBJ_CUSTOM0           = 153,
-    ANIM_GAMEOBJ_CUSTOM1           = 154,
-    ANIM_GAMEOBJ_CUSTOM2           = 155,
-    ANIM_GAMEOBJ_CUSTOM3           = 156,
-    ANIM_GAMEOBJ_DESPAWN           = 157,
-    ANIM_HOLD                      = 158,
-    ANIM_DECAY                     = 159,
-    ANIM_BOWPULL                   = 160,
-    ANIM_BOWRELEASE                = 161,
-    ANIM_SHIPSTART                 = 162,
-    ANIM_SHIPMOVEING               = 163,
-    ANIM_SHIPSTOP                  = 164,
-    ANIM_GROUPARROW                = 165,
-    ANIM_ARROW                     = 166,
-    ANIM_CORPSEARROW               = 167,
-    ANIM_GUIDEARROW                = 168,
-    ANIM_SWAY                      = 169,
-    ANIM_DRUIDCATPOUNCE            = 170,
-    ANIM_DRUIDCATRIP               = 171,
-    ANIM_DRUIDCATRAKE              = 172,
-    ANIM_DRUIDCATRAVAGE            = 173,
-    ANIM_DRUIDCATCLAW              = 174,
-    ANIM_DRUIDCATCOWER             = 175,
-    ANIM_DRUIDBEARSWIPE            = 176,
-    ANIM_DRUIDBEARBITE             = 177,
-    ANIM_DRUIDBEARMAUL             = 178,
-    ANIM_DRUIDBEARBASH             = 179,
-    ANIM_DRAGONTAIL                = 180,
-    ANIM_DRAGONSTOMP               = 181,
-    ANIM_DRAGONSPIT                = 182,
-    ANIM_DRAGONSPITHOVER           = 183,
-    ANIM_DRAGONSPITFLY             = 184,
-    ANIM_EMOTEYES                  = 185,
-    ANIM_EMOTENO                   = 186,
-    ANIM_JUMPLANDRUN               = 187,
-    ANIM_LOOTHOLD                  = 188,
-    ANIM_LOOTUP                    = 189,
-    ANIM_STANDHIGH                 = 190,
-    ANIM_IMPACT                    = 191,
-    ANIM_LIFTOFF                   = 192,
-    ANIM_HOVER                     = 193,
-    ANIM_SUCCUBUSENTICE            = 194,
-    ANIM_EMOTETRAIN                = 195,
-    ANIM_EMOTEDEAD                 = 196,
-    ANIM_EMOTEDANCEONCE            = 197,
-    ANIM_DEFLECT                   = 198,
-    ANIM_EMOTEEATNOSHEATHE         = 199,
-    ANIM_LAND                      = 200,
-    ANIM_SUBMERGE                  = 201,
-    ANIM_SUBMERGED                 = 202,
-    ANIM_CANNIBALIZE               = 203,
-    ANIM_ARROWBIRTH                = 204,
-    ANIM_GROURARROWBIRTH           = 205,
-    ANIM_CORPSEARROWBIRTH          = 206,
-    ANIM_GUIDEARROWBIRTH           = 207,
-    ANIM_EMOTETALKNOSHEATHE        = 208,
-    ANIM_EMOTEPOINTNOSHEATHE       = 209,
-    ANIM_EMOTESALUTENOSHEATHE      = 210,
-    ANIM_EMOTEDANCESPECIAL         = 211,
-    ANIM_MUTILATE                  = 212,
-    ANIM_CUSTOMSPELL01             = 213,
-    ANIM_CUSTOMSPELL02             = 214,
-    ANIM_CUSTOMSPELL03             = 215,
-    ANIM_CUSTOMSPELL04             = 216,
-    ANIM_CUSTOMSPELL05             = 217,
-    ANIM_CUSTOMSPELL06             = 218,
-    ANIM_CUSTOMSPELL07             = 219,
-    ANIM_CUSTOMSPELL08             = 220,
-    ANIM_CUSTOMSPELL09             = 221,
-    ANIM_CUSTOMSPELL10             = 222,
-    ANIM_StealthRun                = 223
+    ANIM_STAND                             = 0,
+    ANIM_DEATH                             = 1,
+    ANIM_SPELL                             = 2,
+    ANIM_STOP                              = 3,
+    ANIM_WALK                              = 4,
+    ANIM_RUN                               = 5,
+    ANIM_DEAD                              = 6,
+    ANIM_RISE                              = 7,
+    ANIM_STAND_WOUND                       = 8,
+    ANIM_COMBAT_WOUND                      = 9,
+    ANIM_COMBAT_CRITICAL                   = 10,
+    ANIM_SHUFFLE_LEFT                      = 11,
+    ANIM_SHUFFLE_RIGHT                     = 12,
+    ANIM_WALK_BACKWARDS                    = 13,
+    ANIM_STUN                              = 14,
+    ANIM_HANDS_CLOSED                      = 15,
+    ANIM_ATTACK_UNARMED                    = 16,
+    ANIM_ATTACK1H                          = 17,
+    ANIM_ATTACK2H                          = 18,
+    ANIM_ATTACK2HL                         = 19,
+    ANIM_PARRY_UNARMED                     = 20,
+    ANIM_PARRY1H                           = 21,
+    ANIM_PARRY2H                           = 22,
+    ANIM_PARRY2HL                          = 23,
+    ANIM_SHIELD_BLOCK                      = 24,
+    ANIM_READY_UNARMED                     = 25,
+    ANIM_READY1H                           = 26,
+    ANIM_READY2H                           = 27,
+    ANIM_READY2HL                          = 28,
+    ANIM_READY_BOW                         = 29,
+    ANIM_DODGE                             = 30,
+    ANIM_SPELL_PRECAST                     = 31,
+    ANIM_SPELL_CAST                        = 32,
+    ANIM_SPELL_CAST_AREA                   = 33,
+    ANIM_NPC_WELCOME                       = 34,
+    ANIM_NPC_GOODBYE                       = 35,
+    ANIM_BLOCK                             = 36,
+    ANIM_JUMP_START                        = 37,
+    ANIM_JUMP                              = 38,
+    ANIM_JUMP_END                          = 39,
+    ANIM_FALL                              = 40,
+    ANIM_SWIM_IDLE                         = 41,
+    ANIM_SWIM                              = 42,
+    ANIM_SWIM_LEFT                         = 43,
+    ANIM_SWIM_RIGHT                        = 44,
+    ANIM_SWIM_BACKWARDS                    = 45,
+    ANIM_ATTACK_BOW                        = 46,
+    ANIM_FIRE_BOW                          = 47,
+    ANIM_READY_RIFLE                       = 48,
+    ANIM_ATTACK_RIFLE                      = 49,
+    ANIM_LOOT                              = 50,
+    ANIM_READY_SPELL_DIRECTED              = 51,
+    ANIM_READY_SPELL_OMNI                  = 52,
+    ANIM_SPELL_CAST_DIRECTED               = 53,
+    ANIM_SPELL_CAST_OMNI                   = 54,
+    ANIM_BATTLE_ROAR                       = 55,
+    ANIM_READY_ABILITY                     = 56,
+    ANIM_SPECIAL1H                         = 57,
+    ANIM_SPECIAL2H                         = 58,
+    ANIM_SHIELD_BASH                       = 59,
+    ANIM_EMOTE_TALK                        = 60,
+    ANIM_EMOTE_EAT                         = 61,
+    ANIM_EMOTE_WORK                        = 62,
+    ANIM_EMOTE_USE_STANDING                = 63,
+    ANIM_EMOTE_TALK_EXCLAMATION            = 64,
+    ANIM_EMOTE_TALK_QUESTION               = 65,
+    ANIM_EMOTE_BOW                         = 66,
+    ANIM_EMOTE_WAVE                        = 67,
+    ANIM_EMOTE_CHEER                       = 68,
+    ANIM_EMOTE_DANCE                       = 69,
+    ANIM_EMOTE_LAUGH                       = 70,
+    ANIM_EMOTE_SLEEP                       = 71,
+    ANIM_EMOTE_SIT_GROUND                  = 72,
+    ANIM_EMOTE_RUDE                        = 73,
+    ANIM_EMOTE_ROAR                        = 74,
+    ANIM_EMOTE_KNEEL                       = 75,
+    ANIM_EMOTE_KISS                        = 76,
+    ANIM_EMOTE_CRY                         = 77,
+    ANIM_EMOTE_CHICKEN                     = 78,
+    ANIM_EMOTE_BEG                         = 79,
+    ANIM_EMOTE_APPLAUD                     = 80,
+    ANIM_EMOTE_SHOUT                       = 81,
+    ANIM_EMOTE_FLEX                        = 82,
+    ANIM_EMOTE_SHY                         = 83,
+    ANIM_EMOTE_POINT                       = 84,
+    ANIM_ATTACK1H_PIERCE                   = 85,
+    ANIM_ATTACK2H_LOOSE_PIERCE             = 86,
+    ANIM_ATTACK_OFF                        = 87,
+    ANIM_ATTACK_OFF_PIERCE                 = 88,
+    ANIM_SHEATHE                           = 89,
+    ANIM_HIP_SHEATHE                       = 90,
+    ANIM_MOUNT                             = 91,
+    ANIM_RUN_RIGHT                         = 92,
+    ANIM_RUN_LEFT                          = 93,
+    ANIM_MOUNT_SPECIAL                     = 94,
+    ANIM_KICK                              = 95,
+    ANIM_SIT_GROUND_DOWN                   = 96,
+    ANIM_SIT_GROUND                        = 97,
+    ANIM_SIT_GROUND_UP                     = 98,
+    ANIM_SLEEP_DOWN                        = 99,
+    ANIM_SLEEP                             = 100,
+    ANIM_SLEEP_UP                          = 101,
+    ANIM_SIT_CHAIR_LOW                     = 102,
+    ANIM_SIT_CHAIR_MED                     = 103,
+    ANIM_SIT_CHAIR_HIGH                    = 104,
+    ANIM_LOAD_BOW                          = 105,
+    ANIM_LOAD_RIFLE                        = 106,
+    ANIM_ATTACK_THROWN                     = 107,
+    ANIM_READY_THROWN                      = 108,
+    ANIM_HOLD_BOW                          = 109,
+    ANIM_HOLD_RIFLE                        = 110,
+    ANIM_HOLD_THROWN                       = 111,
+    ANIM_LOAD_THROWN                       = 112,
+    ANIM_EMOTE_SALUTE                      = 113,
+    ANIM_KNEEL_START                       = 114,
+    ANIM_KNEEL_LOOP                        = 115,
+    ANIM_KNEEL_END                         = 116,
+    ANIM_ATTACK_UNARMED_OFF                = 117,
+    ANIM_SPECIAL_UNARMED                   = 118,
+    ANIM_STEALTH_WALK                      = 119,
+    ANIM_STEALTH_STAND                     = 120,
+    ANIM_KNOCKDOWN                         = 121,
+    ANIM_EATING_LOOP                       = 122,
+    ANIM_USE_STANDING_LOOP                 = 123,
+    ANIM_CHANNEL_CAST_DIRECTED             = 124,
+    ANIM_CHANNEL_CAST_OMNI                 = 125,
+    ANIM_WHIRLWIND                         = 126,
+    ANIM_BIRTH                             = 127,
+    ANIM_USE_STANDING_START                = 128,
+    ANIM_USE_STANDING_END                  = 129,
+    ANIM_CREATURE_SPECIAL                  = 130,
+    ANIM_DROWN                             = 131,
+    ANIM_DROWNED                           = 132,
+    ANIM_FISHING_CAST                      = 133,
+    ANIM_FISHING_LOOP                      = 134,
+    ANIM_FLY                               = 135,
+    ANIM_EMOTE_WORK_NO_SHEATHE             = 136,
+    ANIM_EMOTE_STUN_NO_SHEATHE             = 137,
+    ANIM_EMOTE_USE_STANDING_NO_SHEATHE     = 138,
+    ANIM_SPELL_SLEEP_DOWN                  = 139,
+    ANIM_SPELL_KNEEL_START                 = 140,
+    ANIM_SPELL_KNEEL_LOOP                  = 141,
+    ANIM_SPELL_KNEEL_END                   = 142,
+    ANIM_SPRINT                            = 143,
+    ANIM_IN_FIGHT                          = 144,
+    ANIM_SPAWN                             = 145,
+    ANIM_CLOSE                             = 146,
+    ANIM_CLOSED                            = 147,
+    ANIM_OPEN                              = 148,
+    ANIM_OPENED                            = 149,
+    ANIM_DESTROY                           = 150,
+    ANIM_DESTROYED                         = 151,
+    ANIM_REBUILD                           = 152,
+    ANIM_CUSTOM_0                          = 153,
+    ANIM_CUSTOM_1                          = 154,
+    ANIM_CUSTOM_2                          = 155,
+    ANIM_CUSTOM_3                          = 156,
+    ANIM_DESPAWN                           = 157,
+    ANIM_HOLD                              = 158,
+    ANIM_DECAY                             = 159,
+    ANIM_BOW_PULL                          = 160,
+    ANIM_BOW_RELEASE                       = 161,
+    ANIM_SHIP_START                        = 162,
+    ANIM_SHIP_MOVING                       = 163,
+    ANIM_SHIP_STOP                         = 164,
+    ANIM_GROUP_ARROW                       = 165,
+    ANIM_ARROW                             = 166,
+    ANIM_CORPSE_ARROW                      = 167,
+    ANIM_GUIDE_ARROW                       = 168,
+    ANIM_SWAY                              = 169,
+    ANIM_DRUID_CAT_POUNCE                  = 170,
+    ANIM_DRUID_CAT_RIP                     = 171,
+    ANIM_DRUID_CAT_RAKE                    = 172,
+    ANIM_DRUID_CAT_RAVAGE                  = 173,
+    ANIM_DRUID_CAT_CLAW                    = 174,
+    ANIM_DRUID_CAT_COWER                   = 175,
+    ANIM_DRUID_BEAR_SWIPE                  = 176,
+    ANIM_DRUID_BEAR_BITE                   = 177,
+    ANIM_DRUID_BEAR_MAUL                   = 178,
+    ANIM_DRUID_BEAR_BASH                   = 179,
+    ANIM_DRAGON_TAIL                       = 180,
+    ANIM_DRAGON_STOMP                      = 181,
+    ANIM_DRAGON_SPIT                       = 182,
+    ANIM_DRAGON_SPIT_HOVER                 = 183,
+    ANIM_DRAGON_SPIT_FLY                   = 184,
+    ANIM_EMOTE_YES                         = 185,
+    ANIM_EMOTE_NO                          = 186,
+    ANIM_JUMP_LAND_RUN                     = 187,
+    ANIM_LOOT_HOLD                         = 188,
+    ANIM_LOOT_UP                           = 189,
+    ANIM_STAND_HIGH                        = 190,
+    ANIM_IMPACT                            = 191,
+    ANIM_LIFTOFF                           = 192,
+    ANIM_HOVER                             = 193,
+    ANIM_SUCCUBUS_ENTICE                   = 194,
+    ANIM_EMOTE_TRAIN                       = 195,
+    ANIM_EMOTE_DEAD                        = 196,
+    ANIM_EMOTE_DANCE_ONCE                  = 197,
+    ANIM_DEFLECT                           = 198,
+    ANIM_EMOTE_EAT_NO_SHEATHE              = 199,
+    ANIM_LAND                              = 200,
+    ANIM_SUBMERGE                          = 201,
+    ANIM_SUBMERGED                         = 202,
+    ANIM_CANNIBALIZE                       = 203,
+    ANIM_ARROW_BIRTH                       = 204,
+    ANIM_GROUP_ARROW_BIRTH                 = 205,
+    ANIM_CORPSE_ARROW_BIRTH                = 206,
+    ANIM_GUIDE_ARROW_BIRTH                 = 207,
+    ANIM_EMOTE_TALK_NO_SHEATHE             = 208,
+    ANIM_EMOTE_POINT_NO_SHEATHE            = 209,
+    ANIM_EMOTE_SALUTE_NO_SHEATHE           = 210,
+    ANIM_EMOTE_DANCE_SPECIAL               = 211,
+    ANIM_MUTILATE                          = 212,
+    ANIM_CUSTOM_SPELL_01                   = 213,
+    ANIM_CUSTOM_SPELL_02                   = 214,
+    ANIM_CUSTOM_SPELL_03                   = 215,
+    ANIM_CUSTOM_SPELL_04                   = 216,
+    ANIM_CUSTOM_SPELL_05                   = 217,
+    ANIM_CUSTOM_SPELL_06                   = 218,
+    ANIM_CUSTOM_SPELL_07                   = 219,
+    ANIM_CUSTOM_SPELL_08                   = 220,
+    ANIM_CUSTOM_SPELL_09                   = 221,
+    ANIM_CUSTOM_SPELL_10                   = 222,
+    ANIM_STEALTH_RUN                       = 223,
+    ANIM_EMERGE                            = 224,
+    ANIM_COWER                             = 225,
+    ANIM_GRAB                              = 226,
+    ANIM_GRAB_CLOSED                       = 227,
+    ANIM_GRAB_THROWN                       = 228,
+    ANIM_FLY_STAND                         = 229,
+    ANIM_FLY_DEATH                         = 230,
+    ANIM_FLY_SPELL                         = 231,
+    ANIM_FLY_STOP                          = 232,
+    ANIM_FLY_WALK                          = 233,
+    ANIM_FLY_RUN                           = 234,
+    ANIM_FLY_DEAD                          = 235,
+    ANIM_FLY_RISE                          = 236,
+    ANIM_FLY_STAND_WOUND                   = 237,
+    ANIM_FLY_COMBAT_WOUND                  = 238,
+    ANIM_FLY_COMBAT_CRITICAL               = 239,
+    ANIM_FLY_SHUFFLE_LEFT                  = 240,
+    ANIM_FLY_SHUFFLE_RIGHT                 = 241,
+    ANIM_FLY_WALK_BACKWARDS                = 242,
+    ANIM_FLY_STUN                          = 243,
+    ANIM_FLY_HANDS_CLOSED                  = 244,
+    ANIM_FLY_ATTACK_UNARMED                = 245,
+    ANIM_FLY_ATTACK1H                      = 246,
+    ANIM_FLY_ATTACK2H                      = 247,
+    ANIM_FLY_ATTACK2HL                     = 248,
+    ANIM_FLY_PARRY_UNARMED                 = 249,
+    ANIM_FLY_PARRY1H                       = 250,
+    ANIM_FLY_PARRY2H                       = 251,
+    ANIM_FLY_PARRY2HL                      = 252,
+    ANIM_FLY_SHIELD_BLOCK                  = 253,
+    ANIM_FLY_READY_UNARMED                 = 254,
+    ANIM_FLY_READY1H                       = 255,
+    ANIM_FLY_READY2H                       = 256,
+    ANIM_FLY_READY2HL                      = 257,
+    ANIM_FLY_READY_BOW                     = 258,
+    ANIM_FLY_DODGE                         = 259,
+    ANIM_FLY_SPELL_PRECAST                 = 260,
+    ANIM_FLY_SPELL_CAST                    = 261,
+    ANIM_FLY_SPELL_CAST_AREA               = 262,
+    ANIM_FLY_NPC_WELCOME                   = 263,
+    ANIM_FLY_NPC_GOODBYE                   = 264,
+    ANIM_FLY_BLOCK                         = 265,
+    ANIM_FLY_JUMP_START                    = 266,
+    ANIM_FLY_JUMP                          = 267,
+    ANIM_FLY_JUMP_END                      = 268,
+    ANIM_FLY_FALL                          = 269,
+    ANIM_FLY_SWIM_IDLE                     = 270,
+    ANIM_FLY_SWIM                          = 271,
+    ANIM_FLY_SWIM_LEFT                     = 272,
+    ANIM_FLY_SWIM_RIGHT                    = 273,
+    ANIM_FLY_SWIM_BACKWARDS                = 274,
+    ANIM_FLY_ATTACK_BOW                    = 275,
+    ANIM_FLY_FIRE_BOW                      = 276,
+    ANIM_FLY_READY_RIFLE                   = 277,
+    ANIM_FLY_ATTACK_RIFLE                  = 278,
+    ANIM_FLY_LOOT                          = 279,
+    ANIM_FLY_READY_SPELL_DIRECTED          = 280,
+    ANIM_FLY_READY_SPELL_OMNI              = 281,
+    ANIM_FLY_SPELL_CAST_DIRECTED           = 282,
+    ANIM_FLY_SPELL_CAST_OMNI               = 283,
+    ANIM_FLY_SPELL_BATTLE_ROAR             = 284,
+    ANIM_FLY_READY_ABILITY                 = 285,
+    ANIM_FLY_SPECIAL1H                     = 286,
+    ANIM_FLY_SPECIAL2H                     = 287,
+    ANIM_FLY_SHIELD_BASH                   = 288,
+    ANIM_FLY_EMOTE_TALK                    = 289,
+    ANIM_FLY_EMOTE_EAT                     = 290,
+    ANIM_FLY_EMOTE_WORK                    = 291,
+    ANIM_FLY_USE_STANDING                  = 292,
+    ANIM_FLY_EMOTE_TALK_EXCLAMATION        = 293,
+    ANIM_FLY_EMOTE_TALK_QUESTION           = 294,
+    ANIM_FLY_EMOTE_BOW                     = 295,
+    ANIM_FLY_EMOTE_WAVE                    = 296,
+    ANIM_FLY_EMOTE_CHEER                   = 297,
+    ANIM_FLY_EMOTE_DANCE                   = 298,
+    ANIM_FLY_EMOTE_LAUGH                   = 299,
+    ANIM_FLY_EMOTE_SLEEP                   = 300,
+    ANIM_FLY_EMOTE_SIT_GROUND              = 301,
+    ANIM_FLY_EMOTE_RUDE                    = 302,
+    ANIM_FLY_EMOTE_ROAR                    = 303,
+    ANIM_FLY_EMOTE_KNEEL                   = 304,
+    ANIM_FLY_EMOTE_KISS                    = 305,
+    ANIM_FLY_EMOTE_CRY                     = 306,
+    ANIM_FLY_EMOTE_CHICKEN                 = 307,
+    ANIM_FLY_EMOTE_BEG                     = 308,
+    ANIM_FLY_EMOTE_APPLAUD                 = 309,
+    ANIM_FLY_EMOTE_SHOUT                   = 310,
+    ANIM_FLY_EMOTE_FLEX                    = 311,
+    ANIM_FLY_EMOTE_SHY                     = 312,
+    ANIM_FLY_EMOTE_POINT                   = 313,
+    ANIM_FLY_ATTACK1H_PIERCE               = 314,
+    ANIM_FLY_ATTACK2H_LOOSE_PIERCE         = 315,
+    ANIM_FLY_ATTACK_OFF                    = 316,
+    ANIM_FLY_ATTACK_OFF_PIERCE             = 317,
+    ANIM_FLY_SHEATH                        = 318,
+    ANIM_FLY_HIP_SHEATH                    = 319,
+    ANIM_FLY_MOUNT                         = 320,
+    ANIM_FLY_RUN_RIGHT                     = 321,
+    ANIM_FLY_RUN_LEFT                      = 322,
+    ANIM_FLY_MOUNT_SPECIAL                 = 323,
+    ANIM_FLY_KICK                          = 324,
+    ANIM_FLY_SIT_GROUND_DOWN               = 325,
+    ANIM_FLY_SIT_GROUND                    = 326,
+    ANIM_FLY_SIT_GROUND_UP                 = 327,
+    ANIM_FLY_SLEEP_DOWN                    = 328,
+    ANIM_FLY_SLEEP                         = 329,
+    ANIM_FLY_SLEEP_UP                      = 330,
+    ANIM_FLY_SIT_CHAIR_LOW                 = 331,
+    ANIM_FLY_SIT_CHAIR_MED                 = 332,
+    ANIM_FLY_SIT_CHAIR_HIGH                = 333,
+    ANIM_FLY_LOAD_BOW                      = 334,
+    ANIM_FLY_LOAD_RIFLE                    = 335,
+    ANIM_FLY_ATTACK_THROWN                 = 336,
+    ANIM_FLY_READY_THROWN                  = 337,
+    ANIM_FLY_HOLD_BOW                      = 338,
+    ANIM_FLY_HOLD_RIFLE                    = 339,
+    ANIM_FLY_HOLD_THROWN                   = 340,
+    ANIM_FLY_LOAD_THROWN                   = 341,
+    ANIM_FLY_EMOTE_SALUTE                  = 342,
+    ANIM_FLY_KNEEL_START                   = 343,
+    ANIM_FLY_KNEEL_LOOP                    = 344,
+    ANIM_FLY_KNEEL_END                     = 345,
+    ANIM_FLY_ATTACK_UNARMED_OFF            = 346,
+    ANIM_FLY_SPECIAL_UNARMED               = 347,
+    ANIM_FLY_STEALTH_WALK                  = 348,
+    ANIM_FLY_STEALTH_STAND                 = 349,
+    ANIM_FLY_KNOCKDOWN                     = 350,
+    ANIM_FLY_EATING_LOOP                   = 351,
+    ANIM_FLY_USE_STANDING_LOOP             = 352,
+    ANIM_FLY_CHANNEL_CAST_DIRECTED         = 353,
+    ANIM_FLY_CHANNEL_CAST_OMNI             = 354,
+    ANIM_FLY_WHIRLWIND                     = 355,
+    ANIM_FLY_BIRTH                         = 356,
+    ANIM_FLY_USE_STANDING_START            = 357,
+    ANIM_FLY_USE_STANDING_END              = 358,
+    ANIM_FLY_CREATURE_SPECIAL              = 359,
+    ANIM_FLY_DROWN                         = 360,
+    ANIM_FLY_DROWNED                       = 361,
+    ANIM_FLY_FISHING_CAST                  = 362,
+    ANIM_FLY_FISHING_LOOP                  = 363,
+    ANIM_FLY_FLY                           = 364,
+    ANIM_FLY_EMOTE_WORK_NO_SHEATHE         = 365,
+    ANIM_FLY_EMOTE_STUN_NO_SHEATHE         = 366,
+    ANIM_FLY_EMOTE_USE_STANDING_NO_SHEATHE = 367,
+    ANIM_FLY_SPELL_SLEEP_DOWN              = 368,
+    ANIM_FLY_SPELL_KNEEL_START             = 369,
+    ANIM_FLY_SPELL_KNEEL_LOOP              = 370,
+    ANIM_FLY_SPELL_KNEEL_END               = 371,
+    ANIM_FLY_SPRINT                        = 372,
+    ANIM_FLY_IN_FLIGHT                     = 373,
+    ANIM_FLY_SPAWN                         = 374,
+    ANIM_FLY_CLOSE                         = 375,
+    ANIM_FLY_CLOSED                        = 376,
+    ANIM_FLY_OPEN                          = 377,
+    ANIM_FLY_OPENED                        = 378,
+    ANIM_FLY_DESTROY                       = 379,
+    ANIM_FLY_DESTROYED                     = 380,
+    ANIM_FLY_REBUILD                       = 381,
+    ANIM_FLY_CUSTOM_0                      = 382,
+    ANIM_FLY_CUSTOM_1                      = 383,
+    ANIM_FLY_CUSTOM_2                      = 384,
+    ANIM_FLY_CUSTOM_3                      = 385,
+    ANIM_FLY_DESPAWN                       = 386,
+    ANIM_FLY_HOLD                          = 387,
+    ANIM_FLY_DECAY                         = 388,
+    ANIM_FLY_BOW_PULL                      = 389,
+    ANIM_FLY_BOW_RELEASE                   = 390,
+    ANIM_FLY_SHIP_START                    = 391,
+    ANIM_FLY_SHIP_MOVING                   = 392,
+    ANIM_FLY_SHIP_STOP                     = 393,
+    ANIM_FLY_GROUP_ARROW                   = 394,
+    ANIM_FLY_ARROW                         = 395,
+    ANIM_FLY_CORPSE_ARROW                  = 396,
+    ANIM_FLY_GUIDE_ARROW                   = 397,
+    ANIM_FLY_SWAY                          = 398,
+    ANIM_FLY_DRUID_CAT_POUNCE              = 399,
+    ANIM_FLY_DRUID_CAT_RIP                 = 400,
+    ANIM_FLY_DRUID_CAT_RAKE                = 401,
+    ANIM_FLY_DRUID_CAT_RAVAGE              = 402,
+    ANIM_FLY_DRUID_CAT_CLAW                = 403,
+    ANIM_FLY_DRUID_CAT_COWER               = 404,
+    ANIM_FLY_DRUID_BEAR_SWIPE              = 405,
+    ANIM_FLY_DRUID_BEAR_BITE               = 406,
+    ANIM_FLY_DRUID_BEAR_MAUL               = 407,
+    ANIM_FLY_DRUID_BEAR_BASH               = 408,
+    ANIM_FLY_DRAGON_TAIL                   = 409,
+    ANIM_FLY_DRAGON_STOMP                  = 410,
+    ANIM_FLY_DRAGON_SPIT                   = 411,
+    ANIM_FLY_DRAGON_SPIT_HOVER             = 412,
+    ANIM_FLY_DRAGON_SPIT_FLY               = 413,
+    ANIM_FLY_EMOTE_YES                     = 414,
+    ANIM_FLY_EMOTE_NO                      = 415,
+    ANIM_FLY_JUMP_LAND_RUN                 = 416,
+    ANIM_FLY_LOOT_HOLD                     = 417,
+    ANIM_FLY_LOOT_UP                       = 418,
+    ANIM_FLY_STAND_HIGH                    = 419,
+    ANIM_FLY_IMPACT                        = 420,
+    ANIM_FLY_LIFTOFF                       = 421,
+    ANIM_FLY_HOVER                         = 422,
+    ANIM_FLY_SUCCUBUS_ENTICE               = 423,
+    ANIM_FLY_EMOTE_TRAIN                   = 424,
+    ANIM_FLY_EMOTE_DEAD                    = 425,
+    ANIM_FLY_EMOTE_DANCE_ONCE              = 426,
+    ANIM_FLY_DEFLECT                       = 427,
+    ANIM_FLY_EMOTE_EAT_NO_SHEATHE          = 428,
+    ANIM_FLY_LAND                          = 429,
+    ANIM_FLY_SUBMERGE                      = 430,
+    ANIM_FLY_SUBMERGED                     = 431,
+    ANIM_FLY_CANNIBALIZE                   = 432,
+    ANIM_FLY_ARROW_BIRTH                   = 433,
+    ANIM_FLY_GROUP_ARROW_BIRTH             = 434,
+    ANIM_FLY_CORPSE_ARROW_BIRTH            = 435,
+    ANIM_FLY_GUIDE_ARROW_BIRTH             = 436,
+    ANIM_FLY_EMOTE_TALK_NO_SHEATHE         = 437,
+    ANIM_FLY_EMOTE_POINT_NO_SHEATHE        = 438,
+    ANIM_FLY_EMOTE_SALUTE_NO_SHEATHE       = 439,
+    ANIM_FLY_EMOTE_DANCE_SPECIAL           = 440,
+    ANIM_FLY_MUTILATE                      = 441,
+    ANIM_FLY_CUSTOM_SPELL_01               = 442,
+    ANIM_FLY_CUSTOM_SPELL_02               = 443,
+    ANIM_FLY_CUSTOM_SPELL_03               = 444,
+    ANIM_FLY_CUSTOM_SPELL_04               = 445,
+    ANIM_FLY_CUSTOM_SPELL_05               = 446,
+    ANIM_FLY_CUSTOM_SPELL_06               = 447,
+    ANIM_FLY_CUSTOM_SPELL_07               = 448,
+    ANIM_FLY_CUSTOM_SPELL_08               = 449,
+    ANIM_FLY_CUSTOM_SPELL_09               = 450,
+    ANIM_FLY_CUSTOM_SPELL_10               = 451,
+    ANIM_FLY_STEALTH_RUN                   = 452,
+    ANIM_FLY_EMERGE                        = 453,
+    ANIM_FLY_COWER                         = 454,
+    ANIM_FLY_GRAB                          = 455,
+    ANIM_FLY_GRAB_CLOSED                   = 456,
+    ANIM_FLY_GRAB_THROWN                   = 457,
+    ANIM_TO_FLY                            = 458,
+    ANIM_TO_HOVER                          = 459,
+    ANIM_TO_GROUND                         = 460,
+    ANIM_FLY_TO_FLY                        = 461,
+    ANIM_FLY_TO_HOVER                      = 462,
+    ANIM_FLY_TO_GROUND                     = 463,
+    ANIM_SETTLE                            = 464,
+    ANIM_FLY_SETTLE                        = 465,
+    ANIM_DEATH_START                       = 466,
+    ANIM_DEATH_LOOP                        = 467,
+    ANIM_DEATH_END                         = 468,
+    ANIM_FLY_DEATH_START                   = 469,
+    ANIM_FLY_DEATH_LOOP                    = 470,
+    ANIM_FLY_DEATH_END                     = 471,
+    ANIM_DEATH_END_HOLD                    = 472,
+    ANIM_FLY_DEATH_END_HOLD                = 473,
+    ANIM_STRANGULATE                       = 474,
+    ANIM_FLY_STRANGULATE                   = 475,
+    ANIM_READY_JOUST                       = 476,
+    ANIM_LOAD_JOUST                        = 477,
+    ANIM_HOLD_JOUST                        = 478,
+    ANIM_FLY_READY_JOUST                   = 479,
+    ANIM_FLY_LOAD_JOUST                    = 480,
+    ANIM_FLY_HOLD_JOUST                    = 481,
+    ANIM_ATTACK_JOUST                      = 482,
+    ANIM_FLY_ATTACK_JOUST                  = 483,
+    ANIM_RECLINED_MOUNT                    = 484,
+    ANIM_FLY_RECLINED_MOUNT                = 485,
+    ANIM_TO_ALTERED                        = 486,
+    ANIM_FROM_ALTERED                      = 487,
+    ANIM_FLY_TO_ALTERED                    = 488,
+    ANIM_FLY_FROM_ALTERED                  = 489,
+    ANIM_IN_STOCKS                         = 490,
+    ANIM_FLY_IN_STOCKS                     = 491,
+    ANIM_VEHICLE_GRAB                      = 492,
+    ANIM_VEHICLE_THROW                     = 493,
+    ANIM_FLY_VEHICLE_GRAB                  = 494,
+    ANIM_FLY_VEHICLE_THROW                 = 495,
+    ANIM_TO_ALTERED_POST_SWAP              = 496,
+    ANIM_FROM_ALTERED_POST_SWAP            = 497,
+    ANIM_FLY_TO_ALTERED_POST_SWAP          = 498,
+    ANIM_FLY_FROM_ALTERED_POST_SWAP        = 499,
+    ANIM_RECLINED_MOUNT_PASSENGER          = 500,
+    ANIM_FLY_RECLINED_MOUNT_PASSENGER      = 501,
+    ANIM_CARRY2H                           = 502,
+    ANIM_CARRIED2H                         = 503,
+    ANIM_FLY_CARRY2H                       = 504,
+    ANIM_FLY_CARRIED2H                     = 505
 };
 
 enum LockKeyType
@@ -2463,8 +2760,8 @@ enum SkillType
     SKILL_SURVIVAL2                = 142,
     SKILL_RIDING_HORSE             = 148,
     SKILL_RIDING_WOLF              = 149,
-    SKILL_RIDING_RAM               = 152,
     SKILL_RIDING_TIGER             = 150,
+    SKILL_RIDING_RAM               = 152,
     SKILL_SWIMING                  = 155,
     SKILL_2H_MACES                 = 160,
     SKILL_UNARMED                  = 162,
diff --git a/src/server/game/Movement/MotionMaster.cpp b/src/server/game/Movement/MotionMaster.cpp
index adb7b5c..4945ae2 100755
--- a/src/server/game/Movement/MotionMaster.cpp
+++ b/src/server/game/Movement/MotionMaster.cpp
@@ -80,7 +80,7 @@ void MotionMaster::UpdateMotion(uint32 diff)
     if (!i_owner)
         return;
 
-    if (i_owner->HasUnitState(UNIT_STAT_ROOT | UNIT_STAT_STUNNED)) // what about UNIT_STAT_DISTRACTED? Why is this not included?
+    if (i_owner->HasUnitState(UNIT_STATE_ROOT | UNIT_STATE_STUNNED)) // what about UNIT_STATE_DISTRACTED? Why is this not included?
         return;
 
     ASSERT(!empty());
@@ -237,7 +237,7 @@ void MotionMaster::MoveChase(Unit* target, float dist, float angle)
     if (!target || target == i_owner || i_owner->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE))
         return;
 
-    //i_owner->ClearUnitState(UNIT_STAT_FOLLOW);
+    //i_owner->ClearUnitState(UNIT_STATE_FOLLOW);
     if (i_owner->GetTypeId() == TYPEID_PLAYER)
     {
         sLog->outStaticDebug("Player (GUID: %u) chase to %s (GUID: %u)",
@@ -262,7 +262,7 @@ void MotionMaster::MoveFollow(Unit* target, float dist, float angle, MovementSlo
     if (!target || target == i_owner || i_owner->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE))
         return;
 
-    //i_owner->AddUnitState(UNIT_STAT_FOLLOW);
+    //i_owner->AddUnitState(UNIT_STATE_FOLLOW);
     if (i_owner->GetTypeId() == TYPEID_PLAYER)
     {
         sLog->outStaticDebug("Player (GUID: %u) follow to %s (GUID: %u)", i_owner->GetGUIDLow(),
@@ -374,7 +374,7 @@ void MotionMaster::MoveJump(float x, float y, float z, float speedXY, float spee
 void MotionMaster::MoveFall(uint32 id/*=0*/)
 {
     // use larger distance for vmap height search than in most other cases
-    float tz = i_owner->GetMap()->GetHeight(i_owner->GetPhaseMask(), i_owner->GetPositionX(), i_owner->GetPositionY(), i_owner->GetPositionZ(), true, MAX_FALL_DISTANCE);
+    float tz = i_owner->GetMap()->GetHeight(i_owner->GetPositionX(), i_owner->GetPositionY(), i_owner->GetPositionZ(), true, MAX_FALL_DISTANCE);
     if (tz <= INVALID_HEIGHT)
     {
         sLog->outStaticDebug("MotionMaster::MoveFall: unable retrive a proper height at map %u (x: %f, y: %f, z: %f).",
@@ -387,7 +387,7 @@ void MotionMaster::MoveFall(uint32 id/*=0*/)
         return;
 
     Movement::MoveSplineInit init(*i_owner);
-    init.MoveTo(i_owner->GetPositionX(), i_owner->GetPositionY(), tz);
+    init.MoveTo(i_owner->GetPositionX(),i_owner->GetPositionY(),tz);
     init.SetFall();
     init.Launch();
     Mutate(new EffectMovementGenerator(id), MOTION_SLOT_CONTROLLED);
diff --git a/src/server/game/Movement/MovementGenerators/ConfusedMovementGenerator.cpp b/src/server/game/Movement/MovementGenerators/ConfusedMovementGenerator.cpp
index 94608d8..32b9600 100755
--- a/src/server/game/Movement/MovementGenerators/ConfusedMovementGenerator.cpp
+++ b/src/server/game/Movement/MovementGenerators/ConfusedMovementGenerator.cpp
@@ -71,7 +71,7 @@ void ConfusedMovementGenerator<T>::Initialize(T &unit)
 
     unit.StopMoving();
     unit.SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_CONFUSED);
-    unit.AddUnitState(UNIT_STAT_CONFUSED|UNIT_STAT_CONFUSED_MOVE);
+    unit.AddUnitState(UNIT_STATE_CONFUSED|UNIT_STATE_CONFUSED_MOVE);
 }
 
 template<>
@@ -94,19 +94,19 @@ void ConfusedMovementGenerator<T>::Reset(T &unit)
     i_nextMove = 1;
     i_nextMoveTime.Reset(0);
     unit.StopMoving();
-    unit.AddUnitState(UNIT_STAT_CONFUSED|UNIT_STAT_CONFUSED_MOVE);
+    unit.AddUnitState(UNIT_STATE_CONFUSED|UNIT_STATE_CONFUSED_MOVE);
 }
 
 template<class T>
 bool ConfusedMovementGenerator<T>::Update(T &unit, const uint32 &diff)
 {
-    if (unit.HasUnitState(UNIT_STAT_ROOT | UNIT_STAT_STUNNED | UNIT_STAT_DISTRACTED))
+    if (unit.HasUnitState(UNIT_STATE_ROOT | UNIT_STATE_STUNNED | UNIT_STATE_DISTRACTED))
         return true;
 
     if (i_nextMoveTime.Passed())
     {
         // currently moving, update location
-        unit.AddUnitState(UNIT_STAT_CONFUSED_MOVE);
+        unit.AddUnitState(UNIT_STATE_CONFUSED_MOVE);
 
         if (unit.movespline->Finalized())
         {
@@ -121,7 +121,7 @@ bool ConfusedMovementGenerator<T>::Update(T &unit, const uint32 &diff)
         if(i_nextMoveTime.Passed() )
         {
             // start moving
-            unit.AddUnitState(UNIT_STAT_CONFUSED_MOVE);
+            unit.AddUnitState(UNIT_STATE_CONFUSED_MOVE);
 
             ASSERT( i_nextMove <= MAX_CONF_WAYPOINTS );
             float x = i_waypoints[i_nextMove][0];
@@ -141,14 +141,14 @@ template<>
 void ConfusedMovementGenerator<Player>::Finalize(Player &unit)
 {
     unit.RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_CONFUSED);
-    unit.ClearUnitState(UNIT_STAT_CONFUSED|UNIT_STAT_CONFUSED_MOVE);
+    unit.ClearUnitState(UNIT_STATE_CONFUSED|UNIT_STATE_CONFUSED_MOVE);
 }
 
 template<>
 void ConfusedMovementGenerator<Creature>::Finalize(Creature &unit)
 {
     unit.RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_CONFUSED);
-    unit.ClearUnitState(UNIT_STAT_CONFUSED|UNIT_STAT_CONFUSED_MOVE);
+    unit.ClearUnitState(UNIT_STATE_CONFUSED|UNIT_STATE_CONFUSED_MOVE);
     if (unit.getVictim())
         unit.SetTarget(unit.getVictim()->GetGUID());
 }
diff --git a/src/server/game/Movement/MovementGenerators/FleeingMovementGenerator.cpp b/src/server/game/Movement/MovementGenerators/FleeingMovementGenerator.cpp
index 1a628ae..ed5b73d 100755
--- a/src/server/game/Movement/MovementGenerators/FleeingMovementGenerator.cpp
+++ b/src/server/game/Movement/MovementGenerators/FleeingMovementGenerator.cpp
@@ -34,7 +34,7 @@ FleeingMovementGenerator<T>::_setTargetLocation(T &owner)
     if (!&owner)
         return;
 
-    if (owner.HasUnitState(UNIT_STAT_ROOT | UNIT_STAT_STUNNED))
+    if (owner.HasUnitState(UNIT_STATE_ROOT | UNIT_STATE_STUNNED))
         return;
 
     if (!_setMoveData(owner))
@@ -44,7 +44,7 @@ FleeingMovementGenerator<T>::_setTargetLocation(T &owner)
     if (!_getPoint(owner, x, y, z))
         return;
 
-    owner.AddUnitState(UNIT_STAT_FLEEING_MOVE);
+    owner.AddUnitState(UNIT_STATE_FLEEING_MOVE);
 
     Movement::MoveSplineInit init(owner);
     init.MoveTo(x,y,z);
@@ -157,7 +157,7 @@ FleeingMovementGenerator<T>::_getPoint(T &owner, float &x, float &y, float &z)
                 y = temp_y;
                 return true;
             }
-            float new_z = _map->GetHeight(owner.GetPhaseMask(), temp_x, temp_y, z, true);
+            float new_z = _map->GetHeight(temp_x, temp_y, z, true);
 
             if (new_z <= INVALID_HEIGHT)
                 continue;
@@ -169,8 +169,8 @@ FleeingMovementGenerator<T>::_getPoint(T &owner, float &x, float &y, float &z)
 
             if (!(new_z - z) || distance / fabs(new_z - z) > 1.0f)
             {
-                float new_z_left = _map->GetHeight(owner.GetPhaseMask(), temp_x + 1.0f*cos(angle+static_cast<float>(M_PI/2)),temp_y + 1.0f*sin(angle+static_cast<float>(M_PI/2)),z,true);
-                float new_z_right = _map->GetHeight(owner.GetPhaseMask(), temp_x + 1.0f*cos(angle-static_cast<float>(M_PI/2)),temp_y + 1.0f*sin(angle-static_cast<float>(M_PI/2)),z,true);
+                float new_z_left = _map->GetHeight(temp_x + 1.0f*cos(angle+static_cast<float>(M_PI/2)),temp_y + 1.0f*sin(angle+static_cast<float>(M_PI/2)),z,true);
+                float new_z_right = _map->GetHeight(temp_x + 1.0f*cos(angle-static_cast<float>(M_PI/2)),temp_y + 1.0f*sin(angle-static_cast<float>(M_PI/2)),z,true);
                 if (fabs(new_z_left - new_z) < 1.2f && fabs(new_z_right - new_z) < 1.2f)
                 {
                     x = temp_x;
@@ -287,7 +287,7 @@ FleeingMovementGenerator<T>::Initialize(T &owner)
         return;
 
     owner.SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_FLEEING);
-    owner.AddUnitState(UNIT_STAT_FLEEING|UNIT_STAT_FLEEING_MOVE);
+    owner.AddUnitState(UNIT_STATE_FLEEING|UNIT_STATE_FLEEING_MOVE);
 
     _Init(owner);
 
@@ -335,14 +335,14 @@ template<>
 void FleeingMovementGenerator<Player>::Finalize(Player &owner)
 {
     owner.RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_FLEEING);
-    owner.ClearUnitState(UNIT_STAT_FLEEING|UNIT_STAT_FLEEING_MOVE);
+    owner.ClearUnitState(UNIT_STATE_FLEEING|UNIT_STATE_FLEEING_MOVE);
 }
 
 template<>
 void FleeingMovementGenerator<Creature>::Finalize(Creature &owner)
 {
     owner.RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_FLEEING);
-    owner.ClearUnitState(UNIT_STAT_FLEEING|UNIT_STAT_FLEEING_MOVE);
+    owner.ClearUnitState(UNIT_STATE_FLEEING|UNIT_STATE_FLEEING_MOVE);
     if (owner.getVictim())
         owner.SetTarget(owner.getVictim()->GetGUID());
 }
@@ -359,9 +359,9 @@ FleeingMovementGenerator<T>::Update(T &owner, const uint32 &time_diff)
 {
     if (!&owner || !owner.isAlive())
         return false;
-    if (owner.HasUnitState(UNIT_STAT_ROOT | UNIT_STAT_STUNNED))
+    if (owner.HasUnitState(UNIT_STATE_ROOT | UNIT_STATE_STUNNED))
     {
-        owner.ClearUnitState(UNIT_STAT_FLEEING_MOVE);
+        owner.ClearUnitState(UNIT_STATE_FLEEING_MOVE);
         return true;
     }
 
@@ -388,7 +388,7 @@ template bool FleeingMovementGenerator<Creature>::Update(Creature &, const uint3
 void TimedFleeingMovementGenerator::Finalize(Unit &owner)
 {
     owner.RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_FLEEING);
-    owner.ClearUnitState(UNIT_STAT_FLEEING|UNIT_STAT_FLEEING_MOVE);
+    owner.ClearUnitState(UNIT_STATE_FLEEING|UNIT_STATE_FLEEING_MOVE);
     if (Unit* victim = owner.getVictim())
     {
         if (owner.isAlive())
@@ -404,9 +404,9 @@ bool TimedFleeingMovementGenerator::Update(Unit & owner, const uint32 time_diff)
     if (!owner.isAlive())
         return false;
 
-    if (owner.HasUnitState(UNIT_STAT_ROOT | UNIT_STAT_STUNNED))
+    if (owner.HasUnitState(UNIT_STATE_ROOT | UNIT_STATE_STUNNED))
     {
-        owner.ClearUnitState(UNIT_STAT_FLEEING_MOVE);
+        owner.ClearUnitState(UNIT_STATE_FLEEING_MOVE);
         return true;
     }
 
diff --git a/src/server/game/Movement/MovementGenerators/HomeMovementGenerator.cpp b/src/server/game/Movement/MovementGenerators/HomeMovementGenerator.cpp
index 84997d6..dc47898 100755
--- a/src/server/game/Movement/MovementGenerators/HomeMovementGenerator.cpp
+++ b/src/server/game/Movement/MovementGenerators/HomeMovementGenerator.cpp
@@ -25,7 +25,7 @@
 
 void HomeMovementGenerator<Creature>::Initialize(Creature & owner)
 {
-    owner.AddUnitState(UNIT_STAT_EVADE);
+    owner.AddUnitState(UNIT_STATE_EVADE);
     _setTargetLocation(owner);
 }
 
@@ -38,7 +38,7 @@ void HomeMovementGenerator<Creature>::_setTargetLocation(Creature & owner)
     if (!&owner)
         return;
 
-    if (owner.HasUnitState(UNIT_STAT_ROOT | UNIT_STAT_STUNNED | UNIT_STAT_DISTRACTED))
+    if (owner.HasUnitState(UNIT_STATE_ROOT | UNIT_STATE_STUNNED | UNIT_STATE_DISTRACTED))
         return;
 
     Movement::MoveSplineInit init(owner);
@@ -54,7 +54,7 @@ void HomeMovementGenerator<Creature>::_setTargetLocation(Creature & owner)
     init.Launch();
 
     arrived = false;
-    owner.ClearUnitState(UNIT_STAT_ALL_STATE & ~UNIT_STAT_EVADE);
+    owner.ClearUnitState(UNIT_STATE_ALL_STATE & ~UNIT_STATE_EVADE);
 }
 
 bool HomeMovementGenerator<Creature>::Update(Creature &owner, const uint32 time_diff)
@@ -67,7 +67,7 @@ void HomeMovementGenerator<Creature>::Finalize(Creature& owner)
 {
     if (arrived)
     {
-        owner.ClearUnitState(UNIT_STAT_EVADE);
+        owner.ClearUnitState(UNIT_STATE_EVADE);
         owner.SetWalk(true);
         owner.LoadCreaturesAddon(true);
         owner.AI()->JustReachedHome();
diff --git a/src/server/game/Movement/MovementGenerators/IdleMovementGenerator.cpp b/src/server/game/Movement/MovementGenerators/IdleMovementGenerator.cpp
index 43d3ccc..36561e0 100755
--- a/src/server/game/Movement/MovementGenerators/IdleMovementGenerator.cpp
+++ b/src/server/game/Movement/MovementGenerators/IdleMovementGenerator.cpp
@@ -32,19 +32,19 @@ void IdleMovementGenerator::Initialize(Unit &owner)
 void
 IdleMovementGenerator::Reset(Unit& owner)
 {
-    if (owner.HasUnitState(UNIT_STAT_MOVE))
+    if (owner.HasUnitState(UNIT_STATE_MOVE))
         owner.StopMoving();
 }
 
 void RotateMovementGenerator::Initialize(Unit& owner)
 {
-    if (owner.HasUnitState(UNIT_STAT_MOVE))
+    if (owner.HasUnitState(UNIT_STATE_MOVE))
         owner.StopMoving();
 
     if (owner.getVictim())
         owner.SetInFront(owner.getVictim());
 
-    owner.AddUnitState(UNIT_STAT_ROTATING);
+    owner.AddUnitState(UNIT_STATE_ROTATING);
 
     owner.AttackStop();
 }
@@ -75,7 +75,7 @@ bool RotateMovementGenerator::Update(Unit& owner, const uint32 diff)
 
 void RotateMovementGenerator::Finalize(Unit &unit)
 {
-    unit.ClearUnitState(UNIT_STAT_ROTATING);
+    unit.ClearUnitState(UNIT_STATE_ROTATING);
     if (unit.GetTypeId() == TYPEID_UNIT)
       unit.ToCreature()->AI()->MovementInform(ROTATE_MOTION_TYPE, 0);
 }
@@ -83,13 +83,13 @@ void RotateMovementGenerator::Finalize(Unit &unit)
 void
 DistractMovementGenerator::Initialize(Unit& owner)
 {
-    owner.AddUnitState(UNIT_STAT_DISTRACTED);
+    owner.AddUnitState(UNIT_STATE_DISTRACTED);
 }
 
 void
 DistractMovementGenerator::Finalize(Unit& owner)
 {
-    owner.ClearUnitState(UNIT_STAT_DISTRACTED);
+    owner.ClearUnitState(UNIT_STATE_DISTRACTED);
 }
 
 bool
@@ -105,7 +105,7 @@ DistractMovementGenerator::Update(Unit& /*owner*/, const uint32 time_diff)
 void
 AssistanceDistractMovementGenerator::Finalize(Unit &unit)
 {
-    unit.ClearUnitState(UNIT_STAT_DISTRACTED);
+    unit.ClearUnitState(UNIT_STATE_DISTRACTED);
     unit.ToCreature()->SetReactState(REACT_AGGRESSIVE);
 }
 
diff --git a/src/server/game/Movement/MovementGenerators/PointMovementGenerator.cpp b/src/server/game/Movement/MovementGenerators/PointMovementGenerator.cpp
index 8846501..02f9ebc 100755
--- a/src/server/game/Movement/MovementGenerators/PointMovementGenerator.cpp
+++ b/src/server/game/Movement/MovementGenerators/PointMovementGenerator.cpp
@@ -32,7 +32,7 @@ void PointMovementGenerator<T>::Initialize(T &unit)
     if (!unit.IsStopped())
         unit.StopMoving();
 
-    unit.AddUnitState(UNIT_STAT_ROAMING|UNIT_STAT_ROAMING_MOVE);
+    unit.AddUnitState(UNIT_STATE_ROAMING|UNIT_STATE_ROAMING_MOVE);
     Movement::MoveSplineInit init(unit);
     init.MoveTo(i_x, i_y, i_z);
     if (speed > 0.0f)
@@ -46,20 +46,20 @@ bool PointMovementGenerator<T>::Update(T &unit, const uint32 &diff)
     if (!&unit)
         return false;
 
-    if(unit.HasUnitState(UNIT_STAT_ROOT | UNIT_STAT_STUNNED))
+    if(unit.HasUnitState(UNIT_STATE_ROOT | UNIT_STATE_STUNNED))
     {
-        unit.ClearUnitState(UNIT_STAT_ROAMING_MOVE);
+        unit.ClearUnitState(UNIT_STATE_ROAMING_MOVE);
         return true;
     }
 
-    unit.AddUnitState(UNIT_STAT_ROAMING_MOVE);
+    unit.AddUnitState(UNIT_STATE_ROAMING_MOVE);
     return !unit.movespline->Finalized();
 }
 
 template<class T>
 void PointMovementGenerator<T>:: Finalize(T &unit)
 {
-    unit.ClearUnitState(UNIT_STAT_ROAMING|UNIT_STAT_ROAMING_MOVE);
+    unit.ClearUnitState(UNIT_STATE_ROAMING|UNIT_STATE_ROAMING_MOVE);
 
     if (unit.movespline->Finalized())
         MovementInform(unit);
@@ -71,7 +71,7 @@ void PointMovementGenerator<T>::Reset(T &unit)
     if (!unit.IsStopped())
         unit.StopMoving();
 
-    unit.AddUnitState(UNIT_STAT_ROAMING|UNIT_STAT_ROAMING_MOVE);
+    unit.AddUnitState(UNIT_STATE_ROAMING|UNIT_STATE_ROAMING_MOVE);
 }
 
 template<class T>
@@ -120,7 +120,7 @@ void EffectMovementGenerator::Finalize(Unit &unit)
     if (((Creature&)unit).AI() && unit.movespline->Finalized())
         ((Creature&)unit).AI()->MovementInform(EFFECT_MOTION_TYPE, m_Id);
     // Need restore previous movement since we have no proper states system
-    //if (unit.isAlive() && !unit.HasUnitState(UNIT_STAT_CONFUSED|UNIT_STAT_FLEEING))
+    //if (unit.isAlive() && !unit.HasUnitState(UNIT_STATE_CONFUSED|UNIT_STATE_FLEEING))
     //{
     //    if (Unit * victim = unit.getVictim())
     //        unit.GetMotionMaster()->MoveChase(victim);
diff --git a/src/server/game/Movement/MovementGenerators/RandomMovementGenerator.cpp b/src/server/game/Movement/MovementGenerators/RandomMovementGenerator.cpp
index 7270bbb..22adc7b 100755
--- a/src/server/game/Movement/MovementGenerators/RandomMovementGenerator.cpp
+++ b/src/server/game/Movement/MovementGenerators/RandomMovementGenerator.cpp
@@ -33,7 +33,7 @@
 #endif
 
 template<>
-void RandomMovementGenerator<Creature>::_setRandomLocation(Creature& creature)
+void RandomMovementGenerator<Creature>::_setRandomLocation(Creature &creature)
 {
     float respX, respY, respZ, respO, currZ, destX, destY, destZ, travelDistZ;
     creature.GetHomePosition(respX, respY, respZ, respO);
@@ -78,17 +78,17 @@ void RandomMovementGenerator<Creature>::_setRandomLocation(Creature& creature)
 
         // The fastest way to get an accurate result 90% of the time.
         // Better result can be obtained like 99% accuracy with a ray light, but the cost is too high and the code is too long.
-        destZ = map->GetHeight(creature.GetPhaseMask(), destX, destY, respZ+travelDistZ-2.0f, false);
+        destZ = map->GetHeight(destX, destY, respZ+travelDistZ-2.0f, false);
 
         if (fabs(destZ - respZ) > travelDistZ)              // Map check
         {
             // Vmap Horizontal or above
-            destZ = map->GetHeight(creature.GetPhaseMask(), destX, destY, respZ - 2.0f, true);
+            destZ = map->GetHeight(destX, destY, respZ - 2.0f, true);
 
             if (fabs(destZ - respZ) > travelDistZ)
             {
                 // Vmap Higher
-                destZ = map->GetHeight(creature.GetPhaseMask(), destX, destY, respZ+travelDistZ-2.0f, true);
+                destZ = map->GetHeight(destX, destY, respZ+travelDistZ-2.0f, true);
 
                 // let's forget this bad coords where a z cannot be find and retry at next tick
                 if (fabs(destZ - respZ) > travelDistZ)
@@ -102,7 +102,7 @@ void RandomMovementGenerator<Creature>::_setRandomLocation(Creature& creature)
     else
         i_nextMoveTime.Reset(urand(500, 10000));
 
-    creature.AddUnitState(UNIT_STAT_ROAMING_MOVE);
+    creature.AddUnitState(UNIT_STATE_ROAMING_MOVE);
 
     Movement::MoveSplineInit init(creature);
     init.MoveTo(destX, destY, destZ);
@@ -123,7 +123,7 @@ void RandomMovementGenerator<Creature>::Initialize(Creature &creature)
     if (!wander_distance)
         wander_distance = creature.GetRespawnRadius();
 
-    creature.AddUnitState(UNIT_STAT_ROAMING|UNIT_STAT_ROAMING_MOVE);
+    creature.AddUnitState(UNIT_STATE_ROAMING|UNIT_STATE_ROAMING_MOVE);
     _setRandomLocation(creature);
 }
 
@@ -137,7 +137,7 @@ RandomMovementGenerator<Creature>::Reset(Creature &creature)
 template<>
 void RandomMovementGenerator<Creature>::Finalize(Creature &creature)
 {
-    creature.ClearUnitState(UNIT_STAT_ROAMING|UNIT_STAT_ROAMING_MOVE);
+    creature.ClearUnitState(UNIT_STATE_ROAMING|UNIT_STATE_ROAMING_MOVE);
     creature.SetWalk(false);
 }
 
@@ -145,10 +145,10 @@ template<>
 bool
 RandomMovementGenerator<Creature>::Update(Creature &creature, const uint32 diff)
 {
-    if (creature.HasUnitState(UNIT_STAT_ROOT | UNIT_STAT_STUNNED | UNIT_STAT_DISTRACTED))
+    if (creature.HasUnitState(UNIT_STATE_ROOT | UNIT_STATE_STUNNED | UNIT_STATE_DISTRACTED))
     {
         i_nextMoveTime.Reset(0);  // Expire the timer
-        creature.ClearUnitState(UNIT_STAT_ROAMING_MOVE);
+        creature.ClearUnitState(UNIT_STATE_ROAMING_MOVE);
         return true;
     }
 
diff --git a/src/server/game/Movement/MovementGenerators/TargetedMovementGenerator.cpp b/src/server/game/Movement/MovementGenerators/TargetedMovementGenerator.cpp
index 0d2982a..964b440 100755
--- a/src/server/game/Movement/MovementGenerators/TargetedMovementGenerator.cpp
+++ b/src/server/game/Movement/MovementGenerators/TargetedMovementGenerator.cpp
@@ -34,7 +34,7 @@ void TargetedMovementGeneratorMedium<T,D>::_setTargetLocation(T &owner)
     if (!i_target.isValid() || !i_target->IsInWorld())
         return;
 
-    if (owner.HasUnitState(UNIT_STAT_NOT_MOVE))
+    if (owner.HasUnitState(UNIT_STATE_NOT_MOVE))
         return;
 
     float x, y, z;
@@ -125,7 +125,7 @@ bool TargetedMovementGeneratorMedium<T,D>::Update(T &owner, const uint32 & time_
     if (!owner.isAlive())
         return true;
 
-    if (owner.HasUnitState(UNIT_STAT_NOT_MOVE))
+    if (owner.HasUnitState(UNIT_STATE_NOT_MOVE))
     {
         D::_clearUnitStateMove(owner);
         return true;
@@ -188,7 +188,7 @@ void ChaseMovementGenerator<T>::_reachTarget(T &owner)
 template<>
 void ChaseMovementGenerator<Player>::Initialize(Player &owner)
 {
-    owner.AddUnitState(UNIT_STAT_CHASE|UNIT_STAT_CHASE_MOVE);
+    owner.AddUnitState(UNIT_STATE_CHASE|UNIT_STATE_CHASE_MOVE);
     _setTargetLocation(owner);
 }
 
@@ -196,14 +196,14 @@ template<>
 void ChaseMovementGenerator<Creature>::Initialize(Creature &owner)
 {
     owner.SetWalk(false);
-    owner.AddUnitState(UNIT_STAT_CHASE|UNIT_STAT_CHASE_MOVE);
+    owner.AddUnitState(UNIT_STATE_CHASE|UNIT_STATE_CHASE_MOVE);
     _setTargetLocation(owner);
 }
 
 template<class T>
 void ChaseMovementGenerator<T>::Finalize(T &owner)
 {
-    owner.ClearUnitState(UNIT_STAT_CHASE|UNIT_STAT_CHASE_MOVE);
+    owner.ClearUnitState(UNIT_STATE_CHASE|UNIT_STATE_CHASE_MOVE);
 }
 
 template<class T>
@@ -259,7 +259,7 @@ void FollowMovementGenerator<Creature>::_updateSpeed(Creature &u)
 template<>
 void FollowMovementGenerator<Player>::Initialize(Player &owner)
 {
-    owner.AddUnitState(UNIT_STAT_FOLLOW|UNIT_STAT_FOLLOW_MOVE);
+    owner.AddUnitState(UNIT_STATE_FOLLOW|UNIT_STATE_FOLLOW_MOVE);
     _updateSpeed(owner);
     _setTargetLocation(owner);
 }
@@ -267,7 +267,7 @@ void FollowMovementGenerator<Player>::Initialize(Player &owner)
 template<>
 void FollowMovementGenerator<Creature>::Initialize(Creature &owner)
 {
-    owner.AddUnitState(UNIT_STAT_FOLLOW|UNIT_STAT_FOLLOW_MOVE);
+    owner.AddUnitState(UNIT_STATE_FOLLOW|UNIT_STATE_FOLLOW_MOVE);
     _updateSpeed(owner);
     _setTargetLocation(owner);
 }
@@ -275,7 +275,7 @@ void FollowMovementGenerator<Creature>::Initialize(Creature &owner)
 template<class T>
 void FollowMovementGenerator<T>::Finalize(T &owner)
 {
-    owner.ClearUnitState(UNIT_STAT_FOLLOW|UNIT_STAT_FOLLOW_MOVE);
+    owner.ClearUnitState(UNIT_STATE_FOLLOW|UNIT_STATE_FOLLOW_MOVE);
     _updateSpeed(owner);
 }
 
diff --git a/src/server/game/Movement/MovementGenerators/TargetedMovementGenerator.h b/src/server/game/Movement/MovementGenerators/TargetedMovementGenerator.h
index 696c99e..bf2eecc 100755
--- a/src/server/game/Movement/MovementGenerators/TargetedMovementGenerator.h
+++ b/src/server/game/Movement/MovementGenerators/TargetedMovementGenerator.h
@@ -79,8 +79,8 @@ class ChaseMovementGenerator : public TargetedMovementGeneratorMedium<T, ChaseMo
         void Reset(T &);
         void MovementInform(T &);
 
-        static void _clearUnitStateMove(T &u) { u.ClearUnitState(UNIT_STAT_CHASE_MOVE); }
-        static void _addUnitStateMove(T &u)  { u.AddUnitState(UNIT_STAT_CHASE_MOVE); }
+        static void _clearUnitStateMove(T &u) { u.ClearUnitState(UNIT_STATE_CHASE_MOVE); }
+        static void _addUnitStateMove(T &u)  { u.AddUnitState(UNIT_STATE_CHASE_MOVE); }
         bool EnableWalking() const { return false;}
         bool _lostTarget(T &u) const { return u.getVictim() != this->GetTarget(); }
         void _reachTarget(T &);
@@ -103,8 +103,8 @@ class FollowMovementGenerator : public TargetedMovementGeneratorMedium<T, Follow
         void Reset(T &);
         void MovementInform(T &);
 
-        static void _clearUnitStateMove(T &u) { u.ClearUnitState(UNIT_STAT_FOLLOW_MOVE); }
-        static void _addUnitStateMove(T &u)  { u.AddUnitState(UNIT_STAT_FOLLOW_MOVE); }
+        static void _clearUnitStateMove(T &u) { u.ClearUnitState(UNIT_STATE_FOLLOW_MOVE); }
+        static void _addUnitStateMove(T &u)  { u.AddUnitState(UNIT_STATE_FOLLOW_MOVE); }
         bool EnableWalking() const;
         bool _lostTarget(T &) const { return false; }
         void _reachTarget(T &) {}
diff --git a/src/server/game/Movement/MovementGenerators/WaypointMovementGenerator.cpp b/src/server/game/Movement/MovementGenerators/WaypointMovementGenerator.cpp
index ce8628a..55cf3c2 100755
--- a/src/server/game/Movement/MovementGenerators/WaypointMovementGenerator.cpp
+++ b/src/server/game/Movement/MovementGenerators/WaypointMovementGenerator.cpp
@@ -51,18 +51,18 @@ void WaypointMovementGenerator<Creature>::LoadPath(Creature &creature)
 void WaypointMovementGenerator<Creature>::Initialize(Creature &creature)
 {
     LoadPath(creature);
-    creature.AddUnitState(UNIT_STAT_ROAMING|UNIT_STAT_ROAMING_MOVE);
+    creature.AddUnitState(UNIT_STATE_ROAMING|UNIT_STATE_ROAMING_MOVE);
 }
 
 void WaypointMovementGenerator<Creature>::Finalize(Creature &creature)
 {
-    creature.ClearUnitState(UNIT_STAT_ROAMING|UNIT_STAT_ROAMING_MOVE);
+    creature.ClearUnitState(UNIT_STATE_ROAMING|UNIT_STATE_ROAMING_MOVE);
     creature.SetWalk(false);
 }
 
 void WaypointMovementGenerator<Creature>::Reset(Creature &creature)
 {
-    creature.AddUnitState(UNIT_STAT_ROAMING|UNIT_STAT_ROAMING_MOVE);
+    creature.AddUnitState(UNIT_STATE_ROAMING|UNIT_STATE_ROAMING_MOVE);
     StartMoveNow(creature);
 }
 
@@ -73,7 +73,7 @@ void WaypointMovementGenerator<Creature>::OnArrived(Creature& creature)
     if (m_isArrivalDone)
         return;
 
-    creature.ClearUnitState(UNIT_STAT_ROAMING_MOVE);
+    creature.ClearUnitState(UNIT_STATE_ROAMING_MOVE);
     m_isArrivalDone = true;
 
     if (i_path->at(i_currentNode)->event_id && urand(0, 99) < i_path->at(i_currentNode)->event_chance)
@@ -111,7 +111,7 @@ bool WaypointMovementGenerator<Creature>::StartMove(Creature &creature)
 
     m_isArrivalDone = false;
 
-    creature.AddUnitState(UNIT_STAT_ROAMING_MOVE);   
+    creature.AddUnitState(UNIT_STATE_ROAMING_MOVE);   
     
     Movement::MoveSplineInit init(creature);
     init.MoveTo(node->x, node->y, node->z);
@@ -133,9 +133,9 @@ bool WaypointMovementGenerator<Creature>::Update(Creature &creature, const uint3
 {
     // Waypoint movement can be switched on/off
     // This is quite handy for escort quests and other stuff
-    if (creature.HasUnitState(UNIT_STAT_NOT_MOVE))
+    if (creature.HasUnitState(UNIT_STATE_NOT_MOVE))
     {
-        creature.ClearUnitState(UNIT_STAT_ROAMING_MOVE);
+        creature.ClearUnitState(UNIT_STATE_ROAMING_MOVE);
         return true;
     }
     // prevent a crash at empty waypoint path.
@@ -204,7 +204,7 @@ void FlightPathMovementGenerator::Initialize(Player &player)
 void FlightPathMovementGenerator::Finalize(Player & player)
 {
     // remove flag to prevent send object build movement packets for flight state and crash (movement generator already not at top of stack)
-    player.ClearUnitState(UNIT_STAT_IN_FLIGHT);
+    player.ClearUnitState(UNIT_STATE_IN_FLIGHT);
 
     player.Dismount();
     player.RemoveFlag(UNIT_FIELD_FLAGS,UNIT_FLAG_DISABLE_MOVE | UNIT_FLAG_TAXI_FLIGHT);
@@ -227,7 +227,7 @@ void FlightPathMovementGenerator::Finalize(Player & player)
 void FlightPathMovementGenerator::Reset(Player & player)
 {
     player.getHostileRefManager().setOnlineOfflineState(false);
-    player.AddUnitState(UNIT_STAT_IN_FLIGHT);
+    player.AddUnitState(UNIT_STATE_IN_FLIGHT);
     player.SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE | UNIT_FLAG_TAXI_FLIGHT);
 
     Movement::MoveSplineInit init(player);
diff --git a/src/server/game/Spells/Auras/SpellAuraEffects.cpp b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
index 7c09a2f..1972b62 100755
--- a/src/server/game/Spells/Auras/SpellAuraEffects.cpp
+++ b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
@@ -2417,7 +2417,7 @@ void AuraEffect::HandleFeignDeath(AuraApplication const* aurApp, uint8 mode, boo
         target->VisitNearbyObject(target->GetMap()->GetVisibilityRange(), searcher);
         for (UnitList::iterator iter = targets.begin(); iter != targets.end(); ++iter)
         {
-            if (!(*iter)->HasUnitState(UNIT_STAT_CASTING))
+            if (!(*iter)->HasUnitState(UNIT_STATE_CASTING))
                 continue;
 
             for (uint32 i = CURRENT_FIRST_NON_MELEE_SPELL; i < CURRENT_MAX_SPELL; i++)
@@ -2448,7 +2448,7 @@ void AuraEffect::HandleFeignDeath(AuraApplication const* aurApp, uint8 mode, boo
                                                             // blizz like 2.0.x
         target->SetFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_DEAD);
 
-        target->AddUnitState(UNIT_STAT_DIED);
+        target->AddUnitState(UNIT_STATE_DIED);
     }
     else
     {
@@ -2465,7 +2465,7 @@ void AuraEffect::HandleFeignDeath(AuraApplication const* aurApp, uint8 mode, boo
                                                             // blizz like 2.0.x
         target->RemoveFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_DEAD);
 
-        target->ClearUnitState(UNIT_STAT_DIED);
+        target->ClearUnitState(UNIT_STATE_DIED);
     }
 }
 
@@ -3031,7 +3031,7 @@ void AuraEffect::HandleModConfuse(AuraApplication const* aurApp, uint8 mode, boo
 
     Unit* target = aurApp->GetTarget();
 
-    target->SetControlled(apply, UNIT_STAT_CONFUSED);
+    target->SetControlled(apply, UNIT_STATE_CONFUSED);
 }
 
 void AuraEffect::HandleModFear(AuraApplication const* aurApp, uint8 mode, bool apply) const
@@ -3041,7 +3041,7 @@ void AuraEffect::HandleModFear(AuraApplication const* aurApp, uint8 mode, bool a
 
     Unit* target = aurApp->GetTarget();
 
-    target->SetControlled(apply, UNIT_STAT_FLEEING);
+    target->SetControlled(apply, UNIT_STATE_FLEEING);
 }
 
 void AuraEffect::HandleAuraModStun(AuraApplication const* aurApp, uint8 mode, bool apply) const
@@ -3051,7 +3051,7 @@ void AuraEffect::HandleAuraModStun(AuraApplication const* aurApp, uint8 mode, bo
 
     Unit* target = aurApp->GetTarget();
 
-    target->SetControlled(apply, UNIT_STAT_STUNNED);
+    target->SetControlled(apply, UNIT_STATE_STUNNED);
 }
 
 void AuraEffect::HandleAuraModRoot(AuraApplication const* aurApp, uint8 mode, bool apply) const
@@ -3061,7 +3061,7 @@ void AuraEffect::HandleAuraModRoot(AuraApplication const* aurApp, uint8 mode, bo
 
     Unit* target = aurApp->GetTarget();
 
-    target->SetControlled(apply, UNIT_STAT_ROOT);
+    target->SetControlled(apply, UNIT_STATE_ROOT);
 }
 
 void AuraEffect::HandlePreventFleeing(AuraApplication const* aurApp, uint8 mode, bool apply) const
@@ -3072,7 +3072,7 @@ void AuraEffect::HandlePreventFleeing(AuraApplication const* aurApp, uint8 mode,
     Unit* target = aurApp->GetTarget();
 
     if (target->HasAuraType(SPELL_AURA_MOD_FEAR))
-        target->SetControlled(!(apply), UNIT_STAT_FLEEING);
+        target->SetControlled(!(apply), UNIT_STATE_FLEEING);
 }
 
 /***************************/
@@ -3465,7 +3465,7 @@ void AuraEffect::HandleAuraModSchoolImmunity(AuraApplication const* aurApp, uint
     if (GetSpellInfo()->Mechanic == MECHANIC_BANISH)
     {
         if (apply)
-            target->AddUnitState(UNIT_STAT_ISOLATED);
+            target->AddUnitState(UNIT_STATE_ISOLATED);
         else
         {
             bool banishFound = false;
@@ -3477,7 +3477,7 @@ void AuraEffect::HandleAuraModSchoolImmunity(AuraApplication const* aurApp, uint
                     break;
                 }
             if (!banishFound)
-                target->ClearUnitState(UNIT_STAT_ISOLATED);
+                target->ClearUnitState(UNIT_STATE_ISOLATED);
         }
     }
 
@@ -6156,7 +6156,7 @@ void AuraEffect::HandlePeriodicDamageAurasTick(Unit* target, Unit* caster) const
     if (!caster || !target->isAlive())
         return;
 
-    if (target->HasUnitState(UNIT_STAT_ISOLATED) || target->IsImmunedToDamage(GetSpellInfo()))
+    if (target->HasUnitState(UNIT_STATE_ISOLATED) || target->IsImmunedToDamage(GetSpellInfo()))
     {
         SendTickImmune(target, caster);
         return;
@@ -6297,7 +6297,7 @@ void AuraEffect::HandlePeriodicHealthLeechAuraTick(Unit* target, Unit* caster) c
     if (!caster || !caster->isAlive() || !target->isAlive())
         return;
 
-    if (target->HasUnitState(UNIT_STAT_ISOLATED) || target->IsImmunedToDamage(GetSpellInfo()))
+    if (target->HasUnitState(UNIT_STATE_ISOLATED) || target->IsImmunedToDamage(GetSpellInfo()))
     {
         SendTickImmune(target, caster);
         return;
@@ -6363,7 +6363,7 @@ void AuraEffect::HandlePeriodicHealthFunnelAuraTick(Unit* target, Unit* caster)
     if (!caster || !caster->isAlive() || !target->isAlive())
         return;
 
-    if (target->HasUnitState(UNIT_STAT_ISOLATED))
+    if (target->HasUnitState(UNIT_STATE_ISOLATED))
     {
         SendTickImmune(target, caster);
         return;
@@ -6391,7 +6391,7 @@ void AuraEffect::HandlePeriodicHealAurasTick(Unit* target, Unit* caster) const
     if (!caster || !target->isAlive())
         return;
 
-    if (target->HasUnitState(UNIT_STAT_ISOLATED))
+    if (target->HasUnitState(UNIT_STATE_ISOLATED))
     {
         SendTickImmune(target, caster);
         return;
@@ -6507,7 +6507,7 @@ void AuraEffect::HandlePeriodicManaLeechAuraTick(Unit* target, Unit* caster) con
     if (!caster || !caster->isAlive() || !target->isAlive() || target->getPowerType() != powerType)
         return;
 
-    if (target->HasUnitState(UNIT_STAT_ISOLATED) || target->IsImmunedToDamage(GetSpellInfo()))
+    if (target->HasUnitState(UNIT_STATE_ISOLATED) || target->IsImmunedToDamage(GetSpellInfo()))
     {
         SendTickImmune(target, caster);
         return;
@@ -6607,7 +6607,7 @@ void AuraEffect::HandleObsModPowerAuraTick(Unit* target, Unit* caster) const
     if (!target->isAlive() || !target->GetMaxPower(powerType))
         return;
 
-    if (target->HasUnitState(UNIT_STAT_ISOLATED))
+    if (target->HasUnitState(UNIT_STATE_ISOLATED))
     {
         SendTickImmune(target, caster);
         return;
@@ -6638,7 +6638,7 @@ void AuraEffect::HandlePeriodicEnergizeAuraTick(Unit* target, Unit* caster) cons
     if (!target->isAlive() || !target->GetMaxPower(powerType))
         return;
 
-    if (target->HasUnitState(UNIT_STAT_ISOLATED))
+    if (target->HasUnitState(UNIT_STATE_ISOLATED))
     {
         SendTickImmune(target, caster);
         return;
@@ -6670,7 +6670,7 @@ void AuraEffect::HandlePeriodicPowerBurnAuraTick(Unit* target, Unit* caster) con
     if (!caster || !target->isAlive() || target->getPowerType() != powerType)
         return;
 
-    if (target->HasUnitState(UNIT_STAT_ISOLATED) || target->IsImmunedToDamage(GetSpellInfo()))
+    if (target->HasUnitState(UNIT_STATE_ISOLATED) || target->IsImmunedToDamage(GetSpellInfo()))
     {
         SendTickImmune(target, caster);
         return;
diff --git a/src/server/game/Spells/Auras/SpellAuras.cpp b/src/server/game/Spells/Auras/SpellAuras.cpp
index b32e346..d49ac82 100755
--- a/src/server/game/Spells/Auras/SpellAuras.cpp
+++ b/src/server/game/Spells/Auras/SpellAuras.cpp
@@ -520,7 +520,13 @@ void Aura::UpdateTargetMap(Unit* caster, bool apply)
 
         bool addUnit = true;
         // check target immunities
-        if (itr->first->IsImmunedToSpell(GetSpellInfo())
+        for (uint8 effIndex = 0; effIndex < MAX_SPELL_EFFECTS; ++effIndex)
+        {
+            if (itr->first->IsImmunedToSpellEffect(GetSpellInfo(), effIndex))
+                itr->second &= ~(1 << effIndex);
+        }
+        if (!itr->second
+            || itr->first->IsImmunedToSpell(GetSpellInfo())
             || !CanBeAppliedOn(itr->first))
             addUnit = false;
 
@@ -1855,7 +1861,7 @@ bool Aura::CanStackWith(Aura const* existingAura) const
                 case SPELL_AURA_OBS_MOD_HEALTH:
                 case SPELL_AURA_PERIODIC_TRIGGER_SPELL_WITH_VALUE:
                     // periodic auras which target areas are not allowed to stack this way (replenishment for example)
-                    if (m_spellInfo->Effects[i].IsArea() || existingSpellInfo->Effects[i].IsArea())
+                    if (m_spellInfo->Effects[i].IsTargetingArea() || existingSpellInfo->Effects[i].IsTargetingArea())
                         break;
                     return true;
                 default:
@@ -2085,6 +2091,30 @@ bool Aura::CallScriptCheckAreaTargetHandlers(Unit* target)
     return true;
 }
 
+void Aura::CallScriptDispel(DispelInfo* dispelInfo)
+{
+    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    {
+        (*scritr)->_PrepareScriptCall(AURA_SCRIPT_HOOK_DISPEL);
+        std::list<AuraScript::AuraDispelHandler>::iterator hookItrEnd = (*scritr)->OnDispel.end(), hookItr = (*scritr)->OnDispel.begin();
+        for (; hookItr != hookItrEnd ; ++hookItr)
+            (*hookItr).Call(*scritr, dispelInfo);
+        (*scritr)->_FinishScriptCall();
+    }
+}
+
+void Aura::CallScriptAfterDispel(DispelInfo* dispelInfo)
+{
+    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    {
+        (*scritr)->_PrepareScriptCall(AURA_SCRIPT_HOOK_AFTER_DISPEL);
+        std::list<AuraScript::AuraDispelHandler>::iterator hookItrEnd = (*scritr)->AfterDispel.end(), hookItr = (*scritr)->AfterDispel.begin();
+        for (; hookItr != hookItrEnd ; ++hookItr)
+            (*hookItr).Call(*scritr, dispelInfo);
+        (*scritr)->_FinishScriptCall();
+    }
+}
+
 bool Aura::CallScriptEffectApplyHandlers(AuraEffect const* aurEff, AuraApplication const* aurApp, AuraEffectHandleModes mode)
 {
     bool preventDefault = false;
@@ -2342,7 +2372,7 @@ void UnitAura::FillTargetMap(std::map<Unit*, uint8> & targets, Unit* caster)
         {
             float radius = GetSpellInfo()->Effects[effIndex].CalcRadius(caster);
 
-            if (!GetUnitOwner()->HasUnitState(UNIT_STAT_ISOLATED))
+            if (!GetUnitOwner()->HasUnitState(UNIT_STATE_ISOLATED))
             {
                 switch (GetSpellInfo()->Effects[effIndex].Effect)
                 {
diff --git a/src/server/game/Spells/Auras/SpellAuras.h b/src/server/game/Spells/Auras/SpellAuras.h
index de743eb..4d87abc 100755
--- a/src/server/game/Spells/Auras/SpellAuras.h
+++ b/src/server/game/Spells/Auras/SpellAuras.h
@@ -201,6 +201,8 @@ class Aura
         // AuraScript
         void LoadScripts();
         bool CallScriptCheckAreaTargetHandlers(Unit* target);
+        void CallScriptDispel(DispelInfo* dispelInfo);
+        void CallScriptAfterDispel(DispelInfo* dispelInfo);
         bool CallScriptEffectApplyHandlers(AuraEffect const* aurEff, AuraApplication const* aurApp, AuraEffectHandleModes mode);
         bool CallScriptEffectRemoveHandlers(AuraEffect const* aurEff, AuraApplication const* aurApp, AuraEffectHandleModes mode);
         void CallScriptAfterEffectApplyHandlers(AuraEffect const* aurEff, AuraApplication const* aurApp, AuraEffectHandleModes mode);
diff --git a/src/server/game/Spells/Spell.cpp b/src/server/game/Spells/Spell.cpp
index 042aa68..dc804d7 100755
--- a/src/server/game/Spells/Spell.cpp
+++ b/src/server/game/Spells/Spell.cpp
@@ -1401,13 +1401,17 @@ void Spell::DoAllEffectOnTarget(TargetInfo* target)
     }
 }
 
-SpellMissInfo Spell::DoSpellHitOnUnit(Unit* unit, const uint32 effectMask, bool scaleAura)
+SpellMissInfo Spell::DoSpellHitOnUnit(Unit* unit, uint32 effectMask, bool scaleAura)
 {
     if (!unit || !effectMask)
         return SPELL_MISS_EVADE;
 
-    // Recheck immune (only for delayed spells)
-    if (m_spellInfo->Speed && (unit->IsImmunedToDamage(m_spellInfo) || unit->IsImmunedToSpell(m_spellInfo)))
+    // For delayed spells immunity may be applied between missile launch and hit - check immunity for that case
+    // disable effects to which unit is immune
+    for (uint32 effectNumber = 0; effectNumber < MAX_SPELL_EFFECTS; ++effectNumber)
+        if (effectMask & (1 << effectNumber) && unit->IsImmunedToSpellEffect(m_spellInfo, effectNumber))
+            effectMask &= ~(1 << effectNumber);
+    if (!effectMask || (m_spellInfo->Speed && (unit->IsImmunedToDamage(m_spellInfo) || unit->IsImmunedToSpell(m_spellInfo))))
         return SPELL_MISS_IMMUNE;
 
     PrepareScriptHitHandlers();
@@ -1447,7 +1451,7 @@ SpellMissInfo Spell::DoSpellHitOnUnit(Unit* unit, const uint32 effectMask, bool
                 return SPELL_MISS_EVADE;
 
             // assisting case, healing and resurrection
-            if (unit->HasUnitState(UNIT_STAT_ATTACK_PLAYER))
+            if (unit->HasUnitState(UNIT_STATE_ATTACK_PLAYER))
             {
                 m_caster->SetContestedPvP();
                 if (m_caster->GetTypeId() == TYPEID_PLAYER)
@@ -1562,7 +1566,7 @@ SpellMissInfo Spell::DoSpellHitOnUnit(Unit* unit, const uint32 effectMask, bool
     }
 
     for (uint32 effectNumber = 0; effectNumber < MAX_SPELL_EFFECTS; ++effectNumber)
-        if (effectMask & (1 << effectNumber) && !unit->IsImmunedToSpellEffect(m_spellInfo, effectNumber)) //Handle effect only if the target isn't immune.
+        if (effectMask & (1 << effectNumber))
             HandleEffects(unit, NULL, NULL, effectNumber, SPELL_EFFECT_HANDLE_HIT_TARGET);
 
     return SPELL_MISS_NONE;
@@ -3214,8 +3218,8 @@ void Spell::cast(bool skipCheck)
         m_spellState = SPELL_STATE_DELAYED;
         SetDelayStart(0);
 
-        if (m_caster->HasUnitState(UNIT_STAT_CASTING) && !m_caster->IsNonMeleeSpellCasted(false, false, true))
-            m_caster->ClearUnitState(UNIT_STAT_CASTING);
+        if (m_caster->HasUnitState(UNIT_STATE_CASTING) && !m_caster->IsNonMeleeSpellCasted(false, false, true))
+            m_caster->ClearUnitState(UNIT_STATE_CASTING);
     }
     else
     {
@@ -3581,8 +3585,8 @@ void Spell::finish(bool ok)
     if (m_spellInfo->IsChanneled())
         m_caster->UpdateInterruptMask();
 
-    if (m_caster->HasUnitState(UNIT_STAT_CASTING) && !m_caster->IsNonMeleeSpellCasted(false, false, true))
-        m_caster->ClearUnitState(UNIT_STAT_CASTING);
+    if (m_caster->HasUnitState(UNIT_STATE_CASTING) && !m_caster->IsNonMeleeSpellCasted(false, false, true))
+        m_caster->ClearUnitState(UNIT_STATE_CASTING);
 
     // Unsummon summon as possessed creatures on spell cancel
     if (m_spellInfo->IsChanneled() && m_caster->GetTypeId() == TYPEID_PLAYER)
@@ -5000,7 +5004,7 @@ SpellCastResult Spell::CheckCast(bool strict)
                     if (strict && m_caster->IsScriptOverriden(m_spellInfo, 6953))
                         m_caster->RemoveMovementImpairingAuras();
                 }
-                if (m_caster->HasUnitState(UNIT_STAT_ROOT))
+                if (m_caster->HasUnitState(UNIT_STATE_ROOT))
                     return SPELL_FAILED_ROOTED;
                 break;
             }
@@ -5228,7 +5232,7 @@ SpellCastResult Spell::CheckCast(bool strict)
                     return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
 
                 Unit* target = m_targets.GetUnitTarget();
-                if (m_caster == target && m_caster->HasUnitState(UNIT_STAT_ROOT))
+                if (m_caster == target && m_caster->HasUnitState(UNIT_STATE_ROOT))
                 {
                     if (m_caster->GetTypeId() == TYPEID_PLAYER)
                         return SPELL_FAILED_ROOTED;
@@ -5299,7 +5303,7 @@ SpellCastResult Spell::CheckCast(bool strict)
                     {
                         float x, y, z;
                         m_caster->GetPosition(x, y, z);
-                        float ground_Z = m_caster->GetMap()->GetHeight(m_caster->GetPhaseMask(), x, y, z);
+                        float ground_Z = m_caster->GetMap()->GetHeight(x, y, z);
                         if (fabs(ground_Z - z) < 0.1f)
                             return SPELL_FAILED_DONT_REPORT;
                         break;
@@ -5401,7 +5405,7 @@ SpellCastResult Spell::CheckCast(bool strict)
             }
             case SPELL_AURA_PERIODIC_MANA_LEECH:
             {
-                if (m_spellInfo->Effects[i].IsArea())
+                if (m_spellInfo->Effects[i].IsTargetingArea())
                     break;
 
                 if (!m_targets.GetUnitTarget())
@@ -5455,7 +5459,7 @@ SpellCastResult Spell::CheckCast(bool strict)
 
 SpellCastResult Spell::CheckPetCast(Unit* target)
 {
-    if (m_caster->HasUnitState(UNIT_STAT_CASTING) && !(_triggeredCastFlags & TRIGGERED_IGNORE_CAST_IN_PROGRESS))              //prevent spellcast interruption by another spellcast
+    if (m_caster->HasUnitState(UNIT_STATE_CASTING) && !(_triggeredCastFlags & TRIGGERED_IGNORE_CAST_IN_PROGRESS))              //prevent spellcast interruption by another spellcast
         return SPELL_FAILED_SPELL_IN_PROGRESS;
 
     // dead owner (pets still alive when owners ressed?)
@@ -6630,7 +6634,7 @@ void Spell::HandleLaunchPhase()
             continue;
 
         // do not consume ammo anymore for Hunter's volley spell
-        if (IsTriggered() && m_spellInfo->SpellFamilyName == SPELLFAMILY_HUNTER && m_spellInfo->IsAOE())
+        if (IsTriggered() && m_spellInfo->SpellFamilyName == SPELLFAMILY_HUNTER && m_spellInfo->IsTargetingArea())
             usesAmmo = false;
 
         if (usesAmmo)
@@ -6681,7 +6685,7 @@ void Spell::DoAllEffectOnLaunchTarget(TargetInfo& targetInfo, float* multiplier)
 
             if (m_damage > 0)
             {
-                if (m_spellInfo->Effects[i].IsArea())
+                if (m_spellInfo->Effects[i].IsTargetingArea())
                 {
                     m_damage = int32(float(m_damage) * unit->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_AOE_DAMAGE_AVOIDANCE, m_spellInfo->SchoolMask));
                     if (m_caster->GetTypeId() == TYPEID_UNIT)
diff --git a/src/server/game/Spells/SpellEffects.cpp b/src/server/game/Spells/SpellEffects.cpp
index d5a9bf9..0dd8eb6 100755
--- a/src/server/game/Spells/SpellEffects.cpp
+++ b/src/server/game/Spells/SpellEffects.cpp
@@ -1338,7 +1338,7 @@ void Spell::EffectDummy(SpellEffIndex effIndex)
                 }
 
                 //Any effect which causes you to lose control of your character will supress the starfall effect.
-                if (m_caster->HasUnitState(UNIT_STAT_CONTROLLED))
+                if (m_caster->HasUnitState(UNIT_STATE_CONTROLLED))
                     return;
 
                 m_caster->CastSpell(unitTarget, damage, true);
@@ -3093,7 +3093,7 @@ void Spell::EffectSummonType(SpellEffIndex effIndex)
                     summon->SelectLevel(summon->GetCreatureInfo());       // some summoned creaters have different from 1 DB data for level/hp
                     summon->SetUInt32Value(UNIT_NPC_FLAGS, summon->GetCreatureInfo()->npcflag);
 
-                    summon->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_PASSIVE);
+                    summon->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_IMMUNE_TO_NPC);
 
                     summon->AI()->EnterEvadeMode();
                     break;
@@ -3317,7 +3317,7 @@ void Spell::EffectDispel(SpellEffIndex effIndex)
         // Send dispelled spell info
         dataSuccess << uint32(itr->first->GetId());              // Spell Id
         dataSuccess << uint8(0);                        // 0 - dispelled !=0 cleansed
-        unitTarget->RemoveAurasDueToSpellByDispel(itr->first->GetId(), itr->first->GetCasterGUID(), m_caster, itr->second);
+        unitTarget->RemoveAurasDueToSpellByDispel(itr->first->GetId(), m_spellInfo->Id, itr->first->GetCasterGUID(), m_caster, itr->second);
     }
     m_caster->SendMessageToSet(&dataSuccess, true);
 
@@ -3360,11 +3360,11 @@ void Spell::EffectDistract(SpellEffIndex /*effIndex*/)
         return;
 
     // target must be OK to do this
-    if (unitTarget->HasUnitState(UNIT_STAT_CONFUSED | UNIT_STAT_STUNNED | UNIT_STAT_FLEEING))
+    if (unitTarget->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING))
         return;
 
     unitTarget->SetFacingTo(unitTarget->GetAngle(m_targets.GetDst()));
-    unitTarget->ClearUnitState(UNIT_STAT_MOVING);
+    unitTarget->ClearUnitState(UNIT_STATE_MOVING);
 
     if (unitTarget->GetTypeId() == TYPEID_UNIT)
         unitTarget->GetMotionMaster()->MoveDistract(damage * IN_MILLISECONDS);
@@ -6426,7 +6426,7 @@ void Spell::EffectSummonDeadPet(SpellEffIndex /*effIndex*/)
     pet->SetUInt32Value(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_NONE);
     pet->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE);
     pet->setDeathState(ALIVE);
-    pet->ClearUnitState(uint32(UNIT_STAT_ALL_STATE));
+    pet->ClearUnitState(uint32(UNIT_STATE_ALL_STATE));
     pet->SetHealth(pet->CountPctFromMaxHealth(damage));
 
     //pet->AIM_Initialize();
diff --git a/src/server/game/Spells/SpellInfo.cpp b/src/server/game/Spells/SpellInfo.cpp
index fb8018f..ad46576 100644
--- a/src/server/game/Spells/SpellInfo.cpp
+++ b/src/server/game/Spells/SpellInfo.cpp
@@ -503,7 +503,7 @@ bool SpellEffectInfo::IsAura(AuraType aura) const
     return IsAura() && ApplyAuraName == aura;
 }
 
-bool SpellEffectInfo::IsArea() const
+bool SpellEffectInfo::IsTargetingArea() const
 {
     return TargetA.IsArea() || TargetB.IsArea();
 }
@@ -1061,10 +1061,19 @@ bool SpellInfo::IsAbilityOfSkillType(uint32 skillType) const
     return false;
 }
 
-bool SpellInfo::IsAOE() const
+bool SpellInfo::IsAffectingArea() const
 {
     for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-        if (Effects[i].IsEffect() && Effects[i].IsArea())
+        if (Effects[i].IsEffect() && (Effects[i].IsTargetingArea() || Effects[i].IsEffect(SPELL_EFFECT_PERSISTENT_AREA_AURA) || Effects[i].IsAreaAuraEffect()))
+            return true;
+    return false;
+}
+
+// checks if spell targets are selected from area, doesn't include spell effects in check (like area wide auras for example)
+bool SpellInfo::IsTargetingArea() const
+{
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        if (Effects[i].IsEffect() && Effects[i].IsTargetingArea())
             return true;
     return false;
 }
@@ -1604,7 +1613,7 @@ SpellCastResult SpellInfo::CheckTarget(Unit const* caster, Unit const* target, b
     }
 
     // not allow casting on flying player
-    if (target->HasUnitState(UNIT_STAT_IN_FLIGHT))
+    if (target->HasUnitState(UNIT_STATE_IN_FLIGHT))
         return SPELL_FAILED_BAD_TARGETS;
 
     if (TargetAuraState && !target->HasAuraState(AuraStateType(TargetAuraState), this, caster))
diff --git a/src/server/game/Spells/SpellInfo.h b/src/server/game/Spells/SpellInfo.h
index 90b79d4..65be598 100644
--- a/src/server/game/Spells/SpellInfo.h
+++ b/src/server/game/Spells/SpellInfo.h
@@ -279,7 +279,7 @@ public:
     bool IsEffect(SpellEffects effectName) const;
     bool IsAura() const;
     bool IsAura(AuraType aura) const;
-    bool IsArea() const;
+    bool IsTargetingArea() const;
     bool IsAreaAuraEffect() const;
     bool IsFarUnitTargetEffect() const;
     bool IsFarDestTargetEffect() const;
@@ -403,7 +403,8 @@ public:
     bool IsAbilityLearnedWithProfession() const;
     bool IsAbilityOfSkillType(uint32 skillType) const;
 
-    bool IsAOE() const;
+    bool IsAffectingArea() const;
+    bool IsTargetingArea() const;
     bool NeedsExplicitUnitTarget() const;
     bool NeedsToBeTriggeredByCaster() const;
 
diff --git a/src/server/game/Spells/SpellScript.cpp b/src/server/game/Spells/SpellScript.cpp
index 8e20fd2..8a58ce3 100755
--- a/src/server/game/Spells/SpellScript.cpp
+++ b/src/server/game/Spells/SpellScript.cpp
@@ -542,6 +542,14 @@ bool AuraScript::_Validate(SpellInfo const* entry)
         if (!entry->HasAreaAuraEffect())
             sLog->outError("TSCR: Spell `%u` of script `%s` does not have area aura effect - handler bound to hook `DoCheckAreaTarget` of AuraScript won't be executed", entry->Id, m_scriptName->c_str());
 
+    for (std::list<AuraDispelHandler>::iterator itr = OnDispel.begin(); itr != OnDispel.end();  ++itr)
+        if (!entry->HasEffect(SPELL_EFFECT_APPLY_AURA) && !entry->HasAreaAuraEffect())
+            sLog->outError("TSCR: Spell `%u` of script `%s` does not have apply aura effect - handler bound to hook `OnDispel` of AuraScript won't be executed", entry->Id, m_scriptName->c_str());
+
+    for (std::list<AuraDispelHandler>::iterator itr = AfterDispel.begin(); itr != AfterDispel.end();  ++itr)
+        if (!entry->HasEffect(SPELL_EFFECT_APPLY_AURA) && !entry->HasAreaAuraEffect())
+            sLog->outError("TSCR: Spell `%u` of script `%s` does not have apply aura effect - handler bound to hook `AfterDispel` of AuraScript won't be executed", entry->Id, m_scriptName->c_str());
+
     for (std::list<EffectApplyHandler>::iterator itr = OnEffectApply.begin(); itr != OnEffectApply.end();  ++itr)
         if (!(*itr).GetAffectedEffectsMask(entry))
             sLog->outError("TSCR: Spell `%u` Effect `%s` of script `%s` did not match dbc effect data - handler bound to hook `OnEffectApply` of AuraScript won't be executed", entry->Id, (*itr).ToString().c_str(), m_scriptName->c_str());
@@ -607,6 +615,16 @@ bool AuraScript::CheckAreaTargetHandler::Call(AuraScript* auraScript, Unit* _tar
     return (auraScript->*pHandlerScript)(_target);
 }
 
+AuraScript::AuraDispelHandler::AuraDispelHandler(AuraDispelFnType _pHandlerScript)
+{
+    pHandlerScript = _pHandlerScript;
+}
+
+void AuraScript::AuraDispelHandler::Call(AuraScript* auraScript, DispelInfo* _dispelInfo)
+{
+    (auraScript->*pHandlerScript)(_dispelInfo);
+}
+
 AuraScript::EffectBase::EffectBase(uint8 _effIndex, uint16 _effName)
     : _SpellScript::EffectAuraNameCheck(_effName), _SpellScript::EffectHook(_effIndex)
 {
diff --git a/src/server/game/Spells/SpellScript.h b/src/server/game/Spells/SpellScript.h
index a1d8e65..945a626 100755
--- a/src/server/game/Spells/SpellScript.h
+++ b/src/server/game/Spells/SpellScript.h
@@ -385,6 +385,8 @@ enum AuraScriptHookType
     AURA_SCRIPT_HOOK_EFFECT_MANASHIELD,
     AURA_SCRIPT_HOOK_EFFECT_AFTER_MANASHIELD,
     AURA_SCRIPT_HOOK_CHECK_AREA_TARGET,
+    AURA_SCRIPT_HOOK_DISPEL,
+    AURA_SCRIPT_HOOK_AFTER_DISPEL,
     /*AURA_SCRIPT_HOOK_APPLY,
     AURA_SCRIPT_HOOK_REMOVE, */
 };
@@ -400,6 +402,7 @@ class AuraScript : public _SpellScript
 
     #define AURASCRIPT_FUNCTION_TYPE_DEFINES(CLASSNAME) \
         typedef bool(CLASSNAME::*AuraCheckAreaTargetFnType)(Unit* target); \
+        typedef void(CLASSNAME::*AuraDispelFnType)(DispelInfo* dispelInfo); \
         typedef void(CLASSNAME::*AuraEffectApplicationModeFnType)(AuraEffect const*, AuraEffectHandleModes); \
         typedef void(CLASSNAME::*AuraEffectPeriodicFnType)(AuraEffect const*); \
         typedef void(CLASSNAME::*AuraEffectUpdatePeriodicFnType)(AuraEffect*); \
@@ -418,6 +421,14 @@ class AuraScript : public _SpellScript
             private:
                 AuraCheckAreaTargetFnType pHandlerScript;
         };
+        class AuraDispelHandler
+        {
+            public:
+                AuraDispelHandler(AuraDispelFnType pHandlerScript);
+                void Call(AuraScript* auraScript, DispelInfo* dispelInfo);
+            private:
+                AuraDispelFnType pHandlerScript;
+        };
         class EffectBase : public  _SpellScript::EffectAuraNameCheck, public _SpellScript::EffectHook
         {
             public:
@@ -493,6 +504,7 @@ class AuraScript : public _SpellScript
 
         #define AURASCRIPT_FUNCTION_CAST_DEFINES(CLASSNAME) \
         class CheckAreaTargetFunction : public AuraScript::CheckAreaTargetHandler { public: CheckAreaTargetFunction(AuraCheckAreaTargetFnType _pHandlerScript) : AuraScript::CheckAreaTargetHandler((AuraScript::AuraCheckAreaTargetFnType)_pHandlerScript) {} }; \
+        class AuraDispelFunction : public AuraScript::AuraDispelHandler { public: AuraDispelFunction(AuraDispelFnType _pHandlerScript) : AuraScript::AuraDispelHandler((AuraScript::AuraDispelFnType)_pHandlerScript) {} }; \
         class EffectPeriodicHandlerFunction : public AuraScript::EffectPeriodicHandler { public: EffectPeriodicHandlerFunction(AuraEffectPeriodicFnType _pEffectHandlerScript, uint8 _effIndex, uint16 _effName) : AuraScript::EffectPeriodicHandler((AuraScript::AuraEffectPeriodicFnType)_pEffectHandlerScript, _effIndex, _effName) {} }; \
         class EffectUpdatePeriodicHandlerFunction : public AuraScript::EffectUpdatePeriodicHandler { public: EffectUpdatePeriodicHandlerFunction(AuraEffectUpdatePeriodicFnType _pEffectHandlerScript, uint8 _effIndex, uint16 _effName) : AuraScript::EffectUpdatePeriodicHandler((AuraScript::AuraEffectUpdatePeriodicFnType)_pEffectHandlerScript, _effIndex, _effName) {} }; \
         class EffectCalcAmountHandlerFunction : public AuraScript::EffectCalcAmountHandler { public: EffectCalcAmountHandlerFunction(AuraEffectCalcAmountFnType _pEffectHandlerScript, uint8 _effIndex, uint16 _effName) : AuraScript::EffectCalcAmountHandler((AuraScript::AuraEffectCalcAmountFnType)_pEffectHandlerScript, _effIndex, _effName) {} }; \
@@ -540,6 +552,17 @@ class AuraScript : public _SpellScript
         // where function is: bool function (Unit* target);
         HookList<CheckAreaTargetHandler> DoCheckAreaTarget;
         #define AuraCheckAreaTargetFn(F) CheckAreaTargetFunction(&F)
+
+        // executed when aura is dispelled by a unit
+        // example: OnDispel += AuraDispelFn(class::function);
+        // where function is: void function (DispelInfo* dispelInfo);
+        HookList<AuraDispelHandler> OnDispel;
+        // executed after aura is dispelled by a unit
+        // example: AfterDispel += AuraDispelFn(class::function);
+        // where function is: void function (DispelInfo* dispelInfo);
+        HookList<AuraDispelHandler> AfterDispel;
+        #define AuraDispelFn(F) AuraDispelFunction(&F)
+
         // executed when aura effect is applied with specified mode to target
         // should be used when when effect handler preventing/replacing is needed, do not use this hook for triggering spellcasts/removing auras etc - may be unsafe
         // example: OnEffectApply += AuraEffectApplyFn(class::function, EffectIndexSpecifier, EffectAuraNameSpecifier, AuraEffectHandleModes);
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index d87da4c..426a93f 100755
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -1192,8 +1192,6 @@ void World::LoadConfigSettings(bool reload)
     sScriptMgr->OnConfigLoad(reload);
 }
 
-extern void LoadGameObjectModelList();
-
 /// Initialize the World
 void World::SetInitialWorldSettings()
 {
@@ -1272,9 +1270,6 @@ void World::SetInitialWorldSettings()
     sLog->outString("Loading spell custom attributes...");
     sSpellMgr->LoadSpellCustomAttr();
 
-    sLog->outString("Loading GameObject models...");
-    LoadGameObjectModelList();
-    
     sLog->outString("Loading Script Names...");
     sObjectMgr->LoadScriptNames();
 
diff --git a/src/server/scripts/CMakeLists.txt b/src/server/scripts/CMakeLists.txt
index 9195a60..56e63af 100644
--- a/src/server/scripts/CMakeLists.txt
+++ b/src/server/scripts/CMakeLists.txt
@@ -52,7 +52,6 @@ message("")
 
 include_directories(
   ${CMAKE_BINARY_DIR}
-  ${CMAKE_SOURCE_DIR}/dep/g3dlite/include
   ${CMAKE_SOURCE_DIR}/dep/SFMT
   ${CMAKE_SOURCE_DIR}/dep/mersennetwister
   ${CMAKE_SOURCE_DIR}/dep/zlib
@@ -70,7 +69,6 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/shared/Utilities
   ${CMAKE_SOURCE_DIR}/src/server/collision
   ${CMAKE_SOURCE_DIR}/src/server/collision/Management
-  ${CMAKE_SOURCE_DIR}/src/server/collision/Models
   ${CMAKE_SOURCE_DIR}/src/server/shared
   ${CMAKE_SOURCE_DIR}/src/server/shared/Database
   ${CMAKE_SOURCE_DIR}/src/server/game/Accounts
diff --git a/src/server/scripts/Commands/cs_debug.cpp b/src/server/scripts/Commands/cs_debug.cpp
index 73e6b0a..311c658 100644
--- a/src/server/scripts/Commands/cs_debug.cpp
+++ b/src/server/scripts/Commands/cs_debug.cpp
@@ -88,7 +88,6 @@ public:
             { "update",         SEC_ADMINISTRATOR,  false, &HandleDebugUpdateCommand,          "", NULL },
             { "itemexpire",     SEC_ADMINISTRATOR,  false, &HandleDebugItemExpireCommand,      "", NULL },
             { "areatriggers",   SEC_ADMINISTRATOR,  false, &HandleDebugAreaTriggersCommand,    "", NULL },
-            { "los",            SEC_MODERATOR,      false, &HandleDebugLoSCommand,             "", NULL },
             { NULL,             0,                  false, NULL,                               "", NULL }
         };
         static ChatCommand commandTable[] =
@@ -1041,13 +1040,6 @@ public:
         handler->GetSession()->GetPlayer()->HandleEmoteCommand(animId);
         return true;
     }
-    
-    static bool HandleDebugLoSCommand(ChatHandler* handler, char const* args)
-    {
-        if (Unit* unit = handler->getSelectedUnit())
-            handler->PSendSysMessage("Unit %s (GuidLow: %u) is %sin LoS", unit->GetName(), unit->GetGUIDLow(), handler->GetSession()->GetPlayer()->IsWithinLOSInMap(unit) ? "" : "not ");
-        return true;
-    }
 
     static bool HandleDebugSetAuraStateCommand(ChatHandler* handler, char const* args)
     {
diff --git a/src/server/scripts/Commands/cs_gps.cpp b/src/server/scripts/Commands/cs_gps.cpp
index 589ed4a..8f15f8c 100644
--- a/src/server/scripts/Commands/cs_gps.cpp
+++ b/src/server/scripts/Commands/cs_gps.cpp
@@ -87,8 +87,8 @@ public:
         Map2ZoneCoordinates(zoneX, zoneY, zoneId);
 
         Map const* map = object->GetMap();
-        float groundZ = map->GetHeight(object->GetPhaseMask(), object->GetPositionX(), object->GetPositionY(), MAX_HEIGHT);
-        float floorZ = map->GetHeight(object->GetPhaseMask(), object->GetPositionX(), object->GetPositionY(), object->GetPositionZ());
+        float groundZ = map->GetHeight(object->GetPositionX(), object->GetPositionY(), MAX_HEIGHT);
+        float floorZ = map->GetHeight(object->GetPositionX(), object->GetPositionY(), object->GetPositionZ());
 
         GridCoord gridCoord = Trinity::ComputeGridCoord(object->GetPositionX(), object->GetPositionY());
 
diff --git a/src/server/scripts/EasternKingdoms/BlackrockDepths/blackrock_depths.cpp b/src/server/scripts/EasternKingdoms/BlackrockDepths/blackrock_depths.cpp
index 8eff3e3..17cf775 100644
--- a/src/server/scripts/EasternKingdoms/BlackrockDepths/blackrock_depths.cpp
+++ b/src/server/scripts/EasternKingdoms/BlackrockDepths/blackrock_depths.cpp
@@ -1238,10 +1238,10 @@ public:
                 me->HandleEmoteCommand(EMOTE_ONESHOT_KICK);
                 break;
             case 2:
-                me->HandleEmoteCommand(EMOTE_ONESHOT_ATTACKUNARMED);
+                me->HandleEmoteCommand(EMOTE_ONESHOT_ATTACK_UNARMED);
                 break;
             case 3:
-                me->HandleEmoteCommand(EMOTE_ONESHOT_ATTACKUNARMED);
+                me->HandleEmoteCommand(EMOTE_ONESHOT_ATTACK_UNARMED);
                 break;
             case 4:
                 me->HandleEmoteCommand(EMOTE_ONESHOT_KICK);
diff --git a/src/server/scripts/EasternKingdoms/BlackrockDepths/boss_tomb_of_seven.cpp b/src/server/scripts/EasternKingdoms/BlackrockDepths/boss_tomb_of_seven.cpp
index 6b47416..3c8d5fc 100644
--- a/src/server/scripts/EasternKingdoms/BlackrockDepths/boss_tomb_of_seven.cpp
+++ b/src/server/scripts/EasternKingdoms/BlackrockDepths/boss_tomb_of_seven.cpp
@@ -117,7 +117,7 @@ public:
                 player->CLOSE_GOSSIP_MENU();
                 //start event here
                 creature->setFaction(FACTION_HOSTILE);
-                creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                 creature->AI()->AttackStart(player);
                 InstanceScript* instance = creature->GetInstanceScript();
                 if (instance)
@@ -165,7 +165,7 @@ public:
             me->setFaction(FACTION_FRIEND);
 
             // was set before event start, so set again
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
 
             if (instance)
             {
diff --git a/src/server/scripts/EasternKingdoms/BlackrockDepths/instance_blackrock_depths.cpp b/src/server/scripts/EasternKingdoms/BlackrockDepths/instance_blackrock_depths.cpp
index f87d87d..2ef3ef4 100644
--- a/src/server/scripts/EasternKingdoms/BlackrockDepths/instance_blackrock_depths.cpp
+++ b/src/server/scripts/EasternKingdoms/BlackrockDepths/instance_blackrock_depths.cpp
@@ -375,7 +375,7 @@ public:
                 if (Creature* boss = instance->GetCreature(TombBossGUIDs[TombEventCounter]))
                 {
                     boss->setFaction(FACTION_HOSTILE);
-                    boss->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                    boss->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                     if (Unit* target = boss->SelectNearestTarget(500))
                         boss->AI()->AttackStart(target);
                 }
diff --git a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_drakkisath.cpp b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_drakkisath.cpp
index 442fd02..ff17e98 100644
--- a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_drakkisath.cpp
+++ b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_drakkisath.cpp
@@ -76,7 +76,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_gyth.cpp b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_gyth.cpp
index 0edcdfe..0d8cabc 100644
--- a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_gyth.cpp
+++ b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_gyth.cpp
@@ -105,7 +105,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_halycon.cpp b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_halycon.cpp
index 3a7461f..a944ee6 100644
--- a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_halycon.cpp
+++ b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_halycon.cpp
@@ -82,7 +82,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_highlord_omokk.cpp b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_highlord_omokk.cpp
index 6f5b907..bc9de52 100644
--- a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_highlord_omokk.cpp
+++ b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_highlord_omokk.cpp
@@ -85,7 +85,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_mother_smolderweb.cpp b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_mother_smolderweb.cpp
index cac0746..973ffe7 100644
--- a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_mother_smolderweb.cpp
+++ b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_mother_smolderweb.cpp
@@ -77,7 +77,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_overlord_wyrmthalak.cpp b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_overlord_wyrmthalak.cpp
index 0975b17..b749299 100644
--- a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_overlord_wyrmthalak.cpp
+++ b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_overlord_wyrmthalak.cpp
@@ -101,7 +101,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_pyroguard_emberseer.cpp b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_pyroguard_emberseer.cpp
index 96cc6e7..d76d0d7 100644
--- a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_pyroguard_emberseer.cpp
+++ b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_pyroguard_emberseer.cpp
@@ -74,7 +74,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_quartermaster_zigris.cpp b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_quartermaster_zigris.cpp
index 470d412..4fb7e51 100644
--- a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_quartermaster_zigris.cpp
+++ b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_quartermaster_zigris.cpp
@@ -72,7 +72,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_rend_blackhand.cpp b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_rend_blackhand.cpp
index 70b2a41..ce19a03 100644
--- a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_rend_blackhand.cpp
+++ b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_rend_blackhand.cpp
@@ -73,7 +73,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_shadow_hunter_voshgajin.cpp b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_shadow_hunter_voshgajin.cpp
index 20eefd5..f93466c 100644
--- a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_shadow_hunter_voshgajin.cpp
+++ b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_shadow_hunter_voshgajin.cpp
@@ -74,7 +74,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_the_beast.cpp b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_the_beast.cpp
index 7715227..88a09d5 100644
--- a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_the_beast.cpp
+++ b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_the_beast.cpp
@@ -73,7 +73,7 @@ public:
 
              events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_warmaster_voone.cpp b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_warmaster_voone.cpp
index 9f06c2f..2dc0579 100644
--- a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_warmaster_voone.cpp
+++ b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_warmaster_voone.cpp
@@ -82,7 +82,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/EasternKingdoms/BlackwingLair/boss_victor_nefarius.cpp b/src/server/scripts/EasternKingdoms/BlackwingLair/boss_victor_nefarius.cpp
index 5222270..2c7cd73 100644
--- a/src/server/scripts/EasternKingdoms/BlackwingLair/boss_victor_nefarius.cpp
+++ b/src/server/scripts/EasternKingdoms/BlackwingLair/boss_victor_nefarius.cpp
@@ -351,7 +351,7 @@ public:
 
                         //Teleport self to a hiding spot (this causes errors in the Trinity log but no real issues)
                         DoTeleportTo(HIDE_X, HIDE_Y, HIDE_Z);
-                        me->AddUnitState(UNIT_STAT_FLEEING);
+                        me->AddUnitState(UNIT_STATE_FLEEING);
 
                         //Spawn nef and have him attack a random target
                         Creature* Nefarian = me->SummonCreature(CREATURE_NEFARIAN, NEF_X, NEF_Y, NEF_Z, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 120000);
diff --git a/src/server/scripts/EasternKingdoms/Karazhan/boss_prince_malchezaar.cpp b/src/server/scripts/EasternKingdoms/Karazhan/boss_prince_malchezaar.cpp
index a6d7248..14add92 100644
--- a/src/server/scripts/EasternKingdoms/Karazhan/boss_prince_malchezaar.cpp
+++ b/src/server/scripts/EasternKingdoms/Karazhan/boss_prince_malchezaar.cpp
@@ -393,7 +393,7 @@ public:
                 EnfeebleResetTimer = 0;
             } else EnfeebleResetTimer -= diff;
 
-            if (me->HasUnitState(UNIT_STAT_STUNNED))      // While shifting to phase 2 malchezaar stuns himself
+            if (me->HasUnitState(UNIT_STATE_STUNNED))      // While shifting to phase 2 malchezaar stuns himself
                 return;
 
             if (me->GetUInt64Value(UNIT_FIELD_TARGET) != me->getVictim()->GetGUID())
diff --git a/src/server/scripts/EasternKingdoms/Karazhan/bosses_opera.cpp b/src/server/scripts/EasternKingdoms/Karazhan/bosses_opera.cpp
index a675c35..b15cb7d 100644
--- a/src/server/scripts/EasternKingdoms/Karazhan/bosses_opera.cpp
+++ b/src/server/scripts/EasternKingdoms/Karazhan/bosses_opera.cpp
@@ -655,7 +655,7 @@ public:
         {
             DoScriptText(RAND(SAY_CRONE_AGGRO, SAY_CRONE_AGGRO2), me);
             me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
         }
 
         void JustDied(Unit* /*killer*/)
diff --git a/src/server/scripts/EasternKingdoms/MoltenCore/boss_baron_geddon.cpp b/src/server/scripts/EasternKingdoms/MoltenCore/boss_baron_geddon.cpp
index 3959a01..f792b86 100644
--- a/src/server/scripts/EasternKingdoms/MoltenCore/boss_baron_geddon.cpp
+++ b/src/server/scripts/EasternKingdoms/MoltenCore/boss_baron_geddon.cpp
@@ -80,7 +80,7 @@ class boss_baron_geddon : public CreatureScript
                     return;
                 }
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/EasternKingdoms/MoltenCore/boss_garr.cpp b/src/server/scripts/EasternKingdoms/MoltenCore/boss_garr.cpp
index e1bb48d..a9d32eb 100644
--- a/src/server/scripts/EasternKingdoms/MoltenCore/boss_garr.cpp
+++ b/src/server/scripts/EasternKingdoms/MoltenCore/boss_garr.cpp
@@ -71,7 +71,7 @@ class boss_garr : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/EasternKingdoms/MoltenCore/boss_gehennas.cpp b/src/server/scripts/EasternKingdoms/MoltenCore/boss_gehennas.cpp
index 9bbbb08..7261bbf 100644
--- a/src/server/scripts/EasternKingdoms/MoltenCore/boss_gehennas.cpp
+++ b/src/server/scripts/EasternKingdoms/MoltenCore/boss_gehennas.cpp
@@ -68,7 +68,7 @@ class boss_gehennas : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/EasternKingdoms/MoltenCore/boss_golemagg.cpp b/src/server/scripts/EasternKingdoms/MoltenCore/boss_golemagg.cpp
index 1ba143a..84e9957 100644
--- a/src/server/scripts/EasternKingdoms/MoltenCore/boss_golemagg.cpp
+++ b/src/server/scripts/EasternKingdoms/MoltenCore/boss_golemagg.cpp
@@ -91,7 +91,7 @@ class boss_golemagg : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/EasternKingdoms/MoltenCore/boss_lucifron.cpp b/src/server/scripts/EasternKingdoms/MoltenCore/boss_lucifron.cpp
index 5395b46..e3e0400 100644
--- a/src/server/scripts/EasternKingdoms/MoltenCore/boss_lucifron.cpp
+++ b/src/server/scripts/EasternKingdoms/MoltenCore/boss_lucifron.cpp
@@ -68,7 +68,7 @@ class boss_lucifron : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/EasternKingdoms/MoltenCore/boss_magmadar.cpp b/src/server/scripts/EasternKingdoms/MoltenCore/boss_magmadar.cpp
index 5551531..65a630a 100644
--- a/src/server/scripts/EasternKingdoms/MoltenCore/boss_magmadar.cpp
+++ b/src/server/scripts/EasternKingdoms/MoltenCore/boss_magmadar.cpp
@@ -80,7 +80,7 @@ class boss_magmadar : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/EasternKingdoms/MoltenCore/boss_majordomo_executus.cpp b/src/server/scripts/EasternKingdoms/MoltenCore/boss_majordomo_executus.cpp
index d324150..862a980 100644
--- a/src/server/scripts/EasternKingdoms/MoltenCore/boss_majordomo_executus.cpp
+++ b/src/server/scripts/EasternKingdoms/MoltenCore/boss_majordomo_executus.cpp
@@ -116,7 +116,7 @@ class boss_majordomo : public CreatureScript
                         return;
                     }
 
-                    if (me->HasUnitState(UNIT_STAT_CASTING))
+                    if (me->HasUnitState(UNIT_STATE_CASTING))
                         return;
 
                     if (HealthBelowPct(50))
diff --git a/src/server/scripts/EasternKingdoms/MoltenCore/boss_shazzrah.cpp b/src/server/scripts/EasternKingdoms/MoltenCore/boss_shazzrah.cpp
index 97c89f1..f696ec5 100644
--- a/src/server/scripts/EasternKingdoms/MoltenCore/boss_shazzrah.cpp
+++ b/src/server/scripts/EasternKingdoms/MoltenCore/boss_shazzrah.cpp
@@ -73,7 +73,7 @@ class boss_shazzrah : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/EasternKingdoms/MoltenCore/boss_sulfuron_harbinger.cpp b/src/server/scripts/EasternKingdoms/MoltenCore/boss_sulfuron_harbinger.cpp
index ccefca7..9f511c1 100644
--- a/src/server/scripts/EasternKingdoms/MoltenCore/boss_sulfuron_harbinger.cpp
+++ b/src/server/scripts/EasternKingdoms/MoltenCore/boss_sulfuron_harbinger.cpp
@@ -84,7 +84,7 @@ class boss_sulfuron : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -169,7 +169,7 @@ class mob_flamewaker_priest : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/EasternKingdoms/ScarletEnclave/chapter1.cpp b/src/server/scripts/EasternKingdoms/ScarletEnclave/chapter1.cpp
index a7d1c3a..a2c8a89 100644
--- a/src/server/scripts/EasternKingdoms/ScarletEnclave/chapter1.cpp
+++ b/src/server/scripts/EasternKingdoms/ScarletEnclave/chapter1.cpp
@@ -125,7 +125,7 @@ public:
             phase = PHASE_CHAINED;
             events.Reset();
             me->setFaction(7);
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
             me->SetUInt32Value(UNIT_FIELD_BYTES_1, 8);
             me->LoadEquipment(0, true);
         }
@@ -230,7 +230,7 @@ public:
                     else
                     {
                         me->setFaction(14);
-                        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                         phase = PHASE_ATTACKING;
 
                         if (Player* target = Unit::GetPlayer(*me, playerGUID))
@@ -378,7 +378,7 @@ public:
                     return true;
             }
 
-            creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
             creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_UNK_15);
 
             int32 uiSayId = rand()% (sizeof(m_auiRandomSay)/sizeof(int32));
@@ -877,7 +877,7 @@ public:
     {
         npc_scarlet_miner_cartAI(Creature* c) : PassiveAI(c), minerGUID(0)
         {
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
             me->SetDisplayId(me->GetCreatureInfo()->Modelid1); // Modelid2 is a horse.
         }
 
diff --git a/src/server/scripts/EasternKingdoms/ScarletEnclave/chapter2.cpp b/src/server/scripts/EasternKingdoms/ScarletEnclave/chapter2.cpp
index 1fb8287..4583a33 100644
--- a/src/server/scripts/EasternKingdoms/ScarletEnclave/chapter2.cpp
+++ b/src/server/scripts/EasternKingdoms/ScarletEnclave/chapter2.cpp
@@ -264,7 +264,7 @@ public:
                 m_uiValrothGUID = summoned->GetGUID();
 
             summoned->AddThreat(me, 0.0f);
-            summoned->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            summoned->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
         }
 
         void SummonAcolyte(uint32 uiAmount)
@@ -605,7 +605,7 @@ public:
             ExecuteSpeech_Counter = 0;
             PlayerGUID = 0;
 
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
         }
 
         bool MeetQuestCondition(Unit* player)
@@ -702,7 +702,7 @@ public:
                                 case 9:
                                     DoScriptText(SAY_EXEC_TIME_6, me, player);
                                     me->SetStandState(UNIT_STAND_STATE_KNEEL);
-                                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                                     break;
                                 case 10: DoScriptText(SAY_EXEC_WAITING, me, player); break;
                                 case 11:
@@ -730,7 +730,7 @@ public:
                                 case 9:
                                     DoScriptText(SAY_EXEC_TIME_8, me, player);
                                     me->SetStandState(UNIT_STAND_STATE_KNEEL);
-                                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                                     break;
                                 case 10: DoScriptText(SAY_EXEC_WAITING, me, player); break;
                                 case 11:
@@ -758,7 +758,7 @@ public:
                                 case 9:
                                     DoScriptText(SAY_EXEC_TIME_3, me, player);
                                     me->SetStandState(UNIT_STAND_STATE_KNEEL);
-                                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                                     break;
                                 case 10: DoScriptText(SAY_EXEC_WAITING, me, player); break;
                                 case 11:
@@ -786,7 +786,7 @@ public:
                                 case 9:
                                     DoScriptText(SAY_EXEC_TIME_7, me, player);
                                     me->SetStandState(UNIT_STAND_STATE_KNEEL);
-                                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                                     break;
                                 case 10: DoScriptText(SAY_EXEC_WAITING, me, player); break;
                                 case 11:
@@ -814,7 +814,7 @@ public:
                                 case 9:
                                     DoScriptText(SAY_EXEC_TIME_4, me, player);
                                     me->SetStandState(UNIT_STAND_STATE_KNEEL);
-                                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                                     break;
                                 case 10: DoScriptText(SAY_EXEC_WAITING, me, player); break;
                                 case 11:
@@ -842,7 +842,7 @@ public:
                                 case 9:
                                     DoScriptText(SAY_EXEC_TIME_9, me, player);
                                     me->SetStandState(UNIT_STAND_STATE_KNEEL);
-                                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                                     break;
                                 case 10: DoScriptText(SAY_EXEC_WAITING, me, player); break;
                                 case 11:
@@ -870,7 +870,7 @@ public:
                                 case 9:
                                     DoScriptText(SAY_EXEC_TIME_5, me, player);
                                     me->SetStandState(UNIT_STAND_STATE_KNEEL);
-                                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                                     break;
                                 case 10: DoScriptText(SAY_EXEC_WAITING, me, player); break;
                                 case 11:
@@ -898,7 +898,7 @@ public:
                                 case 9:
                                     DoScriptText(SAY_EXEC_TIME_10, me, player);
                                     me->SetStandState(UNIT_STAND_STATE_KNEEL);
-                                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                                     break;
                                 case 10: DoScriptText(SAY_EXEC_WAITING, me, player); break;
                                 case 11:
@@ -926,7 +926,7 @@ public:
                                 case 9:
                                     DoScriptText(SAY_EXEC_TIME_1, me, player);
                                     me->SetStandState(UNIT_STAND_STATE_KNEEL);
-                                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                                     break;
                                 case 10: DoScriptText(SAY_EXEC_WAITING, me, player); break;
                                 case 11:
@@ -954,7 +954,7 @@ public:
                                 case 9:
                                     DoScriptText(SAY_EXEC_TIME_2, me, player);
                                     me->SetStandState(UNIT_STAND_STATE_KNEEL);
-                                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                                     break;
                                 case 10: DoScriptText(SAY_EXEC_WAITING, me, player); break;
                                 case 11:
diff --git a/src/server/scripts/EasternKingdoms/ScarletEnclave/the_scarlet_enclave.cpp b/src/server/scripts/EasternKingdoms/ScarletEnclave/the_scarlet_enclave.cpp
index febe897..9512d66 100644
--- a/src/server/scripts/EasternKingdoms/ScarletEnclave/the_scarlet_enclave.cpp
+++ b/src/server/scripts/EasternKingdoms/ScarletEnclave/the_scarlet_enclave.cpp
@@ -91,7 +91,7 @@ public:
                     case 2:
                         if (!player->isRessurectRequested())
                         {
-                            me->HandleEmoteCommand(EMOTE_ONESHOT_CUSTOMSPELL01);
+                            me->HandleEmoteCommand(EMOTE_ONESHOT_CUSTOM_SPELL_01);
                             DoCast(player, SPELL_REVIVE, true);
                             me->MonsterWhisper(VALK_WHISPER, player->GetGUID());
                         }
diff --git a/src/server/scripts/EasternKingdoms/ShadowfangKeep/instance_shadowfang_keep.cpp b/src/server/scripts/EasternKingdoms/ShadowfangKeep/instance_shadowfang_keep.cpp
index df369bb..57b902a 100644
--- a/src/server/scripts/EasternKingdoms/ShadowfangKeep/instance_shadowfang_keep.cpp
+++ b/src/server/scripts/EasternKingdoms/ShadowfangKeep/instance_shadowfang_keep.cpp
@@ -252,7 +252,7 @@ public:
                     {
                         case 1:
                             summon = pArchmage->SummonCreature(pArchmage->GetEntry(), SpawnLocation[4], TEMPSUMMON_TIMED_DESPAWN, 10000);
-                            summon->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                            summon->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                             summon->SetReactState(REACT_DEFENSIVE);
                             summon->CastSpell(summon, SPELL_ASHCROMBE_TELEPORT, true);
                             DoScriptText(SAY_ARCHMAGE, summon);
diff --git a/src/server/scripts/EasternKingdoms/SunwellPlateau/boss_kiljaeden.cpp b/src/server/scripts/EasternKingdoms/SunwellPlateau/boss_kiljaeden.cpp
index cb7f0de..337eea1 100644
--- a/src/server/scripts/EasternKingdoms/SunwellPlateau/boss_kiljaeden.cpp
+++ b/src/server/scripts/EasternKingdoms/SunwellPlateau/boss_kiljaeden.cpp
@@ -425,7 +425,7 @@ public:
         {
             me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
             me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-            me->AddUnitState(UNIT_STAT_STUNNED);
+            me->AddUnitState(UNIT_STATE_STUNNED);
 
             ScriptedAI::InitializeAI();
         }
diff --git a/src/server/scripts/EasternKingdoms/SunwellPlateau/boss_muru.cpp b/src/server/scripts/EasternKingdoms/SunwellPlateau/boss_muru.cpp
index 2004eec..9b5d941 100644
--- a/src/server/scripts/EasternKingdoms/SunwellPlateau/boss_muru.cpp
+++ b/src/server/scripts/EasternKingdoms/SunwellPlateau/boss_muru.cpp
@@ -151,7 +151,7 @@ public:
                     summoned->CastSpell(summoned, SPELL_DARKFIEND_VISUAL, false);
                     break;
                 case CREATURE_DARKNESS:
-                    summoned->AddUnitState(UNIT_STAT_STUNNED);
+                    summoned->AddUnitState(UNIT_STATE_STUNNED);
                     float x, y, z, o;
                     summoned->GetHomePosition(x, y, z, o);
                     me->SummonCreature(CREATURE_DARK_FIENDS, x, y, z, o, TEMPSUMMON_CORPSE_DESPAWN, 0);
@@ -399,7 +399,7 @@ public:
             InAction = false;
             SummonSentinel = false;
 
-            me->AddUnitState(UNIT_STAT_STUNNED);
+            me->AddUnitState(UNIT_STATE_STUNNED);
 
             Summons.DespawnAll();
         }
@@ -472,7 +472,7 @@ public:
             WaitTimer = 2000;
             InAction = false;
 
-            me->AddUnitState(UNIT_STAT_STUNNED);
+            me->AddUnitState(UNIT_STATE_STUNNED);
         }
 
         void SpellHit(Unit* /*caster*/, const SpellInfo* Spell)
@@ -491,7 +491,7 @@ public:
             {
                 if (!InAction)
                 {
-                    me->ClearUnitState(UNIT_STAT_STUNNED);
+                    me->ClearUnitState(UNIT_STATE_STUNNED);
                     DoCastAOE(SPELL_DARKFIEND_SKIN, false);
                     AttackStart(SelectTarget(SELECT_TARGET_RANDOM, 0, 100, true));
                     InAction = true;
@@ -599,7 +599,7 @@ public:
             SpellTimer = 5000;
             Phase = 0;
 
-            me->AddUnitState(UNIT_STAT_STUNNED);
+            me->AddUnitState(UNIT_STATE_STUNNED);
             DoCastAOE(SPELL_BLACKHOLE_SPAWN, true);
         }
 
@@ -611,7 +611,7 @@ public:
                 switch (NeedForAHack)
                 {
                     case 0:
-                        me->ClearUnitState(UNIT_STAT_STUNNED);
+                        me->ClearUnitState(UNIT_STATE_STUNNED);
                         DoCastAOE(SPELL_BLACKHOLE_GROW, false);
                         if (Victim)
                             AttackStart(Victim);
diff --git a/src/server/scripts/EasternKingdoms/ZulGurub/boss_venoxis.cpp b/src/server/scripts/EasternKingdoms/ZulGurub/boss_venoxis.cpp
index 3cb0cc2..bd6f6ec 100644
--- a/src/server/scripts/EasternKingdoms/ZulGurub/boss_venoxis.cpp
+++ b/src/server/scripts/EasternKingdoms/ZulGurub/boss_venoxis.cpp
@@ -173,7 +173,7 @@ class boss_venoxis : public CreatureScript
                 events.Update(diff);
 
                 // return back to main code if we're still casting
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/EasternKingdoms/tirisfal_glades.cpp b/src/server/scripts/EasternKingdoms/tirisfal_glades.cpp
index 6cbf28f..0d72ab6 100644
--- a/src/server/scripts/EasternKingdoms/tirisfal_glades.cpp
+++ b/src/server/scripts/EasternKingdoms/tirisfal_glades.cpp
@@ -53,7 +53,7 @@ public:
         if (quest->GetQuestId() == QUEST_590)
         {
             creature->setFaction(FACTION_HOSTILE);
-            creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
             CAST_AI(npc_calvin_montague::npc_calvin_montagueAI, creature->AI())->AttackStart(player);
         }
         return true;
@@ -80,8 +80,8 @@ public:
 
             me->RestoreFaction();
 
-            if (!me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE))
-                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            if (!me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC))
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
         }
 
         void EnterCombat(Unit* /*who*/) {}
@@ -101,7 +101,7 @@ public:
                 uiDamage = 0;
 
                 me->RestoreFaction();
-                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                 me->CombatStop(true);
 
                 m_uiPhase = 1;
diff --git a/src/server/scripts/EasternKingdoms/westfall.cpp b/src/server/scripts/EasternKingdoms/westfall.cpp
index 34cc855..271e1d9 100644
--- a/src/server/scripts/EasternKingdoms/westfall.cpp
+++ b/src/server/scripts/EasternKingdoms/westfall.cpp
@@ -110,7 +110,7 @@ public:
                 case 4:
                     SetEquipmentSlots(false, EQUIP_NO_CHANGE, EQUIP_NO_CHANGE, EQUIP_ID_RIFLE);
                     me->SetSheath(SHEATH_STATE_RANGED);
-                    me->HandleEmoteCommand(EMOTE_STATE_USESTANDING_NOSHEATHE);
+                    me->HandleEmoteCommand(EMOTE_STATE_USE_STANDING_NO_SHEATHE);
                     break;
                 case 7:
                     me->SummonCreature(NPC_DEFIAS_RAIDER, -11450.836f, 1569.755f, 54.267f, 4.230f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000);
@@ -141,7 +141,7 @@ public:
                 case 13:
                     SetEquipmentSlots(true);
                     me->SetSheath(SHEATH_STATE_UNARMED);
-                    me->HandleEmoteCommand(EMOTE_STATE_USESTANDING_NOSHEATHE);
+                    me->HandleEmoteCommand(EMOTE_STATE_USE_STANDING_NO_SHEATHE);
                     break;
                 case 17:
                     player->GroupEventHappens(QUEST_TOME_VALOR, me);
diff --git a/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/hyjal_trash.cpp b/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/hyjal_trash.cpp
index 3a96e64..65bc8f6 100644
--- a/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/hyjal_trash.cpp
+++ b/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/hyjal_trash.cpp
@@ -678,7 +678,7 @@ public:
             }
             if (i == LastOverronPos && IsOverrun)
             {
-                me->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_ONESHOT_ATTACKUNARMED);
+                me->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_ONESHOT_ATTACK_UNARMED);
                 if ((faction == 0 && LastOverronPos == 17) || (faction == 1 && LastOverronPos == 21))
                 {
                     me->setDeathState(DEAD);
@@ -1200,7 +1200,7 @@ public:
 
             float x, y, z;
             me->GetPosition(x, y, z);
-            z = me->GetMap()->GetHeight(me->GetPhaseMask(), x, y, z);
+            z = me->GetMap()->GetHeight(x, y, z);
             me->GetMotionMaster()->MovePoint(0, x, y, z);
             me->SetPosition(x, y, z, 0);
         }
@@ -1319,7 +1319,7 @@ public:
         {
             float x, y, z;
             me->GetPosition(x, y, z);
-            z = me->GetMap()->GetHeight(me->GetPhaseMask(), x, y, z);
+            z = me->GetMap()->GetHeight(x, y, z);
             me->GetMotionMaster()->MovePoint(0, x, y, z);
             me->SetPosition(x, y, z, 0);
             hyjal_trashAI::JustDied(victim);
diff --git a/src/server/scripts/Kalimdor/CavernsOfTime/CullingOfStratholme/culling_of_stratholme.cpp b/src/server/scripts/Kalimdor/CavernsOfTime/CullingOfStratholme/culling_of_stratholme.cpp
index 6cdb794..9518abd 100644
--- a/src/server/scripts/Kalimdor/CavernsOfTime/CullingOfStratholme/culling_of_stratholme.cpp
+++ b/src/server/scripts/Kalimdor/CavernsOfTime/CullingOfStratholme/culling_of_stratholme.cpp
@@ -414,7 +414,7 @@ public:
                 if (Creature* temp = me->SummonCreature((uint32)RiftAndSpawnsLocations[i][0], RiftAndSpawnsLocations[timeRiftID][1], RiftAndSpawnsLocations[timeRiftID][2], RiftAndSpawnsLocations[timeRiftID][3], RiftAndSpawnsLocations[timeRiftID][4], TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 900000))
                 {
                     guidVector[i-timeRiftID-1] = temp->GetGUID();
-                    temp->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_PASSIVE);
+                    temp->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_IMMUNE_TO_NPC);
                     temp->SetReactState(REACT_PASSIVE);
                     temp->GetMotionMaster()->MovePoint(0, RiftAndSpawnsLocations[i][1], RiftAndSpawnsLocations[i][2], RiftAndSpawnsLocations[i][3]);
                     if ((uint32)RiftAndSpawnsLocations[i][0] == NPC_EPOCH)
@@ -1003,7 +1003,7 @@ public:
                             {
                                 pDisguised2->UpdateEntry(NPC_INFINITE_HUNTER, 0);
                                 //Make them unattackable
-                                pDisguised2->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_PASSIVE);
+                                pDisguised2->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_IMMUNE_TO_NPC);
                                 pDisguised2->SetReactState(REACT_PASSIVE);
                             }
                             JumpToNextStep(2000);
@@ -1013,7 +1013,7 @@ public:
                             {
                                 pDisguised1->UpdateEntry(NPC_INFINITE_AGENT, 0);
                                 //Make them unattackable
-                                pDisguised1->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_PASSIVE);
+                                pDisguised1->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_IMMUNE_TO_NPC);
                                 pDisguised1->SetReactState(REACT_PASSIVE);
                             }
                             JumpToNextStep(2000);
@@ -1023,7 +1023,7 @@ public:
                             {
                                 pDisguised0->UpdateEntry(NPC_INFINITE_ADVERSARY, 0);
                                 //Make them unattackable
-                                pDisguised0->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_PASSIVE);
+                                pDisguised0->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_IMMUNE_TO_NPC);
                                 pDisguised0->SetReactState(REACT_PASSIVE);
                             }
                             JumpToNextStep(2000);
@@ -1037,7 +1037,7 @@ public:
                             for (uint32 i = 0; i< ENCOUNTER_DRACONIAN_NUMBER; ++i)
                                 if (Creature* temp = Unit::GetCreature(*me, uiInfiniteDraconianGUID[i]))
                                 {
-                                    temp->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_PASSIVE);
+                                    temp->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_IMMUNE_TO_NPC);
                                     temp->SetReactState(REACT_AGGRESSIVE);
                                 }
                             JumpToNextStep(5000);
@@ -1095,7 +1095,7 @@ public:
                                     if (Creature* pEpoch = Unit::GetCreature(*me, uiEpochGUID))
                                     {
                                         //Make Epoch attackable
-                                        pEpoch->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_PASSIVE);
+                                        pEpoch->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_IMMUNE_TO_NPC);
                                         pEpoch->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
                                         pEpoch->SetReactState(REACT_AGGRESSIVE);
                                     }
@@ -1150,7 +1150,7 @@ public:
                         case 87:
                             if (Creature* pMalganis = Unit::GetCreature(*me, uiMalganisGUID))
                             {
-                                pMalganis->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_UNK_6 | UNIT_FLAG_PASSIVE | UNIT_FLAG_UNK_15);
+                                pMalganis->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_UNK_6 | UNIT_FLAG_IMMUNE_TO_NPC | UNIT_FLAG_UNK_15);
                                 pMalganis->SetReactState(REACT_AGGRESSIVE);
                             }
                             JumpToNextStep(1000);
diff --git a/src/server/scripts/Kalimdor/RuinsOfAhnQiraj/boss_kurinnaxx.cpp b/src/server/scripts/Kalimdor/RuinsOfAhnQiraj/boss_kurinnaxx.cpp
index b295780..36a1ff1 100644
--- a/src/server/scripts/Kalimdor/RuinsOfAhnQiraj/boss_kurinnaxx.cpp
+++ b/src/server/scripts/Kalimdor/RuinsOfAhnQiraj/boss_kurinnaxx.cpp
@@ -75,7 +75,7 @@ class boss_kurinnaxx : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Kalimdor/RuinsOfAhnQiraj/boss_moam.cpp b/src/server/scripts/Kalimdor/RuinsOfAhnQiraj/boss_moam.cpp
index 3dc7660..a290b07 100644
--- a/src/server/scripts/Kalimdor/RuinsOfAhnQiraj/boss_moam.cpp
+++ b/src/server/scripts/Kalimdor/RuinsOfAhnQiraj/boss_moam.cpp
@@ -127,7 +127,7 @@ class boss_moam : public CreatureScript
                 }
 
                 // Messing up mana-drain channel
-                //if (me->HasUnitState(UNIT_STAT_CASTING))
+                //if (me->HasUnitState(UNIT_STATE_CASTING))
                 //    return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Kalimdor/RuinsOfAhnQiraj/boss_rajaxx.cpp b/src/server/scripts/Kalimdor/RuinsOfAhnQiraj/boss_rajaxx.cpp
index ea13702..afa8eff 100644
--- a/src/server/scripts/Kalimdor/RuinsOfAhnQiraj/boss_rajaxx.cpp
+++ b/src/server/scripts/Kalimdor/RuinsOfAhnQiraj/boss_rajaxx.cpp
@@ -93,7 +93,7 @@ class boss_rajaxx : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Kalimdor/TempleOfAhnQiraj/boss_skeram.cpp b/src/server/scripts/Kalimdor/TempleOfAhnQiraj/boss_skeram.cpp
index d56608b..7f3c19a 100644
--- a/src/server/scripts/Kalimdor/TempleOfAhnQiraj/boss_skeram.cpp
+++ b/src/server/scripts/Kalimdor/TempleOfAhnQiraj/boss_skeram.cpp
@@ -38,7 +38,7 @@ EndScriptData */
 
 #define SPELL_ARCANE_EXPLOSION      25679
 #define SPELL_EARTH_SHOCK           26194
-#define SPELL_TRUE_FULFILLMENT4     26526
+#define SPELL_TRUE_FULFILLMENT      785
 #define SPELL_BLINK                 28391
 
 class ov_mycoordinates
diff --git a/src/server/scripts/Kalimdor/TempleOfAhnQiraj/boss_twinemperors.cpp b/src/server/scripts/Kalimdor/TempleOfAhnQiraj/boss_twinemperors.cpp
index a60c33a..b03d2dc 100644
--- a/src/server/scripts/Kalimdor/TempleOfAhnQiraj/boss_twinemperors.cpp
+++ b/src/server/scripts/Kalimdor/TempleOfAhnQiraj/boss_twinemperors.cpp
@@ -90,7 +90,7 @@ struct boss_twinemperorsAI : public ScriptedAI
         AfterTeleportTimer = 0;
         Abuse_Bug_Timer = urand(10000, 17000);
         BugsTimer = 2000;
-        me->ClearUnitState(UNIT_STAT_STUNNED);
+        me->ClearUnitState(UNIT_STATE_STUNNED);
         DontYellWhenDead = false;
         EnrageTimer = 15*60000;
     }
@@ -234,7 +234,7 @@ struct boss_twinemperorsAI : public ScriptedAI
         DoStopAttack();
         DoResetThreat();
         DoCast(me, SPELL_TWIN_TELEPORT_VISUAL);
-        me->AddUnitState(UNIT_STAT_STUNNED);
+        me->AddUnitState(UNIT_STATE_STUNNED);
         AfterTeleport = true;
         AfterTeleportTimer = 2000;
         tspellcasted = false;
@@ -246,9 +246,9 @@ struct boss_twinemperorsAI : public ScriptedAI
         {
             if (!tspellcasted)
             {
-                me->ClearUnitState(UNIT_STAT_STUNNED);
+                me->ClearUnitState(UNIT_STATE_STUNNED);
                 DoCast(me, SPELL_TWIN_TELEPORT);
-                me->AddUnitState(UNIT_STAT_STUNNED);
+                me->AddUnitState(UNIT_STATE_STUNNED);
             }
 
             tspellcasted = true;
@@ -256,7 +256,7 @@ struct boss_twinemperorsAI : public ScriptedAI
             if (AfterTeleportTimer <= diff)
             {
                 AfterTeleport = false;
-                me->ClearUnitState(UNIT_STAT_STUNNED);
+                me->ClearUnitState(UNIT_STATE_STUNNED);
                 if (Unit* nearu = me->SelectNearestTarget(100))
                 {
                     //DoYell(nearu->GetName(), LANG_UNIVERSAL, 0);
diff --git a/src/server/scripts/Kalimdor/WailingCaverns/wailing_caverns.cpp b/src/server/scripts/Kalimdor/WailingCaverns/wailing_caverns.cpp
index 1155d35..8eb3d20 100644
--- a/src/server/scripts/Kalimdor/WailingCaverns/wailing_caverns.cpp
+++ b/src/server/scripts/Kalimdor/WailingCaverns/wailing_caverns.cpp
@@ -98,7 +98,7 @@ public:
             DoScriptText(SAY_MAKE_PREPARATIONS, creature);
 
             creature->setFaction(250);
-            creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
 
             CAST_AI(npc_escortAI, (creature->AI()))->Start(false, false, player->GetGUID());
             CAST_AI(npc_escortAI, (creature->AI()))->SetDespawnAtFar(false);
@@ -143,7 +143,7 @@ public:
             currentEvent = 0;
             eventProgress = 0;
             me->setActive(true);
-            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
         }
 
         uint32 eventTimer;
diff --git a/src/server/scripts/Kalimdor/durotar.cpp b/src/server/scripts/Kalimdor/durotar.cpp
index 8cf72b3..6c91c64 100644
--- a/src/server/scripts/Kalimdor/durotar.cpp
+++ b/src/server/scripts/Kalimdor/durotar.cpp
@@ -84,7 +84,7 @@ public:
         void UpdateAI(const uint32 uiDiff)
         {
             if (work == true)
-                me->HandleEmoteCommand(466);
+                me->HandleEmoteCommand(EMOTE_ONESHOT_WORK_CHOPWOOD);
             if (m_uiRebuffTimer <= uiDiff)
             {
                 DoCast(me, SPELL_BUFF_SLEEP);
diff --git a/src/server/scripts/Kalimdor/dustwallow_marsh.cpp b/src/server/scripts/Kalimdor/dustwallow_marsh.cpp
index 0ead5d9..eede1aa 100644
--- a/src/server/scripts/Kalimdor/dustwallow_marsh.cpp
+++ b/src/server/scripts/Kalimdor/dustwallow_marsh.cpp
@@ -176,7 +176,7 @@ public:
                     creature->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
                     creature->SetSpeed(MOVE_RUN, creature->GetSpeedRate(MOVE_RUN), true);
                     creature->setFaction(35);
-                    creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_NON_ATTACKABLE);
+                    creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_NON_ATTACKABLE);
                     creature->SetReactState(REACT_PASSIVE);
                     creature->GetMotionMaster()->MovePoint(1, DeserterDisappearPos);
                     break;
@@ -198,7 +198,7 @@ public:
         void Reset()
         {
             me->RestoreFaction();
-            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_NON_ATTACKABLE);
+            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_NON_ATTACKABLE);
             me->SetReactState(REACT_AGGRESSIVE);
             me->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
         }
@@ -531,7 +531,7 @@ public:
                 return;
 
             me->SetHomePosition(me->GetPositionX(), me->GetPositionY(), me->GetPositionZ(), me->GetOrientation());
-            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
             SetCombatMovement(true);
 
             if (me->isInCombat())
diff --git a/src/server/scripts/Kalimdor/moonglade.cpp b/src/server/scripts/Kalimdor/moonglade.cpp
index f9e4bce..2d6e34a 100644
--- a/src/server/scripts/Kalimdor/moonglade.cpp
+++ b/src/server/scripts/Kalimdor/moonglade.cpp
@@ -602,7 +602,7 @@ public:
     {
         npc_omenAI(Creature* creature) : ScriptedAI(creature)
         {
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
             me->GetMotionMaster()->MovePoint(1, 7549.977f, -2855.137f, 456.9678f);
         }
 
@@ -616,7 +616,7 @@ public:
             if (pointId == 1)
             {
                 me->SetHomePosition(me->GetPositionX(), me->GetPositionY(), me->GetPositionZ(), me->GetOrientation());
-                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                 if (Player* player = me->SelectNearestPlayer(40.0f))
                     AttackStart(player);
             }
diff --git a/src/server/scripts/Kalimdor/mulgore.cpp b/src/server/scripts/Kalimdor/mulgore.cpp
index 01cca58..c689d69 100644
--- a/src/server/scripts/Kalimdor/mulgore.cpp
+++ b/src/server/scripts/Kalimdor/mulgore.cpp
@@ -171,7 +171,7 @@ public:
                             break;
                         case 2:
                             DoScriptText(EMOTE_EAT_LUNCH, me);
-                            me->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_STATE_USESTANDING);
+                            me->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_STATE_USE_STANDING);
                             break;
                         case 3:
                             if (Player* unit = Unit::GetPlayer(*me, uiPlayerGUID))
diff --git a/src/server/scripts/Kalimdor/stonetalon_mountains.cpp b/src/server/scripts/Kalimdor/stonetalon_mountains.cpp
index 3dd0d1c..c31a773 100644
--- a/src/server/scripts/Kalimdor/stonetalon_mountains.cpp
+++ b/src/server/scripts/Kalimdor/stonetalon_mountains.cpp
@@ -154,7 +154,7 @@ public:
 
             DoScriptText(SAY_START, creature);
             creature->setFaction(113);
-            creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
         }
         return true;
     }
diff --git a/src/server/scripts/Kalimdor/tanaris.cpp b/src/server/scripts/Kalimdor/tanaris.cpp
index 394a32e..ff6cdcc 100644
--- a/src/server/scripts/Kalimdor/tanaris.cpp
+++ b/src/server/scripts/Kalimdor/tanaris.cpp
@@ -410,7 +410,7 @@ public:
             creature->setFaction(113);
             creature->SetFullHealth();
             creature->SetUInt32Value(UNIT_FIELD_BYTES_1, 0);
-            creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
             DoScriptText(SAY_OOX_START, creature);
 
             if (npc_escortAI* pEscortAI = CAST_AI(npc_OOX17::npc_OOX17AI, creature->AI()))
diff --git a/src/server/scripts/Kalimdor/the_barrens.cpp b/src/server/scripts/Kalimdor/the_barrens.cpp
index 6f2ddb1..e12897c 100644
--- a/src/server/scripts/Kalimdor/the_barrens.cpp
+++ b/src/server/scripts/Kalimdor/the_barrens.cpp
@@ -512,7 +512,7 @@ public:
                                 //creature->GetMotionMaster()->MovePoint(0, -1693, -4343, 4.32f);
                                 //creature->GetMotionMaster()->MovePoint(1, -1684, -4333, 2.78f);
                                 creature->GetMotionMaster()->MovePoint(2, -1682, -4329, 2.79f);
-                                creature->HandleEmoteCommand(EMOTE_STATE_READYUNARMED);
+                                creature->HandleEmoteCommand(EMOTE_STATE_READY_UNARMED);
                                 EventBigWill = true;
                                 Wave_Timer = 1000;
                             }
diff --git a/src/server/scripts/Northrend/AzjolNerub/Ahnkahet/boss_herald_volazj.cpp b/src/server/scripts/Northrend/AzjolNerub/Ahnkahet/boss_herald_volazj.cpp
index bf22c7a..f1eaa0c 100644
--- a/src/server/scripts/Northrend/AzjolNerub/Ahnkahet/boss_herald_volazj.cpp
+++ b/src/server/scripts/Northrend/AzjolNerub/Ahnkahet/boss_herald_volazj.cpp
@@ -115,7 +115,7 @@ public:
                     DoCast(me, INSANITY_VISUAL, true);
                     // Unattackable
                     me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
-                    me->SetControlled(true, UNIT_STAT_STUNNED);
+                    me->SetControlled(true, UNIT_STATE_STUNNED);
                 }
                 // phase mask
                 target->CastSpell(target, SPELL_INSANITY_TARGET+insanityHandled, true);
@@ -171,7 +171,7 @@ public:
             // Cleanup
             Summons.DespawnAll();
             me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
-            me->SetControlled(false, UNIT_STAT_STUNNED);
+            me->SetControlled(false, UNIT_STATE_STUNNED);
         }
 
         void EnterCombat(Unit* /*who*/)
@@ -271,7 +271,7 @@ public:
 
                 insanityHandled = 0;
                 me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
-                me->SetControlled(false, UNIT_STAT_STUNNED);
+                me->SetControlled(false, UNIT_STATE_STUNNED);
                 me->RemoveAurasDueToSpell(INSANITY_VISUAL);
             }
 
diff --git a/src/server/scripts/Northrend/AzjolNerub/Ahnkahet/boss_prince_taldaram.cpp b/src/server/scripts/Northrend/AzjolNerub/Ahnkahet/boss_prince_taldaram.cpp
index 1e3a9a7..0f4b046 100644
--- a/src/server/scripts/Northrend/AzjolNerub/Ahnkahet/boss_prince_taldaram.cpp
+++ b/src/server/scripts/Northrend/AzjolNerub/Ahnkahet/boss_prince_taldaram.cpp
@@ -82,7 +82,7 @@ public:
         boss_taldaramAI(Creature* c) : ScriptedAI(c)
         {
             instance = c->GetInstanceScript();
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
             me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
         }
 
@@ -314,7 +314,7 @@ public:
         {
             if (!instance)
                 return;
-            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
             me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
             me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
             me->RemoveAurasDueToSpell(SPELL_BEAM_VISUAL);
diff --git a/src/server/scripts/Northrend/AzjolNerub/AzjolNerub/boss_anubarak.cpp b/src/server/scripts/Northrend/AzjolNerub/AzjolNerub/boss_anubarak.cpp
index cf9c7fd..79a102c 100644
--- a/src/server/scripts/Northrend/AzjolNerub/AzjolNerub/boss_anubarak.cpp
+++ b/src/server/scripts/Northrend/AzjolNerub/AzjolNerub/boss_anubarak.cpp
@@ -283,7 +283,7 @@ public:
                 if (((UndergroundPhase == 0 && HealthBelowPct(75))
                     || (UndergroundPhase == 1 && HealthBelowPct(50))
                     || (UndergroundPhase == 2 && HealthBelowPct(25)))
-                    && !me->HasUnitState(UNIT_STAT_CASTING))
+                    && !me->HasUnitState(UNIT_STATE_CASTING))
                 {
                     GuardianSummoned = false;
                     VenomancerSummoned = false;
diff --git a/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/boss_baltharus_the_warborn.cpp b/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/boss_baltharus_the_warborn.cpp
index 61d74c4..e848c29 100644
--- a/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/boss_baltharus_the_warborn.cpp
+++ b/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/boss_baltharus_the_warborn.cpp
@@ -174,7 +174,7 @@ class boss_baltharus_the_warborn : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING) && !(events.GetPhaseMask() & PHASE_INTRO_MASK))
+                if (me->HasUnitState(UNIT_STATE_CASTING) && !(events.GetPhaseMask() & PHASE_INTRO_MASK))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -268,7 +268,7 @@ class npc_baltharus_the_warborn_clone : public CreatureScript
 
                 _events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = _events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/boss_general_zarithrian.cpp b/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/boss_general_zarithrian.cpp
index 3b3b1fb..f41522f 100644
--- a/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/boss_general_zarithrian.cpp
+++ b/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/boss_general_zarithrian.cpp
@@ -97,7 +97,7 @@ class boss_general_zarithrian : public CreatureScript
             {
                 _Reset();
                 if (instance->GetBossState(DATA_SAVIANA_RAGEFIRE) == DONE && instance->GetBossState(DATA_BALTHARUS_THE_WARBORN) == DONE)
-                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
             }
 
             void EnterCombat(Unit* /*who*/)
@@ -148,7 +148,7 @@ class boss_general_zarithrian : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -257,7 +257,7 @@ class npc_onyx_flamecaller : public CreatureScript
 
                 _events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = _events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/boss_saviana_ragefire.cpp b/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/boss_saviana_ragefire.cpp
index 724fd4e..78810e2 100644
--- a/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/boss_saviana_ragefire.cpp
+++ b/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/boss_saviana_ragefire.cpp
@@ -137,7 +137,7 @@ class boss_saviana_ragefire : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/instance_ruby_sanctum.cpp b/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/instance_ruby_sanctum.cpp
index 0fb51df..f9e302d 100644
--- a/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/instance_ruby_sanctum.cpp
+++ b/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/instance_ruby_sanctum.cpp
@@ -189,7 +189,7 @@ class instance_ruby_sanctum : public InstanceMapScript
                         {
                             HandleGameObject(FlameWallsGUID, true);
                             if (Creature* zarithrian = instance->GetCreature(GeneralZarithrianGUID))
-                                zarithrian->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
+                                zarithrian->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_NOT_SELECTABLE);
                         }
                         break;
                     }
@@ -199,7 +199,7 @@ class instance_ruby_sanctum : public InstanceMapScript
                         {
                             HandleGameObject(FlameWallsGUID, true);
                             if (Creature* zarithrian = instance->GetCreature(GeneralZarithrianGUID))
-                                zarithrian->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
+                                zarithrian->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_NOT_SELECTABLE);
                         }
                         break;
                     }
diff --git a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_black_knight.cpp b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_black_knight.cpp
index 153e128..0848d1e 100644
--- a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_black_knight.cpp
+++ b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_black_knight.cpp
@@ -111,7 +111,7 @@ public:
         {
             RemoveSummons();
             me->SetDisplayId(me->GetNativeDisplayId());
-            me->ClearUnitState(UNIT_STAT_ROOT | UNIT_STAT_STUNNED);
+            me->ClearUnitState(UNIT_STATE_ROOT | UNIT_STATE_STUNNED);
 
             bEventInProgress = false;
             bEvent = false;
@@ -167,7 +167,7 @@ public:
                     uiPhase++;
                     uiResurrectTimer = 4000;
                     bEventInProgress = false;
-                    me->ClearUnitState(UNIT_STAT_ROOT | UNIT_STAT_STUNNED);
+                    me->ClearUnitState(UNIT_STATE_ROOT | UNIT_STATE_STUNNED);
                 } else uiResurrectTimer -= uiDiff;
             }
 
@@ -211,14 +211,14 @@ public:
                             if (!bSummonArmy)
                             {
                                 bSummonArmy = true;
-                                me->AddUnitState(UNIT_STAT_ROOT | UNIT_STAT_STUNNED);
+                                me->AddUnitState(UNIT_STATE_ROOT | UNIT_STATE_STUNNED);
                                 DoCast(me, SPELL_ARMY_DEAD);
                             }
                             if (!bDeathArmyDone)
                             {
                                 if (uiDeathArmyCheckTimer <= uiDiff)
                                 {
-                                    me->ClearUnitState(UNIT_STAT_ROOT | UNIT_STAT_STUNNED);
+                                    me->ClearUnitState(UNIT_STATE_ROOT | UNIT_STATE_STUNNED);
                                     uiDeathArmyCheckTimer = 0;
                                     bDeathArmyDone = true;
                                 } else uiDeathArmyCheckTimer -= uiDiff;
@@ -263,7 +263,7 @@ public:
                 }
             }
 
-            if (!me->HasUnitState(UNIT_STAT_ROOT) && !me->HealthBelowPct(1))
+            if (!me->HasUnitState(UNIT_STATE_ROOT) && !me->HealthBelowPct(1))
                 DoMeleeAttackIfReady();
         }
 
@@ -273,7 +273,7 @@ public:
             {
                 uiDamage = 0;
                 me->SetHealth(0);
-                me->AddUnitState(UNIT_STAT_ROOT | UNIT_STAT_STUNNED);
+                me->AddUnitState(UNIT_STATE_ROOT | UNIT_STATE_STUNNED);
                 RemoveSummons();
                 switch (uiPhase)
                 {
diff --git a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_grand_champions.cpp b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_grand_champions.cpp
index ebdc55c..9fcfcfa 100644
--- a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_grand_champions.cpp
+++ b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_grand_champions.cpp
@@ -107,7 +107,7 @@ void AggroAllPlayers(Creature* temp)
 
             if (player->isAlive())
             {
-                temp->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                temp->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
                 temp->SetReactState(REACT_AGGRESSIVE);
                 temp->SetInCombatWith(player);
                 player->SetInCombatWith(temp);
@@ -320,7 +320,7 @@ public:
 
             me->SetReactState(REACT_PASSIVE);
             // THIS IS A HACK, SHOULD BE REMOVED WHEN THE EVENT IS FULL SCRIPTED
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
         }
 
         InstanceScript* instance;
@@ -453,7 +453,7 @@ public:
 
             me->SetReactState(REACT_PASSIVE);
             // THIS IS A HACK, SHOULD BE REMOVED WHEN THE EVENT IS FULL SCRIPTED
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
         }
 
         InstanceScript* instance;
@@ -592,7 +592,7 @@ public:
 
             me->SetReactState(REACT_PASSIVE);
             // THIS IS A HACK, SHOULD BE REMOVED WHEN THE EVENT IS FULL SCRIPTED
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
         }
 
         InstanceScript* instance;
@@ -739,7 +739,7 @@ public:
 
             me->SetReactState(REACT_PASSIVE);
             // THIS IS A HACK, SHOULD BE REMOVED WHEN THE EVENT IS FULL SCRIPTED
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
         }
 
         InstanceScript* instance;
@@ -895,7 +895,7 @@ public:
 
             me->SetReactState(REACT_PASSIVE);
             // THIS IS A HACK, SHOULD BE REMOVED WHEN THE EVENT IS FULL SCRIPTED
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
         }
 
         InstanceScript* instance;
diff --git a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_anubarak_trial.cpp b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_anubarak_trial.cpp
index d3d9237..a9e41d9 100755
--- a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_anubarak_trial.cpp
+++ b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_anubarak_trial.cpp
@@ -535,7 +535,7 @@ public:
                 {
                     me->RemoveAurasDueToSpell(SPELL_SUBMERGE_EFFECT);
                     DoCast(me, SPELL_EMERGE_EFFECT);
-                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
+                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_NOT_SELECTABLE);
                     me->CombatStart(me->SelectNearestTarget());
                 }
                 else
@@ -543,7 +543,7 @@ public:
                     if (!me->HasAura(SPELL_PERMAFROST_HELPER))
                     {
                         DoCast(me, SPELL_SUBMERGE_EFFECT);
-                        me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
+                        me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_NOT_SELECTABLE);
                         me->CombatStop();
                     }
                 }
@@ -647,7 +647,7 @@ public:
         void Reset()
         {
             // For an unknown reason this npc isn't recognize the Aura of Permafrost with this flags =/
-            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
             m_uiTargetGUID = 0;
         }
 
diff --git a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_faction_champions.cpp b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_faction_champions.cpp
index 45fdbdd..2fe0bd3 100755
--- a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_faction_champions.cpp
+++ b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_faction_champions.cpp
@@ -172,7 +172,7 @@ public:
                 {
                     Summons.Summon(temp);
                     temp->SetReactState(REACT_PASSIVE);
-                    temp->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                    temp->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
                     if (playerTeam == ALLIANCE)
                     {
                         temp->SetHomePosition(vChampionJumpTarget[pos].GetPositionX(), vChampionJumpTarget[pos].GetPositionY(), vChampionJumpTarget[pos].GetPositionZ(), 0);
@@ -203,7 +203,7 @@ public:
                         if (Creature* temp = Unit::GetCreature(*me, *i))
                         {
                             temp->SetReactState(REACT_AGGRESSIVE);
-                            temp->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                            temp->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
                         }
                     }
                     break;
diff --git a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_twin_valkyr.cpp b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_twin_valkyr.cpp
index 960b685..c100996 100755
--- a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_twin_valkyr.cpp
+++ b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_twin_valkyr.cpp
@@ -172,7 +172,7 @@ struct boss_twin_baseAI : public ScriptedAI
     uint32 m_uiTouchSpellId;
 
     void Reset() {
-        me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
+        me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_NOT_SELECTABLE);
         me->SetReactState(REACT_PASSIVE);
         me->ModifyAuraState(m_uiAuraState, true);
         /* Uncomment this once that they are flying above the ground
@@ -205,7 +205,7 @@ struct boss_twin_baseAI : public ScriptedAI
         {
             case 1:
                 m_instance->DoUseDoorOrButton(m_instance->GetData64(GO_MAIN_GATE_DOOR));
-                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_NOT_SELECTABLE);
                 me->SetReactState(REACT_AGGRESSIVE);
                 break;
         }
@@ -572,7 +572,7 @@ struct mob_unleashed_ballAI : public ScriptedAI
 
     void Reset()
     {
-        me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
+        me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_NOT_SELECTABLE);
         me->SetReactState(REACT_PASSIVE);
         me->AddUnitMovementFlag(MOVEMENTFLAG_LEVITATING);
         me->SetFlying(true);
diff --git a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/trial_of_the_crusader.cpp b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/trial_of_the_crusader.cpp
index b17b6f1..3831e48 100755
--- a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/trial_of_the_crusader.cpp
+++ b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/trial_of_the_crusader.cpp
@@ -429,7 +429,7 @@ class npc_fizzlebang_toc : public CreatureScript
                         case 1130:
                             me->GetMotionMaster()->MovementExpired();
                             DoScriptText(SAY_STAGE_1_03, me);
-                            me->HandleEmoteCommand(EMOTE_ONESHOT_SPELLCAST_OMNI);
+                            me->HandleEmoteCommand(EMOTE_ONESHOT_SPELL_CAST_OMNI);
                             if (Unit* pTrigger =  me->SummonCreature(NPC_TRIGGER, ToCCommonLoc[1].GetPositionX(), ToCCommonLoc[1].GetPositionY(), ToCCommonLoc[1].GetPositionZ(), 4.69494f, TEMPSUMMON_MANUAL_DESPAWN))
                             {
                                 m_uiTriggerGUID = pTrigger->GetGUID();
@@ -446,7 +446,7 @@ class npc_fizzlebang_toc : public CreatureScript
                             m_uiUpdateTimer = 4000;
                             break;
                         case 1134:
-                            me->HandleEmoteCommand(EMOTE_ONESHOT_SPELLCAST_OMNI);
+                            me->HandleEmoteCommand(EMOTE_ONESHOT_SPELL_CAST_OMNI);
                             if (Creature* pPortal = me->SummonCreature(NPC_WILFRED_PORTAL, ToCCommonLoc[1].GetPositionX(), ToCCommonLoc[1].GetPositionY(), ToCCommonLoc[1].GetPositionZ(), 4.71239f, TEMPSUMMON_MANUAL_DESPAWN))
                             {
                                 pPortal->SetReactState(REACT_PASSIVE);
diff --git a/src/server/scripts/Northrend/DraktharonKeep/boss_novos.cpp b/src/server/scripts/Northrend/DraktharonKeep/boss_novos.cpp
index 54e234a..5418cf8 100644
--- a/src/server/scripts/Northrend/DraktharonKeep/boss_novos.cpp
+++ b/src/server/scripts/Northrend/DraktharonKeep/boss_novos.cpp
@@ -100,8 +100,8 @@ public:
             lSummons.DespawnAll();
             crystalHandlerAmount = 0;
 
-            if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE))
-                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC))
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
             if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
                 me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
             if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE))
@@ -136,7 +136,7 @@ public:
                 }
                 instance->SetData(DATA_NOVOS_EVENT, IN_PROGRESS);
             }
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
             me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
             me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
         }
@@ -227,7 +227,7 @@ public:
             if (luiCrystals.empty())
             {
                 me->CastStop();
-                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                 me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
                 me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
                 Phase = PHASE_2;
diff --git a/src/server/scripts/Northrend/FrozenHalls/ForgeOfSouls/boss_bronjahm.cpp b/src/server/scripts/Northrend/FrozenHalls/ForgeOfSouls/boss_bronjahm.cpp
index a0d6f04..4a28ebe 100644
--- a/src/server/scripts/Northrend/FrozenHalls/ForgeOfSouls/boss_bronjahm.cpp
+++ b/src/server/scripts/Northrend/FrozenHalls/ForgeOfSouls/boss_bronjahm.cpp
@@ -142,7 +142,7 @@ class boss_bronjahm : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/FrozenHalls/ForgeOfSouls/boss_devourer_of_souls.cpp b/src/server/scripts/Northrend/FrozenHalls/ForgeOfSouls/boss_devourer_of_souls.cpp
index fb39019..ad49f6c 100644
--- a/src/server/scripts/Northrend/FrozenHalls/ForgeOfSouls/boss_devourer_of_souls.cpp
+++ b/src/server/scripts/Northrend/FrozenHalls/ForgeOfSouls/boss_devourer_of_souls.cpp
@@ -260,7 +260,7 @@ class boss_devourer_of_souls : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/FrozenHalls/ForgeOfSouls/forge_of_souls.cpp b/src/server/scripts/Northrend/FrozenHalls/ForgeOfSouls/forge_of_souls.cpp
index c6d00a9..c8f18db 100644
--- a/src/server/scripts/Northrend/FrozenHalls/ForgeOfSouls/forge_of_souls.cpp
+++ b/src/server/scripts/Northrend/FrozenHalls/ForgeOfSouls/forge_of_souls.cpp
@@ -441,7 +441,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
@@ -497,7 +497,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
@@ -555,7 +555,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
@@ -612,7 +612,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
@@ -672,7 +672,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
@@ -738,7 +738,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
@@ -811,7 +811,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
@@ -878,7 +878,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/FrozenHalls/HallsOfReflection/boss_falric.cpp b/src/server/scripts/Northrend/FrozenHalls/HallsOfReflection/boss_falric.cpp
index 673362f..9cfcb78 100644
--- a/src/server/scripts/Northrend/FrozenHalls/HallsOfReflection/boss_falric.cpp
+++ b/src/server/scripts/Northrend/FrozenHalls/HallsOfReflection/boss_falric.cpp
@@ -103,7 +103,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             switch (events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/FrozenHalls/HallsOfReflection/boss_marwyn.cpp b/src/server/scripts/Northrend/FrozenHalls/HallsOfReflection/boss_marwyn.cpp
index b074c30..a9bfb60 100644
--- a/src/server/scripts/Northrend/FrozenHalls/HallsOfReflection/boss_marwyn.cpp
+++ b/src/server/scripts/Northrend/FrozenHalls/HallsOfReflection/boss_marwyn.cpp
@@ -100,7 +100,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             switch (events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/FrozenHalls/HallsOfReflection/halls_of_reflection.cpp b/src/server/scripts/Northrend/FrozenHalls/HallsOfReflection/halls_of_reflection.cpp
index e1ae837..1583bdb 100644
--- a/src/server/scripts/Northrend/FrozenHalls/HallsOfReflection/halls_of_reflection.cpp
+++ b/src/server/scripts/Northrend/FrozenHalls/HallsOfReflection/halls_of_reflection.cpp
@@ -659,7 +659,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
@@ -742,7 +742,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
@@ -842,7 +842,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
@@ -912,7 +912,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
@@ -978,7 +978,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/FrozenHalls/PitOfSaron/boss_forgemaster_garfrost.cpp b/src/server/scripts/Northrend/FrozenHalls/PitOfSaron/boss_forgemaster_garfrost.cpp
index 26ece7d..0f9495d 100644
--- a/src/server/scripts/Northrend/FrozenHalls/PitOfSaron/boss_forgemaster_garfrost.cpp
+++ b/src/server/scripts/Northrend/FrozenHalls/PitOfSaron/boss_forgemaster_garfrost.cpp
@@ -190,7 +190,7 @@ class boss_garfrost : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/FrozenHalls/PitOfSaron/boss_krickandick.cpp b/src/server/scripts/Northrend/FrozenHalls/PitOfSaron/boss_krickandick.cpp
index 8bcd0b8..8e211cb 100644
--- a/src/server/scripts/Northrend/FrozenHalls/PitOfSaron/boss_krickandick.cpp
+++ b/src/server/scripts/Northrend/FrozenHalls/PitOfSaron/boss_krickandick.cpp
@@ -215,7 +215,7 @@ class boss_ick : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/FrozenHalls/PitOfSaron/pit_of_saron.cpp b/src/server/scripts/Northrend/FrozenHalls/PitOfSaron/pit_of_saron.cpp
index 91be62a..25cd292 100644
--- a/src/server/scripts/Northrend/FrozenHalls/PitOfSaron/pit_of_saron.cpp
+++ b/src/server/scripts/Northrend/FrozenHalls/PitOfSaron/pit_of_saron.cpp
@@ -72,7 +72,7 @@ class mob_ymirjar_flamebearer : public CreatureScript
 
                 _events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = _events.ExecuteEvent())
@@ -187,7 +187,7 @@ class mob_wrathbone_laborer : public CreatureScript
 
                 _events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = _events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/Gundrak/boss_drakkari_colossus.cpp b/src/server/scripts/Northrend/Gundrak/boss_drakkari_colossus.cpp
index 9abcc66..b66c3d7 100644
--- a/src/server/scripts/Northrend/Gundrak/boss_drakkari_colossus.cpp
+++ b/src/server/scripts/Northrend/Gundrak/boss_drakkari_colossus.cpp
@@ -97,7 +97,7 @@ class boss_drakkari_colossus : public CreatureScript
                 if (GetData(DATA_INTRO_DONE))
                 {
                     me->SetReactState(REACT_AGGRESSIVE);
-                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                     me->RemoveAura(SPELL_FREEZE_ANIM);
                 }
 
@@ -149,7 +149,7 @@ class boss_drakkari_colossus : public CreatureScript
                         me->GetMotionMaster()->MoveIdle();
 
                         me->SetReactState(REACT_PASSIVE);
-                        me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                        me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                         DoCast(me, SPELL_FREEZE_ANIM);
                         break;
                     case ACTION_UNFREEZE_COLOSSUS:
@@ -158,7 +158,7 @@ class boss_drakkari_colossus : public CreatureScript
                             return;
 
                         me->SetReactState(REACT_AGGRESSIVE);
-                        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                         me->RemoveAura(SPELL_FREEZE_ANIM);
 
                         me->SetInCombatWithZone();
@@ -172,7 +172,7 @@ class boss_drakkari_colossus : public CreatureScript
 
             void DamageTaken(Unit* /*attacker*/, uint32& damage)
             {
-                if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE))
+                if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC))
                     damage = 0;
 
                 if (phase == COLOSSUS_PHASE_NORMAL ||
@@ -212,7 +212,7 @@ class boss_drakkari_colossus : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -289,7 +289,7 @@ class boss_drakkari_elemental : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -335,7 +335,7 @@ class boss_drakkari_elemental : public CreatureScript
                             damage = 0;
 
                             // to prevent spell spaming
-                            if (me->HasUnitState(UNIT_STAT_CHARGING))
+                            if (me->HasUnitState(UNIT_STATE_CHARGING))
                                 return;
 
                             // not sure about this, the idea of this code is to prevent bug the elemental
diff --git a/src/server/scripts/Northrend/Gundrak/boss_gal_darah.cpp b/src/server/scripts/Northrend/Gundrak/boss_gal_darah.cpp
index 4607009..daa5ee8 100644
--- a/src/server/scripts/Northrend/Gundrak/boss_gal_darah.cpp
+++ b/src/server/scripts/Northrend/Gundrak/boss_gal_darah.cpp
@@ -148,7 +148,7 @@ public:
                             DoScriptText(SAY_TRANSFORM_1, me);
                             uiTransformationTimer = 5*IN_MILLISECONDS;
                             bStartOfTransformation = true;
-                            me->ClearUnitState(UNIT_STAT_STUNNED|UNIT_STAT_ROOT);
+                            me->ClearUnitState(UNIT_STATE_STUNNED|UNIT_STATE_ROOT);
                             me->SetReactState(REACT_AGGRESSIVE);
                         }
                         else
@@ -158,7 +158,7 @@ public:
                             if (bStartOfTransformation)
                             {
                                 bStartOfTransformation = false;
-                                me->AddUnitState(UNIT_STAT_STUNNED|UNIT_STAT_ROOT);
+                                me->AddUnitState(UNIT_STATE_STUNNED|UNIT_STATE_ROOT);
                                 me->SetReactState(REACT_PASSIVE);
                             }
                         }
@@ -191,7 +191,7 @@ public:
                             DoScriptText(SAY_TRANSFORM_2, me);
                             uiTransformationTimer = 9*IN_MILLISECONDS;
                             bStartOfTransformation = true;
-                            me->ClearUnitState(UNIT_STAT_STUNNED|UNIT_STAT_ROOT);
+                            me->ClearUnitState(UNIT_STATE_STUNNED|UNIT_STATE_ROOT);
                             me->SetReactState(REACT_AGGRESSIVE);
                         }
                         else
@@ -201,7 +201,7 @@ public:
                             if (bStartOfTransformation)
                             {
                                 bStartOfTransformation = false;
-                                me->AddUnitState(UNIT_STAT_STUNNED|UNIT_STAT_ROOT);
+                                me->AddUnitState(UNIT_STATE_STUNNED|UNIT_STATE_ROOT);
                                 me->SetReactState(REACT_PASSIVE);
                             }
                         }
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_blood_prince_council.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_blood_prince_council.cpp
index 62b1666..f5e207a 100644
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_blood_prince_council.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_blood_prince_council.cpp
@@ -287,7 +287,7 @@ class boss_blood_council_controller : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -383,7 +383,7 @@ class boss_prince_keleseth_icc : public CreatureScript
                 events.Reset();
                 summons.DespawnAll();
 
-                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                 _isEmpowered = false;
                 me->SetHealth(_spawnHealth);
                 instance->SetData(DATA_ORB_WHISPERER_ACHIEVEMENT, uint32(true));
@@ -489,7 +489,7 @@ class boss_prince_keleseth_icc : public CreatureScript
                 {
                     case ACTION_STAND_UP:
                         me->RemoveAurasDueToSpell(SPELL_FEIGN_DEATH);
-                        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_IMMUNE_TO_PC);
                         me->RemoveFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_DEAD);
                         me->RemoveFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_FEIGN_DEATH);
                         me->ForceValuesUpdateAtIndex(UNIT_NPC_FLAGS);   // was in sniff. don't ask why
@@ -535,7 +535,7 @@ class boss_prince_keleseth_icc : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -607,7 +607,7 @@ class boss_prince_taldaram_icc : public CreatureScript
                 events.Reset();
                 summons.DespawnAll();
 
-                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                 _isEmpowered = false;
                 me->SetHealth(_spawnHealth);
                 instance->SetData(DATA_ORB_WHISPERER_ACHIEVEMENT, uint32(true));
@@ -707,7 +707,7 @@ class boss_prince_taldaram_icc : public CreatureScript
                 {
                     case ACTION_STAND_UP:
                         me->RemoveAurasDueToSpell(SPELL_FEIGN_DEATH);
-                        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_IMMUNE_TO_PC);
                         me->RemoveFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_DEAD);
                         me->RemoveFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_FEIGN_DEATH);
                         me->ForceValuesUpdateAtIndex(UNIT_NPC_FLAGS);   // was in sniff. don't ask why
@@ -753,7 +753,7 @@ class boss_prince_taldaram_icc : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -830,7 +830,7 @@ class boss_prince_valanar_icc : public CreatureScript
                 events.Reset();
                 summons.DespawnAll();
 
-                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                 _isEmpowered = false;
                 me->SetHealth(me->GetMaxHealth());
                 instance->SetData(DATA_ORB_WHISPERER_ACHIEVEMENT, uint32(true));
@@ -892,7 +892,7 @@ class boss_prince_valanar_icc : public CreatureScript
                     {
                         float x, y, z;
                         summon->GetPosition(x, y, z);
-                        float ground_Z = summon->GetMap()->GetHeight(summon->GetPhaseMask(), x, y, z, true, 500.0f);
+                        float ground_Z = summon->GetMap()->GetHeight(x, y, z, true, 500.0f);
                         summon->GetMotionMaster()->MovePoint(POINT_KINETIC_BOMB_IMPACT, x, y, ground_Z);
                         break;
                     }
@@ -944,7 +944,7 @@ class boss_prince_valanar_icc : public CreatureScript
                 {
                     case ACTION_STAND_UP:
                         me->RemoveAurasDueToSpell(SPELL_FEIGN_DEATH);
-                        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_IMMUNE_TO_PC);
                         me->RemoveFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_DEAD);
                         me->RemoveFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_FEIGN_DEATH);
                         me->ForceValuesUpdateAtIndex(UNIT_NPC_FLAGS);   // was in sniff. don't ask why
@@ -990,7 +990,7 @@ class boss_prince_valanar_icc : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -1179,7 +1179,7 @@ class npc_ball_of_flame : public CreatureScript
                     if (Player* target = ObjectAccessor::GetPlayer(*me, _chaseGUID))
                     {
                         // need to clear states now because this call is before AuraEffect is fully removed
-                        me->ClearUnitState(UNIT_STAT_CASTING | UNIT_STAT_STUNNED);
+                        me->ClearUnitState(UNIT_STATE_CASTING | UNIT_STATE_STUNNED);
                         if (target && me->Attack(target, true))
                             me->GetMotionMaster()->MoveChase(target, 1.0f);
                     }
@@ -1238,7 +1238,7 @@ class npc_kinetic_bomb : public CreatureScript
                 me->SetReactState(REACT_PASSIVE);
                 me->SetSpeed(MOVE_FLIGHT, IsHeroic() ? 0.3f : 0.15f, true);
                 me->GetPosition(_x, _y, _groundZ);
-                _groundZ = me->GetMap()->GetHeight(me->GetPhaseMask(), _x, _y, _groundZ, true, 500.0f);
+                _groundZ = me->GetMap()->GetHeight(_x, _y, _groundZ, true, 500.0f);
             }
 
             void DoAction(int32 const action)
@@ -1316,7 +1316,7 @@ class npc_dark_nucleus : public CreatureScript
                 }
 
                 DoCast(who, SPELL_SHADOW_RESONANCE_RESIST);
-                me->ClearUnitState(UNIT_STAT_CASTING);
+                me->ClearUnitState(UNIT_STATE_CASTING);
             }
 
             void MoveInLineOfSight(Unit* who)
@@ -1350,7 +1350,7 @@ class npc_dark_nucleus : public CreatureScript
                             !victim->HasAura(SPELL_SHADOW_RESONANCE_RESIST, me->GetGUID()))
                         {
                             DoCast(victim, SPELL_SHADOW_RESONANCE_RESIST);
-                            me->ClearUnitState(UNIT_STAT_CASTING);
+                            me->ClearUnitState(UNIT_STATE_CASTING);
                         }
                 }
                 else
@@ -1369,7 +1369,7 @@ class npc_dark_nucleus : public CreatureScript
                         _lockedTarget = true;
                         AttackStart(victim);
                         DoCast(victim, SPELL_SHADOW_RESONANCE_RESIST);
-                        me->ClearUnitState(UNIT_STAT_CASTING);
+                        me->ClearUnitState(UNIT_STATE_CASTING);
                     }
                 }
             }
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_blood_queen_lana_thel.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_blood_queen_lana_thel.cpp
index d775e57..79a577f 100644
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_blood_queen_lana_thel.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_blood_queen_lana_thel.cpp
@@ -321,7 +321,7 @@ class boss_blood_queen_lana_thel : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_deathbringer_saurfang.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_deathbringer_saurfang.cpp
index 31b3786..3c79518 100755
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_deathbringer_saurfang.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_deathbringer_saurfang.cpp
@@ -279,7 +279,7 @@ class boss_deathbringer_saurfang : public CreatureScript
 
                 events.Reset();
                 events.SetPhase(PHASE_COMBAT);
-                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                 if (!_introDone)
                 {
                     DoCast(me, SPELL_GRIP_OF_AGONY);
@@ -314,7 +314,7 @@ class boss_deathbringer_saurfang : public CreatureScript
 
             void AttackStart(Unit* victim)
             {
-                if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE))
+                if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC))
                     return;
 
                 ScriptedAI::AttackStart(victim);
@@ -324,7 +324,7 @@ class boss_deathbringer_saurfang : public CreatureScript
             {
                 ScriptedAI::EnterEvadeMode();
                 if (_introDone)
-                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
             }
 
             void JustReachedHome()
@@ -403,7 +403,7 @@ class boss_deathbringer_saurfang : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -434,7 +434,7 @@ class boss_deathbringer_saurfang : public CreatureScript
                         case EVENT_INTRO_FINISH:
                             events.SetPhase(PHASE_COMBAT);
                             _introDone = true;
-                            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                             break;
                         case EVENT_SUMMON_BLOOD_BEAST:
                             for (uint32 i10 = 0; i10 < 2; ++i10)
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_festergut.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_festergut.cpp
index f90bc5d..a97c6f7 100755
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_festergut.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_festergut.cpp
@@ -169,7 +169,7 @@ class boss_festergut : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -305,7 +305,7 @@ class npc_stinky_icc : public CreatureScript
 
                 _events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = _events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_lady_deathwhisper.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_lady_deathwhisper.cpp
index af9bc3f..ea2f73e 100755
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_lady_deathwhisper.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_lady_deathwhisper.cpp
@@ -410,7 +410,7 @@ class boss_lady_deathwhisper : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING) && !(events.GetPhaseMask() & PHASE_INTRO_MASK))
+                if (me->HasUnitState(UNIT_STATE_CASTING) && !(events.GetPhaseMask() & PHASE_INTRO_MASK))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -665,7 +665,7 @@ class npc_cult_fanatic : public CreatureScript
 
                 Events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = Events.ExecuteEvent())
@@ -743,7 +743,7 @@ class npc_cult_adherent : public CreatureScript
 
                 Events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = Events.ExecuteEvent())
@@ -888,7 +888,7 @@ class npc_darnavan : public CreatureScript
 
                 _events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 if (_canShatter && me->getVictim() && me->getVictim()->IsImmunedToDamage(SPELL_SCHOOL_MASK_NORMAL))
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_lord_marrowgar.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_lord_marrowgar.cpp
index ac246ab..1672d8b 100755
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_lord_marrowgar.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_lord_marrowgar.cpp
@@ -154,7 +154,7 @@ class boss_lord_marrowgar : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_professor_putricide.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_professor_putricide.cpp
index 6eda383..28964a2 100755
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_professor_putricide.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_professor_putricide.cpp
@@ -196,7 +196,7 @@ class boss_professor_putricide : public CreatureScript
                     me->GetMotionMaster()->MovementExpired();
 
                 if (instance->GetBossState(DATA_ROTFACE) == DONE && instance->GetBossState(DATA_FESTERGUT) == DONE)
-                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
+                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_NOT_SELECTABLE);
             }
 
             void EnterCombat(Unit* who)
@@ -519,7 +519,7 @@ class boss_professor_putricide : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -796,7 +796,7 @@ class spell_putricide_ooze_channel : public SpellScriptLoader
 
             void StartAttack()
             {
-                GetCaster()->ClearUnitState(UNIT_STAT_CASTING);
+                GetCaster()->ClearUnitState(UNIT_STATE_CASTING);
                 GetCaster()->ToCreature()->AI()->AttackStart(GetHitUnit());
             }
 
@@ -948,7 +948,7 @@ class spell_putricide_ooze_summon : public SpellScriptLoader
                     uint32 triggerSpellId = GetSpellInfo()->Effects[aurEff->GetEffIndex()].TriggerSpell;
                     float x, y, z;
                     GetTarget()->GetPosition(x, y, z);
-                    z = GetTarget()->GetMap()->GetHeight(GetTarget()->GetPhaseMask(), x, y, z, true, 25.0f);
+                    z = GetTarget()->GetMap()->GetHeight(x, y, z, true, 25.0f);
                     x += 10.0f * cosf(caster->GetOrientation());
                     y += 10.0f * sinf(caster->GetOrientation());
                     caster->CastSpell(x, y, z, triggerSpellId, true, NULL, NULL, GetCasterGUID());
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_rotface.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_rotface.cpp
index a4cd96a..9649b6c 100644
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_rotface.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_rotface.cpp
@@ -169,7 +169,7 @@ class boss_rotface : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -384,7 +384,7 @@ class npc_precious_icc : public CreatureScript
 
                 _events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = _events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_sindragosa.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_sindragosa.cpp
index 3d3eaa1..fb04d9c 100644
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_sindragosa.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_sindragosa.cpp
@@ -379,7 +379,7 @@ class boss_sindragosa : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -663,7 +663,7 @@ class npc_spinestalker : public CreatureScript
 
                 _events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = _events.ExecuteEvent())
@@ -749,7 +749,7 @@ class npc_rimefang : public CreatureScript
 
                     me->setActive(true);
                     me->SetSpeed(MOVE_FLIGHT, 2.0f);
-                    me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                    me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                     float moveTime = me->GetExactDist(&RimefangFlyPos) / (me->GetSpeed(MOVE_FLIGHT) * 0.001f);
                     me->m_Events.AddEvent(new FrostwyrmLandEvent(*me, RimefangLandPos), me->m_Events.CalculateTime(uint64(moveTime) + 250));
                     me->SetDefaultMovementType(IDLE_MOTION_TYPE);
@@ -768,7 +768,7 @@ class npc_rimefang : public CreatureScript
                 me->SetFlying(false);
                 me->RemoveUnitMovementFlag(MOVEMENTFLAG_LEVITATING);
                 me->SetHomePosition(RimefangLandPos);
-                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
             }
 
             void EnterCombat(Unit* /*victim*/)
@@ -783,7 +783,7 @@ class npc_rimefang : public CreatureScript
 
                 _events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = _events.ExecuteEvent())
@@ -911,7 +911,7 @@ class npc_sindragosa_trash : public CreatureScript
 
                 _events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = _events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_the_lich_king.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_the_lich_king.cpp
index 6cac58e..2acd014 100644
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_the_lich_king.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_the_lich_king.cpp
@@ -504,7 +504,7 @@ class boss_the_lich_king : public CreatureScript
                 float x, y, z;
                 me->GetPosition(x, y, z);
                 // use larger distance for vmap height search than in most other cases
-                float ground_Z = me->GetMap()->GetHeight(me->GetPhaseMask(), x, y, z, true, MAX_FALL_DISTANCE);
+                float ground_Z = me->GetMap()->GetHeight(x, y, z, true, MAX_FALL_DISTANCE);
                 if (fabs(ground_Z - z) < 0.1f)
                     return;
 
@@ -701,7 +701,7 @@ class boss_the_lich_king : public CreatureScript
                             summon->CastSpell(summon, SPELL_ICE_SPHERE, false);
                             summon->CastSpell(summon, SPELL_ICE_BURST_TARGET_SEARCH, false);
                             summon->CastSpell(target, SPELL_ICE_PULSE, false);
-                            summon->ClearUnitState(UNIT_STAT_CASTING);
+                            summon->ClearUnitState(UNIT_STATE_CASTING);
                             summon->GetMotionMaster()->MoveFollow(target, 0.0f, 0.0f);
                         }
                         else
@@ -861,7 +861,7 @@ class boss_the_lich_king : public CreatureScript
                 events.Update(diff);
 
                 // during Remorseless Winter phases The Lich King is channeling a spell, but we must continue casting other spells
-                if (me->HasUnitState(UNIT_STAT_CASTING) && !(events.GetPhaseMask() & PHASE_MASK_NO_CAST_CHECK))
+                if (me->HasUnitState(UNIT_STATE_CASTING) && !(events.GetPhaseMask() & PHASE_MASK_NO_CAST_CHECK))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -883,7 +883,7 @@ class boss_the_lich_king : public CreatureScript
                         case EVENT_INTRO_TALK_1:
                             Talk(SAY_LK_INTRO_2);
                             // for some reason blizz sends 2 emotes in row here so (we handle one in Talk)
-                            me->HandleEmoteCommand(EMOTE_ONESHOT_TALK_NOSHEATHE);
+                            me->HandleEmoteCommand(EMOTE_ONESHOT_TALK_NO_SHEATHE);
                             events.ScheduleEvent(EVENT_EMOTE_CAST_SHOUT, 7000, 0, PHASE_INTRO);
                             events.ScheduleEvent(EVENT_INTRO_EMOTE_1, 13000, 0, PHASE_INTRO);
                             events.ScheduleEvent(EVENT_EMOTE_CAST_SHOUT, 18000, 0, PHASE_INTRO);
@@ -893,7 +893,7 @@ class boss_the_lich_king : public CreatureScript
                             DoCast(me, SPELL_EMOTE_SHOUT_NO_SHEATH, false);
                             break;
                         case EVENT_INTRO_EMOTE_1:
-                            me->HandleEmoteCommand(EMOTE_ONESHOT_POINT_NOSHEATHE);
+                            me->HandleEmoteCommand(EMOTE_ONESHOT_POINT_NO_SHEATHE);
                             break;
                         case EVENT_INTRO_CAST_FREEZE:
                             Talk(SAY_LK_INTRO_3);
@@ -902,7 +902,7 @@ class boss_the_lich_king : public CreatureScript
                             break;
                         case EVENT_FINISH_INTRO:
                             me->RemoveUnitMovementFlag(MOVEMENTFLAG_WALKING);
-                            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                             me->SetReactState(REACT_AGGRESSIVE);
                             events.SetPhase(PHASE_ONE);
                             break;
@@ -966,14 +966,14 @@ class boss_the_lich_king : public CreatureScript
                             break;
                         case EVENT_QUAKE:
                             events.SetPhase(PHASE_TWO);
-                            me->ClearUnitState(UNIT_STAT_CASTING);  // clear state to ensure check in DoCastAOE passes
+                            me->ClearUnitState(UNIT_STATE_CASTING);  // clear state to ensure check in DoCastAOE passes
                             DoCastAOE(SPELL_QUAKE);
                             SendMusicToPlayers(MUSIC_SPECIAL);
                             Talk(SAY_LK_QUAKE);
                             break;
                         case EVENT_QUAKE_2:
                             events.SetPhase(PHASE_THREE);
-                            me->ClearUnitState(UNIT_STAT_CASTING);  // clear state to ensure check in DoCastAOE passes
+                            me->ClearUnitState(UNIT_STATE_CASTING);  // clear state to ensure check in DoCastAOE passes
                             DoCastAOE(SPELL_QUAKE);
                             SendMusicToPlayers(MUSIC_SPECIAL);
                             Talk(SAY_LK_QUAKE);
@@ -1043,7 +1043,7 @@ class boss_the_lich_king : public CreatureScript
                             DoCastAOE(SPELL_EMOTE_QUESTION_NO_SHEATH);
                             break;
                         case EVENT_OUTRO_EMOTE_TALK:
-                            me->HandleEmoteCommand(EMOTE_ONESHOT_TALK_NOSHEATHE);
+                            me->HandleEmoteCommand(EMOTE_ONESHOT_TALK_NO_SHEATHE);
                             break;
                         case EVENT_OUTRO_TALK_3:
                             if (Creature* tirion = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_HIGHLORD_TIRION_FORDRING)))
@@ -1059,7 +1059,7 @@ class boss_the_lich_king : public CreatureScript
                             break;
                         case EVENT_OUTRO_RAISE_DEAD:
                             DoCastAOE(SPELL_RAISE_DEAD);
-                            me->ClearUnitState(UNIT_STAT_CASTING);
+                            me->ClearUnitState(UNIT_STATE_CASTING);
                             SendMusicToPlayers(MUSIC_FINAL);
                             break;
                         case EVENT_OUTRO_TALK_5:
@@ -1071,7 +1071,7 @@ class boss_the_lich_king : public CreatureScript
                             Talk(SAY_LK_OUTRO_6);
                             if (Creature* tirion = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_HIGHLORD_TIRION_FORDRING)))
                                 tirion->SetFacingToObject(me);
-                            me->ClearUnitState(UNIT_STAT_CASTING);
+                            me->ClearUnitState(UNIT_STATE_CASTING);
                             DoCastAOE(SPELL_SUMMON_BROKEN_FROSTMOURNE_3);
                             SetEquipmentSlots(false, EQUIP_UNEQUIP);
                             break;
@@ -1255,7 +1255,7 @@ class npc_tirion_fordring_tft : public CreatureScript
 
                 _events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = _events.ExecuteEvent())
@@ -1268,7 +1268,7 @@ class npc_tirion_fordring_tft : public CreatureScript
                             _events.ScheduleEvent(EVENT_INTRO_CHARGE, 5000, 0, PHASE_INTRO);
                             break;
                         case EVENT_INTRO_EMOTE_1:
-                            me->HandleEmoteCommand(EMOTE_ONESHOT_POINT_NOSHEATHE);
+                            me->HandleEmoteCommand(EMOTE_ONESHOT_POINT_NO_SHEATHE);
                             break;
                         case EVENT_INTRO_CHARGE:
                             me->RemoveUnitMovementFlag(MOVEMENTFLAG_WALKING);
@@ -1349,7 +1349,7 @@ class npc_shambling_horror_icc : public CreatureScript
 
                 _events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = _events.ExecuteEvent())
@@ -1429,7 +1429,7 @@ class npc_raging_spirit : public CreatureScript
 
                 _events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = _events.ExecuteEvent())
@@ -1498,7 +1498,7 @@ class npc_valkyr_shadowguard : public CreatureScript
                     _events.Reset();
                     DoCastAOE(SPELL_EJECT_ALL_PASSENGERS);
                     me->GetMotionMaster()->MoveTargetedHome();
-                    me->ClearUnitState(UNIT_STAT_EVADE);
+                    me->ClearUnitState(UNIT_STATE_EVADE);
                 }
             }
 
@@ -1564,7 +1564,7 @@ class npc_valkyr_shadowguard : public CreatureScript
 
                 _events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = _events.ExecuteEvent())
@@ -1825,7 +1825,7 @@ class npc_terenas_menethil : public CreatureScript
                             if (Creature* lichKing = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_THE_LICH_KING)))
                             {
                                 lichKing->AI()->DoAction(ACTION_FINISH_OUTRO);
-                                lichKing->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PASSIVE);
+                                lichKing->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_NPC);
                                 if (Creature* tirion = ObjectAccessor::GetCreature(*me, _instance->GetData64(DATA_HIGHLORD_TIRION_FORDRING)))
                                     tirion->AI()->AttackStart(lichKing);
                             }
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_valithria_dreamwalker.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_valithria_dreamwalker.cpp
index 96072ad..e099317 100644
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_valithria_dreamwalker.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_valithria_dreamwalker.cpp
@@ -426,7 +426,7 @@ class boss_valithria_dreamwalker : public CreatureScript
 
                 _events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = _events.ExecuteEvent())
@@ -626,7 +626,7 @@ class npc_the_lich_king_controller : public CreatureScript
 
                 _events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = _events.ExecuteEvent())
@@ -741,7 +741,7 @@ class npc_risen_archmage : public CreatureScript
 
                 _events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = _events.ExecuteEvent())
@@ -807,7 +807,7 @@ class npc_blazing_skeleton : public CreatureScript
 
                 _events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = _events.ExecuteEvent())
@@ -873,7 +873,7 @@ class npc_suppresser : public CreatureScript
 
                 _events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 // this code will never be reached while channeling
@@ -967,7 +967,7 @@ class npc_gluttonous_abomination : public CreatureScript
 
                 _events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = _events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.cpp b/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.cpp
index bae1ec3..00a6a02 100644
--- a/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.cpp
@@ -477,7 +477,7 @@ class npc_highlord_tirion_fordring_lh : public CreatureScript
                             Talk(SAY_TIRION_INTRO_3);
                             break;
                         case EVENT_LK_INTRO_1:
-                            me->HandleEmoteCommand(EMOTE_ONESHOT_POINT_NOSHEATHE);
+                            me->HandleEmoteCommand(EMOTE_ONESHOT_POINT_NO_SHEATHE);
                             if (Creature* theLichKing = ObjectAccessor::GetCreature(*me, _theLichKing))
                                 theLichKing->AI()->Talk(SAY_LK_INTRO_1);
                             break;
@@ -611,7 +611,7 @@ class npc_rotting_frost_giant : public CreatureScript
 
                 _events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = _events.ExecuteEvent())
@@ -809,7 +809,7 @@ class boss_sister_svalna : public CreatureScript
                     case ACTION_START_GAUNTLET:
                         me->setActive(true);
                         _isEventInProgress = true;
-                        me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_PASSIVE);
+                        me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_IMMUNE_TO_NPC);
                         events.ScheduleEvent(EVENT_SVALNA_START, 25000);
                         break;
                     case ACTION_RESURRECT_CAPTAINS:
@@ -843,7 +843,7 @@ class boss_sister_svalna : public CreatureScript
 
                 _isEventInProgress = false;
                 me->setActive(false);
-                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_PASSIVE);
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_IMMUNE_TO_NPC);
                 me->SetFlying(false);
             }
 
@@ -874,7 +874,7 @@ class boss_sister_svalna : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -1130,7 +1130,7 @@ class npc_crok_scourgebane : public CreatureScript
 
                 _events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = _events.ExecuteEvent())
@@ -1353,7 +1353,7 @@ class npc_captain_arnath : public CreatureScript
 
                 Events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = Events.ExecuteEvent())
@@ -1434,7 +1434,7 @@ class npc_captain_brandon : public CreatureScript
 
                 Events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = Events.ExecuteEvent())
@@ -1502,7 +1502,7 @@ class npc_captain_grondel : public CreatureScript
 
                 Events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = Events.ExecuteEvent())
@@ -1567,7 +1567,7 @@ class npc_captain_rupert : public CreatureScript
 
                 Events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = Events.ExecuteEvent())
@@ -1680,7 +1680,7 @@ class spell_icc_stoneform : public SpellScriptLoader
                 if (Creature* target = GetTarget()->ToCreature())
                 {
                     target->SetReactState(REACT_PASSIVE);
-                    target->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                    target->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_IMMUNE_TO_PC);
                     target->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_STATE_CUSTOM_SPELL_02);
                 }
             }
@@ -1690,7 +1690,7 @@ class spell_icc_stoneform : public SpellScriptLoader
                 if (Creature* target = GetTarget()->ToCreature())
                 {
                     target->SetReactState(REACT_AGGRESSIVE);
-                    target->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                    target->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_IMMUNE_TO_PC);
                     target->SetUInt32Value(UNIT_NPC_EMOTESTATE, 0);
                 }
             }
@@ -1921,7 +1921,7 @@ class spell_svalna_revive_champion : public SpellScriptLoader
                 Position pos;
                 caster->GetPosition(&pos);
                 caster->GetNearPosition(pos, 5.0f, 0.0f);
-                pos.m_positionZ = caster->GetBaseMap()->GetHeight(caster->GetPhaseMask(), pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), true, 20.0f);
+                pos.m_positionZ = caster->GetBaseMap()->GetHeight(pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), true, 20.0f);
                 pos.m_positionZ += 0.05f;
                 caster->SetHomePosition(pos);
                 caster->GetMotionMaster()->MovePoint(POINT_LAND, pos);
diff --git a/src/server/scripts/Northrend/Naxxramas/boss_faerlina.cpp b/src/server/scripts/Northrend/Naxxramas/boss_faerlina.cpp
index 95f07ac..058c5b3 100644
--- a/src/server/scripts/Northrend/Naxxramas/boss_faerlina.cpp
+++ b/src/server/scripts/Northrend/Naxxramas/boss_faerlina.cpp
@@ -137,7 +137,7 @@ class boss_faerlina : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/Naxxramas/boss_four_horsemen.cpp b/src/server/scripts/Northrend/Naxxramas/boss_four_horsemen.cpp
index 2964cb5..47151ef 100644
--- a/src/server/scripts/Northrend/Naxxramas/boss_four_horsemen.cpp
+++ b/src/server/scripts/Northrend/Naxxramas/boss_four_horsemen.cpp
@@ -342,7 +342,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/Naxxramas/boss_gothik.cpp b/src/server/scripts/Northrend/Naxxramas/boss_gothik.cpp
index 4c0efc4..8c6afba 100644
--- a/src/server/scripts/Northrend/Naxxramas/boss_gothik.cpp
+++ b/src/server/scripts/Northrend/Naxxramas/boss_gothik.cpp
@@ -354,7 +354,7 @@ class boss_gothik : public CreatureScript
                 }
                 if (spellId && me->isInCombat())
                 {
-                    me->HandleEmoteCommand(EMOTE_ONESHOT_SPELLCAST);
+                    me->HandleEmoteCommand(EMOTE_ONESHOT_SPELL_CAST);
                     if (Creature* pRandomDeadTrigger = Unit::GetCreature(*me, DeadTriggerGUID[rand() % POS_DEAD]))
                         me->CastSpell(pRandomDeadTrigger, spellId, true);
                 }
@@ -400,7 +400,7 @@ class boss_gothik : public CreatureScript
                         instance->SetData(DATA_GOTHIK_GATE, GO_STATE_ACTIVE);
                 }
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/Naxxramas/boss_kelthuzad.cpp b/src/server/scripts/Northrend/Naxxramas/boss_kelthuzad.cpp
index f70f36e..161c916 100644
--- a/src/server/scripts/Northrend/Naxxramas/boss_kelthuzad.cpp
+++ b/src/server/scripts/Northrend/Naxxramas/boss_kelthuzad.cpp
@@ -486,7 +486,7 @@ public:
                     else uiGuardiansOfIcecrownTimer -= diff;
                 }
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 if (uint32 eventId = events.GetEvent())
diff --git a/src/server/scripts/Northrend/Naxxramas/boss_thaddius.cpp b/src/server/scripts/Northrend/Naxxramas/boss_thaddius.cpp
index be9168c..7977fa4 100644
--- a/src/server/scripts/Northrend/Naxxramas/boss_thaddius.cpp
+++ b/src/server/scripts/Northrend/Naxxramas/boss_thaddius.cpp
@@ -132,12 +132,12 @@ public:
 
             if (!checkFeugenAlive && !checkStalaggAlive)
             {
-                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_STUNNED);
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_STUNNED);
                 me->SetReactState(REACT_AGGRESSIVE);
             }
             else
             {
-                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_STUNNED);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_STUNNED);
                 me->SetReactState(REACT_PASSIVE);
             }
         }
@@ -179,13 +179,13 @@ public:
 
             if (!checkFeugenAlive && !checkStalaggAlive)
             {
-                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_STUNNED);
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_STUNNED);
                 // REACT_AGGRESSIVE only reset when he takes damage.
                 DoZoneInCombat();
             }
             else
             {
-                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_STUNNED);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_STUNNED);
                 me->SetReactState(REACT_PASSIVE);
             }
         }
@@ -248,7 +248,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/Nexus/EyeOfEternity/boss_malygos.cpp b/src/server/scripts/Northrend/Nexus/EyeOfEternity/boss_malygos.cpp
index 052fa3b..6dfa62d 100644
--- a/src/server/scripts/Northrend/Nexus/EyeOfEternity/boss_malygos.cpp
+++ b/src/server/scripts/Northrend/Nexus/EyeOfEternity/boss_malygos.cpp
@@ -523,7 +523,7 @@ public:
                 return;
 
             // We can't cast if we are casting already.
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/Nexus/Nexus/boss_keristrasza.cpp b/src/server/scripts/Northrend/Nexus/Nexus/boss_keristrasza.cpp
index 6a57444..44c6c25 100644
--- a/src/server/scripts/Northrend/Nexus/Nexus/boss_keristrasza.cpp
+++ b/src/server/scripts/Northrend/Nexus/Nexus/boss_keristrasza.cpp
@@ -144,14 +144,14 @@ public:
         {
             if (remove)
             {
-                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                 me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
                 if (me->HasAura(SPELL_FROZEN_PRISON))
                     me->RemoveAurasDueToSpell(SPELL_FROZEN_PRISON);
             }
             else
             {
-                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                 me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
                 DoCast(me, SPELL_FROZEN_PRISON, false);
             }
diff --git a/src/server/scripts/Northrend/Nexus/Oculus/boss_drakos.cpp b/src/server/scripts/Northrend/Nexus/Oculus/boss_drakos.cpp
index fe00f5b..bb75b78 100644
--- a/src/server/scripts/Northrend/Nexus/Oculus/boss_drakos.cpp
+++ b/src/server/scripts/Northrend/Nexus/Oculus/boss_drakos.cpp
@@ -95,7 +95,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/Nexus/Oculus/boss_eregos.cpp b/src/server/scripts/Northrend/Nexus/Oculus/boss_eregos.cpp
index b86e04f..ab814a2 100644
--- a/src/server/scripts/Northrend/Nexus/Oculus/boss_eregos.cpp
+++ b/src/server/scripts/Northrend/Nexus/Oculus/boss_eregos.cpp
@@ -200,7 +200,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/Nexus/Oculus/boss_varos.cpp b/src/server/scripts/Northrend/Nexus/Oculus/boss_varos.cpp
index 28b606c..8852338 100644
--- a/src/server/scripts/Northrend/Nexus/Oculus/boss_varos.cpp
+++ b/src/server/scripts/Northrend/Nexus/Oculus/boss_varos.cpp
@@ -101,7 +101,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
@@ -256,10 +256,10 @@ class spell_varos_centrifuge_shield : public SpellScriptLoader
                 {
                     // flags taken from sniffs
                     // UNIT_FLAG_UNK_9 -> means passive but it is not yet implemented in core
-                    if (caster->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_UNK_15|UNIT_FLAG_PASSIVE|UNIT_FLAG_OOC_NOT_ATTACKABLE|UNIT_FLAG_UNK_6))
+                    if (caster->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_UNK_15|UNIT_FLAG_IMMUNE_TO_NPC|UNIT_FLAG_IMMUNE_TO_PC|UNIT_FLAG_UNK_6))
                     {
                         caster->ToCreature()->SetReactState(REACT_PASSIVE);
-                        caster->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_UNK_15|UNIT_FLAG_PASSIVE|UNIT_FLAG_OOC_NOT_ATTACKABLE|UNIT_FLAG_UNK_6);
+                        caster->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_UNK_15|UNIT_FLAG_IMMUNE_TO_NPC|UNIT_FLAG_IMMUNE_TO_PC|UNIT_FLAG_UNK_6);
                     }
                 }
             }
@@ -269,7 +269,7 @@ class spell_varos_centrifuge_shield : public SpellScriptLoader
                 if (Unit* caster = GetCaster())
                 {
                     caster->ToCreature()->SetReactState(REACT_AGGRESSIVE);
-                    caster->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_UNK_15|UNIT_FLAG_PASSIVE|UNIT_FLAG_OOC_NOT_ATTACKABLE|UNIT_FLAG_UNK_6);
+                    caster->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_UNK_15|UNIT_FLAG_IMMUNE_TO_NPC|UNIT_FLAG_IMMUNE_TO_PC|UNIT_FLAG_UNK_6);
                 }
             }
 
diff --git a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_assembly_of_iron.cpp b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_assembly_of_iron.cpp
index 2c7532f..eadc524 100644
--- a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_assembly_of_iron.cpp
+++ b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_assembly_of_iron.cpp
@@ -283,7 +283,7 @@ class boss_steelbreaker : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -404,7 +404,7 @@ class boss_runemaster_molgeim : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -649,7 +649,7 @@ class boss_stormcaller_brundir : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_auriaya.cpp b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_auriaya.cpp
index 10ff3db..1c478cd 100644
--- a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_auriaya.cpp
+++ b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_auriaya.cpp
@@ -217,7 +217,7 @@ class boss_auriaya : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -348,7 +348,7 @@ class npc_sanctum_sentry : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -418,7 +418,7 @@ class npc_feral_defender : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_flame_leviathan.cpp b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_flame_leviathan.cpp
index a5adeb1..47f74b1 100644
--- a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_flame_leviathan.cpp
+++ b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_flame_leviathan.cpp
@@ -384,7 +384,7 @@ class boss_flame_leviathan : public CreatureScript
                     return;
                 }
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -425,7 +425,7 @@ class boss_flame_leviathan : public CreatureScript
                             break;
                         case EVENT_REPAIR:
                             me->MonsterTextEmote(EMOTE_REPAIR, 0, true);
-                            me->ClearUnitState(UNIT_STAT_STUNNED | UNIT_STAT_ROOT);
+                            me->ClearUnitState(UNIT_STATE_STUNNED | UNIT_STATE_ROOT);
                             events.ScheduleEvent(EVENT_SHUTDOWN, 150*IN_MILLISECONDS);
                             events.CancelEvent(EVENT_REPAIR);
                             break;
@@ -755,7 +755,7 @@ class boss_flame_leviathan_safety_container : public CreatureScript
             {
                 float x, y, z;
                 me->GetPosition(x, y, z);
-                z = me->GetMap()->GetHeight(me->GetPhaseMask(), x, y, z);
+                z = me->GetMap()->GetHeight(x, y, z);
                 me->GetMotionMaster()->MovePoint(0, x, y, z);
                 me->SetPosition(x, y, z, 0);
             }
@@ -1576,7 +1576,7 @@ class spell_systems_shutdown : public SpellScriptLoader
                     return;
 
                 //! This could probably in the SPELL_EFFECT_SEND_EVENT handler too:
-                owner->AddUnitState(UNIT_STAT_STUNNED | UNIT_STAT_ROOT);
+                owner->AddUnitState(UNIT_STATE_STUNNED | UNIT_STATE_ROOT);
                 owner->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
                 owner->RemoveAurasDueToSpell(SPELL_GATHERING_SPEED);
             }
diff --git a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_freya.cpp b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_freya.cpp
index f62c2d6..12d953a 100644
--- a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_freya.cpp
+++ b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_freya.cpp
@@ -401,7 +401,7 @@ class boss_freya : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -739,7 +739,7 @@ class boss_elder_brightleaf : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -872,7 +872,7 @@ class boss_elder_stonebark : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -985,7 +985,7 @@ class boss_elder_ironbranch : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -1372,7 +1372,7 @@ class npc_healthy_spore : public CreatureScript
         {
             npc_healthy_sporeAI(Creature* creature) : Scripted_NoMovementAI(creature)
             {
-                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
                 me->SetReactState(REACT_PASSIVE);
                 DoCast(me, SPELL_HEALTHY_SPORE_VISUAL);
                 DoCast(me, SPELL_POTENT_PHEROMONES);
diff --git a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_general_vezax.cpp b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_general_vezax.cpp
index 0013a97..c7918f8 100644
--- a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_general_vezax.cpp
+++ b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_general_vezax.cpp
@@ -138,7 +138,7 @@ class boss_general_vezax : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -336,7 +336,7 @@ class boss_saronite_animus : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_hodir.cpp b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_hodir.cpp
index 918a401..33f50d0 100644
--- a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_hodir.cpp
+++ b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_hodir.cpp
@@ -370,7 +370,7 @@ class boss_hodir : public CreatureScript
                     me->StopMoving();
                     me->GetMotionMaster()->Clear();
                     me->GetMotionMaster()->MoveIdle();
-                    me->SetControlled(true, UNIT_STAT_STUNNED);
+                    me->SetControlled(true, UNIT_STATE_STUNNED);
                     me->CombatStop(true);
 
                     me->setFaction(35);
@@ -387,7 +387,7 @@ class boss_hodir : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -612,12 +612,12 @@ class npc_hodir_priest : public CreatureScript
 
             void UpdateAI(uint32 const diff)
             {
-                if (!UpdateVictim() || me->HasUnitState(UNIT_STAT_STUNNED) || me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED))
+                if (!UpdateVictim() || me->HasUnitState(UNIT_STATE_STUNNED) || me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED))
                     return;
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 if (HealthBelowPct(30))
@@ -688,12 +688,12 @@ class npc_hodir_shaman : public CreatureScript
 
             void UpdateAI(uint32 const diff)
             {
-                if (!UpdateVictim() || me->HasUnitState(UNIT_STAT_STUNNED) || me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED))
+                if (!UpdateVictim() || me->HasUnitState(UNIT_STATE_STUNNED) || me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED))
                     return;
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -750,12 +750,12 @@ class npc_hodir_druid : public CreatureScript
 
             void UpdateAI(uint32 const diff)
             {
-                if (!UpdateVictim() || me->HasUnitState(UNIT_STAT_STUNNED) || me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED))
+                if (!UpdateVictim() || me->HasUnitState(UNIT_STATE_STUNNED) || me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED))
                     return;
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -825,12 +825,12 @@ class npc_hodir_mage : public CreatureScript
 
             void UpdateAI(uint32 const diff)
             {
-                if (!UpdateVictim() || me->HasUnitState(UNIT_STAT_STUNNED) || me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED))
+                if (!UpdateVictim() || me->HasUnitState(UNIT_STATE_STUNNED) || me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED))
                     return;
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_ignis.cpp b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_ignis.cpp
index e72cf39..d8a3ef0 100644
--- a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_ignis.cpp
+++ b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_ignis.cpp
@@ -202,7 +202,7 @@ class boss_ignis : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_kologarn.cpp b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_kologarn.cpp
index 1fd8430..a156e6e 100644
--- a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_kologarn.cpp
+++ b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_kologarn.cpp
@@ -224,7 +224,7 @@ class boss_kologarn : public CreatureScript
                 summon->CastSpell(summon, SPELL_FOCUSED_EYEBEAM_VISUAL, true);
                 summon->SetReactState(REACT_PASSIVE);
                 // One of the above spells is a channeled spell, we need to clear this unit state for MoveChase to work
-                summon->ClearUnitState(UNIT_STAT_CASTING);
+                summon->ClearUnitState(UNIT_STATE_CASTING);
 
                 // Victim gets 67351
                 if (eyebeamTarget)
@@ -244,7 +244,7 @@ class boss_kologarn : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_razorscale.cpp b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_razorscale.cpp
index 6b170ba..45f9a1f 100644
--- a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_razorscale.cpp
+++ b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_razorscale.cpp
@@ -668,7 +668,7 @@ class npc_expedition_commander : public CreatureScript
                             break;
                         case 4:
                             for (uint8 n = 0; n < RAID_MODE(2, 4); n++)
-                                Engineer[n]->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_STATE_USESTANDING);
+                                Engineer[n]->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_STATE_USE_STANDING);
                             for (uint8 n = 0; n < 4; ++n)
                                 Defender[n]->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_STATE_READY2H);
                             me->MonsterYell(SAY_AGGRO_2, LANG_UNIVERSAL, 0);
diff --git a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_xt002.cpp b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_xt002.cpp
index 8f09ab2..724eb45 100644
--- a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_xt002.cpp
+++ b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_xt002.cpp
@@ -263,7 +263,7 @@ class boss_xt002 : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/UtgardeKeep/UtgardeKeep/boss_ingvar_the_plunderer.cpp b/src/server/scripts/Northrend/UtgardeKeep/UtgardeKeep/boss_ingvar_the_plunderer.cpp
index 0c59097..a11f88f 100644
--- a/src/server/scripts/Northrend/UtgardeKeep/UtgardeKeep/boss_ingvar_the_plunderer.cpp
+++ b/src/server/scripts/Northrend/UtgardeKeep/UtgardeKeep/boss_ingvar_the_plunderer.cpp
@@ -117,7 +117,7 @@ public:
             bIsUndead = false;
             bEventInProgress = false;
 
-            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
             me->SetStandState(UNIT_STAND_STATE_STAND);
 
             events.Reset();
@@ -229,7 +229,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/UtgardeKeep/UtgardeKeep/boss_keleseth.cpp b/src/server/scripts/Northrend/UtgardeKeep/UtgardeKeep/boss_keleseth.cpp
index 94a133c..8a6d7f8 100644
--- a/src/server/scripts/Northrend/UtgardeKeep/UtgardeKeep/boss_keleseth.cpp
+++ b/src/server/scripts/Northrend/UtgardeKeep/UtgardeKeep/boss_keleseth.cpp
@@ -252,7 +252,7 @@ public:
 
             events.Update(diff);
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/UtgardeKeep/UtgardePinnacle/boss_palehoof.cpp b/src/server/scripts/Northrend/UtgardeKeep/UtgardePinnacle/boss_palehoof.cpp
index 0a778f8..656b293 100644
--- a/src/server/scripts/Northrend/UtgardeKeep/UtgardePinnacle/boss_palehoof.cpp
+++ b/src/server/scripts/Northrend/UtgardeKeep/UtgardePinnacle/boss_palehoof.cpp
@@ -268,7 +268,7 @@ public:
 
         void JustReachedHome()
         {
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE|UNIT_FLAG_NOT_SELECTABLE|UNIT_FLAG_NOT_ATTACKABLE_1|UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE|UNIT_FLAG_NOT_SELECTABLE|UNIT_FLAG_NOT_ATTACKABLE_1|UNIT_FLAG_IMMUNE_TO_PC);
             me->SetStandState(UNIT_STAND_STATE_STAND);
             DoCast(me, SPELL_FREEZE);
         }
@@ -381,7 +381,7 @@ public:
 
         void JustReachedHome()
         {
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_NOT_ATTACKABLE_1 | UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_NOT_ATTACKABLE_1 | UNIT_FLAG_IMMUNE_TO_PC);
             me->SetStandState(UNIT_STAND_STATE_STAND);
             DoCast(me, SPELL_FREEZE);
         }
@@ -496,7 +496,7 @@ public:
 
         void JustReachedHome()
         {
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_NOT_ATTACKABLE_1 | UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_NOT_ATTACKABLE_1 | UNIT_FLAG_IMMUNE_TO_PC);
             me->SetStandState(UNIT_STAND_STATE_STAND);
             DoCast(me, SPELL_FREEZE);
         }
@@ -611,7 +611,7 @@ public:
 
         void JustReachedHome()
         {
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_NOT_ATTACKABLE_1 | UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_NOT_ATTACKABLE_1 | UNIT_FLAG_IMMUNE_TO_PC);
             me->SetStandState(UNIT_STAND_STATE_STAND);
             DoCast(me, SPELL_FREEZE);
         }
@@ -732,7 +732,7 @@ public:
 
         void JustReachedHome()
         {
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_NOT_ATTACKABLE_1 | UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_NOT_ATTACKABLE_1 | UNIT_FLAG_IMMUNE_TO_PC);
             me->SetStandState(UNIT_STAND_STATE_STAND);
             DoCast(me, SPELL_FREEZE);
         }
@@ -793,7 +793,7 @@ public:
                    if (pNext)
                    {
                         pNext->RemoveAurasDueToSpell(SPELL_FREEZE);
-                        pNext->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_ATTACKABLE_1 | UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                        pNext->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_ATTACKABLE_1 | UNIT_FLAG_IMMUNE_TO_PC);
                         pNext->SetStandState(UNIT_STAND_STATE_STAND);
                         pNext->SetInCombatWithZone();
                         pNext->Attack(pNext->SelectNearestTarget(100), true);
diff --git a/src/server/scripts/Northrend/UtgardeKeep/UtgardePinnacle/boss_svala.cpp b/src/server/scripts/Northrend/UtgardeKeep/UtgardePinnacle/boss_svala.cpp
index 5c1ec15..989e1e5 100644
--- a/src/server/scripts/Northrend/UtgardeKeep/UtgardePinnacle/boss_svala.cpp
+++ b/src/server/scripts/Northrend/UtgardeKeep/UtgardePinnacle/boss_svala.cpp
@@ -535,7 +535,7 @@ public:
         
         void UpdateAI(const uint32 diff)
         {
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             if (paralyzeTimer <= diff)
@@ -663,7 +663,7 @@ class npc_scourge_hulk : public CreatureScript
                 if (mightyBlow <= diff)
                 {
                     if (Unit* victim = me->getVictim())
-                        if (!victim->HasUnitState(UNIT_STAT_STUNNED))    // Prevent knocking back a ritual player
+                        if (!victim->HasUnitState(UNIT_STATE_STUNNED))    // Prevent knocking back a ritual player
                             DoCast(victim, SPELL_MIGHTY_BLOW);
                     mightyBlow = urand(12000, 17000);
                 }
diff --git a/src/server/scripts/Northrend/VaultOfArchavon/boss_archavon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/boss_archavon.cpp
index 1cc681b..bffc6af 100644
--- a/src/server/scripts/Northrend/VaultOfArchavon/boss_archavon.cpp
+++ b/src/server/scripts/Northrend/VaultOfArchavon/boss_archavon.cpp
@@ -81,7 +81,7 @@ class boss_archavon : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -161,7 +161,7 @@ class mob_archavon_warder : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/VaultOfArchavon/boss_emalon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/boss_emalon.cpp
index 973e7a2..2f4079d 100644
--- a/src/server/scripts/Northrend/VaultOfArchavon/boss_emalon.cpp
+++ b/src/server/scripts/Northrend/VaultOfArchavon/boss_emalon.cpp
@@ -120,7 +120,7 @@ class boss_emalon : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -221,7 +221,7 @@ class mob_tempest_minion : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 if (Aura const* overchargedAura = me->GetAura(SPELL_OVERCHARGED))
diff --git a/src/server/scripts/Northrend/VaultOfArchavon/boss_koralon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/boss_koralon.cpp
index a545a6a..dd9db1c 100644
--- a/src/server/scripts/Northrend/VaultOfArchavon/boss_koralon.cpp
+++ b/src/server/scripts/Northrend/VaultOfArchavon/boss_koralon.cpp
@@ -79,7 +79,7 @@ class boss_koralon : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/Northrend/VaultOfArchavon/boss_toravon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/boss_toravon.cpp
index 4b92b54..162f59f 100644
--- a/src/server/scripts/Northrend/VaultOfArchavon/boss_toravon.cpp
+++ b/src/server/scripts/Northrend/VaultOfArchavon/boss_toravon.cpp
@@ -80,7 +80,7 @@ class boss_toravon : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = events.ExecuteEvent())
@@ -148,7 +148,7 @@ class mob_frost_warder : public CreatureScript
 
                 events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 if (events.ExecuteEvent() == EVENT_FROST_BLAST)
diff --git a/src/server/scripts/Northrend/VioletHold/boss_erekem.cpp b/src/server/scripts/Northrend/VioletHold/boss_erekem.cpp
index 148ae2b..63f0cd3 100644
--- a/src/server/scripts/Northrend/VioletHold/boss_erekem.cpp
+++ b/src/server/scripts/Northrend/VioletHold/boss_erekem.cpp
@@ -97,7 +97,7 @@ public:
 
         void AttackStart(Unit* who)
         {
-            if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE) || me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
+            if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC) || me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
                 return;
 
             if (me->Attack(who, true))
@@ -109,13 +109,13 @@ public:
 
                 if (Creature* pGuard1 = Unit::GetCreature(*me, instance ? instance->GetData64(DATA_EREKEM_GUARD_1) : 0))
                 {
-                    pGuard1->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE|UNIT_FLAG_NON_ATTACKABLE);
+                    pGuard1->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC|UNIT_FLAG_NON_ATTACKABLE);
                     if (!pGuard1->getVictim() && pGuard1->AI())
                         pGuard1->AI()->AttackStart(who);
                 }
                 if (Creature* pGuard2 = Unit::GetCreature(*me, instance ? instance->GetData64(DATA_EREKEM_GUARD_2) : 0))
                 {
-                    pGuard2->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE|UNIT_FLAG_NON_ATTACKABLE);
+                    pGuard2->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC|UNIT_FLAG_NON_ATTACKABLE);
                     if (!pGuard2->getVictim() && pGuard2->AI())
                         pGuard2->AI()->AttackStart(who);
                 }
@@ -290,7 +290,7 @@ public:
 
         void AttackStart(Unit* who)
         {
-            if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE) || me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
+            if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC) || me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
                 return;
 
             if (me->Attack(who, true))
diff --git a/src/server/scripts/Northrend/VioletHold/boss_ichoron.cpp b/src/server/scripts/Northrend/VioletHold/boss_ichoron.cpp
index 5b36481..a191d93 100644
--- a/src/server/scripts/Northrend/VioletHold/boss_ichoron.cpp
+++ b/src/server/scripts/Northrend/VioletHold/boss_ichoron.cpp
@@ -140,7 +140,7 @@ public:
 
         void AttackStart(Unit* who)
         {
-            if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE) || me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
+            if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC) || me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
                 return;
 
             if (me->Attack(who, true))
diff --git a/src/server/scripts/Northrend/VioletHold/boss_lavanthor.cpp b/src/server/scripts/Northrend/VioletHold/boss_lavanthor.cpp
index 21e4df3..c5b2cb3 100644
--- a/src/server/scripts/Northrend/VioletHold/boss_lavanthor.cpp
+++ b/src/server/scripts/Northrend/VioletHold/boss_lavanthor.cpp
@@ -87,7 +87,7 @@ public:
 
         void AttackStart(Unit* who)
         {
-            if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE) || me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
+            if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC) || me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
                 return;
 
             if (me->Attack(who, true))
diff --git a/src/server/scripts/Northrend/VioletHold/boss_moragg.cpp b/src/server/scripts/Northrend/VioletHold/boss_moragg.cpp
index 08bc243..84b0457 100644
--- a/src/server/scripts/Northrend/VioletHold/boss_moragg.cpp
+++ b/src/server/scripts/Northrend/VioletHold/boss_moragg.cpp
@@ -80,7 +80,7 @@ public:
 
         void AttackStart(Unit* who)
         {
-            if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE) || me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
+            if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC) || me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
                 return;
 
             if (me->Attack(who, true))
diff --git a/src/server/scripts/Northrend/VioletHold/boss_xevozz.cpp b/src/server/scripts/Northrend/VioletHold/boss_xevozz.cpp
index 095d63f..ac165ac 100644
--- a/src/server/scripts/Northrend/VioletHold/boss_xevozz.cpp
+++ b/src/server/scripts/Northrend/VioletHold/boss_xevozz.cpp
@@ -123,7 +123,7 @@ public:
 
         void AttackStart(Unit* who)
         {
-            if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE) || me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
+            if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC) || me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
                 return;
 
             if (me->Attack(who, true))
diff --git a/src/server/scripts/Northrend/VioletHold/boss_zuramat.cpp b/src/server/scripts/Northrend/VioletHold/boss_zuramat.cpp
index dc47785..ff2009c 100644
--- a/src/server/scripts/Northrend/VioletHold/boss_zuramat.cpp
+++ b/src/server/scripts/Northrend/VioletHold/boss_zuramat.cpp
@@ -91,7 +91,7 @@ public:
 
         void AttackStart(Unit* who)
         {
-            if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE) || me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
+            if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC) || me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
                 return;
 
             if (me->Attack(who, true))
diff --git a/src/server/scripts/Northrend/VioletHold/instance_violet_hold.cpp b/src/server/scripts/Northrend/VioletHold/instance_violet_hold.cpp
index 3db63e5..5980c53 100644
--- a/src/server/scripts/Northrend/VioletHold/instance_violet_hold.cpp
+++ b/src/server/scripts/Northrend/VioletHold/instance_violet_hold.cpp
@@ -249,7 +249,7 @@ public:
                     if (uiCountErekemGuards < 2)
                     {
                         uiErekemGuard[uiCountErekemGuards++] = creature->GetGUID();
-                        creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE|UNIT_FLAG_NON_ATTACKABLE);
+                        creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC|UNIT_FLAG_NON_ATTACKABLE);
                     }
                     break;
                 case CREATURE_MORAGG:
@@ -257,7 +257,7 @@ public:
                     break;
                 case CREATURE_CYANIGOSA:
                     uiCyanigosa = creature->GetGUID();
-                    creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE|UNIT_FLAG_NON_ATTACKABLE);
+                    creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC|UNIT_FLAG_NON_ATTACKABLE);
                     break;
                 case CREATURE_SINCLARI:
                     uiSinclari = creature->GetGUID();
@@ -499,18 +499,18 @@ public:
                     if (Creature* pGuard1 = instance->GetCreature(uiErekemGuard[0]))
                     {
                         if (bForceRespawn)
-                            pGuard1->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE|UNIT_FLAG_NON_ATTACKABLE);
+                            pGuard1->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC|UNIT_FLAG_NON_ATTACKABLE);
                         else
-                            pGuard1->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE|UNIT_FLAG_NON_ATTACKABLE);
+                            pGuard1->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC|UNIT_FLAG_NON_ATTACKABLE);
                         pGuard1->GetMotionMaster()->MovePoint(0, BossStartMove21);
                     }
 
                     if (Creature* pGuard2 = instance->GetCreature(uiErekemGuard[1]))
                     {
                         if (bForceRespawn)
-                            pGuard2->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE|UNIT_FLAG_NON_ATTACKABLE);
+                            pGuard2->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC|UNIT_FLAG_NON_ATTACKABLE);
                         else
-                            pGuard2->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE|UNIT_FLAG_NON_ATTACKABLE);
+                            pGuard2->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC|UNIT_FLAG_NON_ATTACKABLE);
                         pGuard2->GetMotionMaster()->MovePoint(0, BossStartMove22);
                     }
                     break;
@@ -543,7 +543,7 @@ public:
             // generic boss state changes
             if (pBoss)
             {
-                pBoss->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE|UNIT_FLAG_NON_ATTACKABLE);
+                pBoss->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC|UNIT_FLAG_NON_ATTACKABLE);
                 pBoss->SetReactState(REACT_AGGRESSIVE);
 
                 if (!bForceRespawn)
@@ -554,7 +554,7 @@ public:
                         pBoss->Respawn();
                         pBoss->RemoveLootMode(1);
                     }
-                    pBoss->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE|UNIT_FLAG_NON_ATTACKABLE);
+                    pBoss->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC|UNIT_FLAG_NON_ATTACKABLE);
                     uiWaveCount = 0;
                 }
             }
@@ -750,7 +750,7 @@ public:
                         case 3:
                             pCyanigosa->RemoveAurasDueToSpell(CYANIGOSA_BLUE_AURA);
                             pCyanigosa->CastSpell(pCyanigosa, CYANIGOSA_SPELL_TRANSFORM, 0);
-                            pCyanigosa->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE|UNIT_FLAG_NON_ATTACKABLE);
+                            pCyanigosa->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC|UNIT_FLAG_NON_ATTACKABLE);
                             pCyanigosa->SetReactState(REACT_AGGRESSIVE);
                             uiCyanigosaEventTimer = 2*IN_MILLISECONDS;
                             ++uiCyanigosaEventPhase;
diff --git a/src/server/scripts/Northrend/VioletHold/violet_hold.cpp b/src/server/scripts/Northrend/VioletHold/violet_hold.cpp
index 617ce96..8b77cb2 100644
--- a/src/server/scripts/Northrend/VioletHold/violet_hold.cpp
+++ b/src/server/scripts/Northrend/VioletHold/violet_hold.cpp
@@ -443,7 +443,7 @@ public:
             if (instance && !uiBoss)
                 uiBoss = instance->GetData(DATA_WAVE_COUNT) == 6 ? instance->GetData(DATA_FIRST_BOSS) : instance->GetData(DATA_SECOND_BOSS);
             me->SetReactState(REACT_PASSIVE);
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE|UNIT_FLAG_NON_ATTACKABLE);
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC|UNIT_FLAG_NON_ATTACKABLE);
             me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
         }
 
diff --git a/src/server/scripts/Northrend/borean_tundra.cpp b/src/server/scripts/Northrend/borean_tundra.cpp
index b6e01d3..11fb093 100644
--- a/src/server/scripts/Northrend/borean_tundra.cpp
+++ b/src/server/scripts/Northrend/borean_tundra.cpp
@@ -1328,7 +1328,7 @@ public:
             if (uiType != POINT_MOTION_TYPE)
                 return;
 
-            me->AddUnitState(UNIT_STAT_STUNNED);
+            me->AddUnitState(UNIT_STATE_STUNNED);
             me->CastSpell(me, SPELL_STUN, true);
             if (me->isSummon())
                 if (Unit* summoner = me->ToTempSummon()->GetSummoner())
@@ -1445,7 +1445,7 @@ public:
             DoScriptText(SAY_LERYSSA_1, pLeryssa);
             pArlos->Kill(pArlos, false);
             pLeryssa->RemoveAura(SPELL_STUN);
-            pLeryssa->ClearUnitState(UNIT_STAT_STUNNED);
+            pLeryssa->ClearUnitState(UNIT_STATE_STUNNED);
             pLeryssa->RemoveUnitMovementFlag(MOVEMENTFLAG_WALKING);
             pLeryssa->GetMotionMaster()->MovePoint(0, 3722.114502f, 3564.201660f, 477.441437f);
 
@@ -1495,7 +1495,7 @@ public:
                 if (Creature* pTalbot = me->FindNearestCreature(NPC_PRINCE_VALANAR, 50.0f, true))
                     CAST_AI(npc_counselor_talbot::npc_counselor_talbotAI, pTalbot->GetAI())->bCheck = true;
 
-                me->AddUnitState(UNIT_STAT_STUNNED);
+                me->AddUnitState(UNIT_STATE_STUNNED);
                 me->CastSpell(me, SPELL_STUN, true);
 
                 if (me->isSummon())
diff --git a/src/server/scripts/Northrend/grizzly_hills.cpp b/src/server/scripts/Northrend/grizzly_hills.cpp
index 9eb7346..ccb31c8 100644
--- a/src/server/scripts/Northrend/grizzly_hills.cpp
+++ b/src/server/scripts/Northrend/grizzly_hills.cpp
@@ -370,7 +370,7 @@ public:
                 if (me->FindNearestGameObject(OBJECT_HAUNCH, 2.0f))
                 {
                     me->SetStandState(UNIT_STAND_STATE_DEAD);
-                    me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                    me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                     me->SetUInt32Value(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_DEAD);
                 }
                 m_uiPhase = 0;
@@ -415,7 +415,7 @@ public:
             // call this each update tick?
             if (me->FindNearestCreature(TALLHORN_STAG, 0.2f))
             {
-                me->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_STATE_USESTANDING);
+                me->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_STATE_USE_STANDING);
             }
             else
                 if (m_uiPhase)
@@ -624,7 +624,7 @@ public:
             uiPlayerGUID = 0;
             uiTimer = 0;
             uiChopTimer = urand(10000, 12500);
-            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
             me->SetReactState(REACT_AGGRESSIVE);
         }
 
@@ -683,7 +683,7 @@ public:
         {
             if (pCaster && pCaster->GetTypeId() == TYPEID_PLAYER && pSpell->Id == SPELL_SMOKE_BOMB)
             {
-                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
                 me->SetReactState(REACT_PASSIVE);
                 me->CombatStop(false);
                 uiPlayerGUID = pCaster->GetGUID();
diff --git a/src/server/scripts/Northrend/zuldrak.cpp b/src/server/scripts/Northrend/zuldrak.cpp
index 2b73d57..0af8234 100644
--- a/src/server/scripts/Northrend/zuldrak.cpp
+++ b/src/server/scripts/Northrend/zuldrak.cpp
@@ -586,7 +586,7 @@ public:
     {
         npc_orinoko_tuskbreakerAI(Creature* creature) : ScriptedAI(creature)
         {
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
             me->SetReactState(REACT_PASSIVE);
         }
 
@@ -622,7 +622,7 @@ public:
             if (uiType != POINT_MOTION_TYPE)
                 return;
 
-            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
             me->SetReactState(REACT_AGGRESSIVE);
             me->SetHomePosition(me->GetPositionX(), me->GetPositionY(), me->GetPositionZ(), me->GetOrientation());
             uiBattleShoutTimer  = 7000;
@@ -734,7 +734,7 @@ public:
 
         void Reset()
         {
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
             me->SetReactState(REACT_PASSIVE);
             uiChargeTimer = 15000;
             uiUppercutTimer = 12000;
@@ -747,7 +747,7 @@ public:
             {
                 case 6:
                     me->SetHomePosition(me->GetPositionX(), me->GetPositionY(), me->GetPositionZ(), 0);
-                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                     me->SetReactState(REACT_AGGRESSIVE);
                     break;
             }
@@ -914,7 +914,7 @@ public:
     {
         npc_stinkbeardAI(Creature* creature) : npc_escortAI(creature)
         {
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
             me->SetReactState(REACT_PASSIVE);
             Start(true, true, 0, NULL);
             SetDespawnAtEnd(false);
@@ -940,7 +940,7 @@ public:
             switch (uiI)
             {
                 case 7:
-                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                     me->SetReactState(REACT_AGGRESSIVE);
                     me->SetHomePosition(me->GetPositionX(), me->GetPositionY(), me->GetPositionZ(), me->GetOrientation());
                     break;
diff --git a/src/server/scripts/Outland/Auchindoun/AuchenaiCrypts/boss_shirrak_the_dead_watcher.cpp b/src/server/scripts/Outland/Auchindoun/AuchenaiCrypts/boss_shirrak_the_dead_watcher.cpp
index a8d1f22..d359917 100644
--- a/src/server/scripts/Outland/Auchindoun/AuchenaiCrypts/boss_shirrak_the_dead_watcher.cpp
+++ b/src/server/scripts/Outland/Auchindoun/AuchenaiCrypts/boss_shirrak_the_dead_watcher.cpp
@@ -82,7 +82,7 @@ public:
                 summoned->CastSpell(summoned, SPELL_FOCUS_FIRE_VISUAL, false);
                 summoned->setFaction(me->getFaction());
                 summoned->SetLevel(me->getLevel());
-                summoned->AddUnitState(UNIT_STAT_ROOT);
+                summoned->AddUnitState(UNIT_STATE_ROOT);
 
                 if (Unit* pFocusedTarget = Unit::GetUnit(*me, FocusedTargetGUID))
                     summoned->AI()->AttackStart(pFocusedTarget);
diff --git a/src/server/scripts/Outland/BlackTemple/boss_illidan.cpp b/src/server/scripts/Outland/BlackTemple/boss_illidan.cpp
index c17b6d5..58f0e10 100644
--- a/src/server/scripts/Outland/BlackTemple/boss_illidan.cpp
+++ b/src/server/scripts/Outland/BlackTemple/boss_illidan.cpp
@@ -1865,7 +1865,7 @@ void boss_illidan_stormrage::boss_illidan_stormrageAI::Reset()
     TransformCount = 0;
 
     me->SetDisplayId(21135);
-    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
     me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
     me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
     SetEquipmentSlots(false, EQUIP_UNEQUIP, EQUIP_UNEQUIP, EQUIP_NO_CHANGE);
diff --git a/src/server/scripts/Outland/BlackTemple/boss_teron_gorefiend.cpp b/src/server/scripts/Outland/BlackTemple/boss_teron_gorefiend.cpp
index 278488e..15c7cdb 100644
--- a/src/server/scripts/Outland/BlackTemple/boss_teron_gorefiend.cpp
+++ b/src/server/scripts/Outland/BlackTemple/boss_teron_gorefiend.cpp
@@ -435,7 +435,7 @@ public:
                     float X = CalculateRandomLocation(target->GetPositionX(), 20);
                     float Y = CalculateRandomLocation(target->GetPositionY(), 20);
                     float Z = target->GetPositionZ();
-                    Z = me->GetMap()->GetHeight(me->GetPhaseMask(), X, Y, Z);
+                    Z = me->GetMap()->GetHeight(X, Y, Z);
                     Creature* DoomBlossom = me->SummonCreature(CREATURE_DOOM_BLOSSOM, X, Y, Z, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 20000);
                     if (DoomBlossom)
                     {
diff --git a/src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/boss_lurker_below.cpp b/src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/boss_lurker_below.cpp
index 3c06efe..0ed9d8e 100644
--- a/src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/boss_lurker_below.cpp
+++ b/src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/boss_lurker_below.cpp
@@ -136,7 +136,7 @@ public:
             DoCast(me, SPELL_SUBMERGE);//submerge anim
             me->SetVisible(false);//we start invis under water, submerged
             me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
         }
 
         void JustDied(Unit* /*Killer*/)
@@ -205,7 +205,7 @@ public:
                     {
                         WaitTimer = 3000;
                         CanStartEvent = true;//fresh fished from pool
-                        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                         me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
                     }
                     else
@@ -325,7 +325,7 @@ public:
                     Submerged = false;
                     me->InterruptNonMeleeSpells(false);//shouldn't be any
                     me->RemoveAllAuras();
-                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                     me->RemoveFlag(UNIT_NPC_EMOTESTATE, EMOTE_STATE_SUBMERGED);
                     DoCast(me, SPELL_EMERGE, true);
                     Spawned = false;
@@ -344,7 +344,7 @@ public:
 
                 if (!Spawned)
                 {
-                    me->SetUInt32Value(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                    me->SetUInt32Value(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                     //spawn adds
                     for (uint8 i = 0; i < 9; ++i)
                     {
diff --git a/src/server/scripts/Outland/HellfireCitadel/HellfireRamparts/boss_vazruden_the_herald.cpp b/src/server/scripts/Outland/HellfireCitadel/HellfireRamparts/boss_vazruden_the_herald.cpp
index 71e7730..ecea5e6 100644
--- a/src/server/scripts/Outland/HellfireCitadel/HellfireRamparts/boss_vazruden_the_herald.cpp
+++ b/src/server/scripts/Outland/HellfireCitadel/HellfireRamparts/boss_vazruden_the_herald.cpp
@@ -337,7 +337,7 @@ class boss_vazruden_the_herald : public CreatureScript
                         VazrudenGUID = 0;
                     }
                     summoned = false;
-                    me->ClearUnitState(UNIT_STAT_ROOT);
+                    me->ClearUnitState(UNIT_STATE_ROOT);
                     me->SetVisible(true);
                 }
             }
@@ -352,7 +352,7 @@ class boss_vazruden_the_herald : public CreatureScript
                         NazanGUID = Nazan->GetGUID();
                     summoned = true;
                     me->SetVisible(false);
-                    me->AddUnitState(UNIT_STAT_ROOT);
+                    me->AddUnitState(UNIT_STATE_ROOT);
                 }
             }
 
diff --git a/src/server/scripts/Outland/HellfireCitadel/MagtheridonsLair/boss_magtheridon.cpp b/src/server/scripts/Outland/HellfireCitadel/MagtheridonsLair/boss_magtheridon.cpp
index 1679efb..c355079 100644
--- a/src/server/scripts/Outland/HellfireCitadel/MagtheridonsLair/boss_magtheridon.cpp
+++ b/src/server/scripts/Outland/HellfireCitadel/MagtheridonsLair/boss_magtheridon.cpp
@@ -252,8 +252,8 @@ class boss_magtheridon : public CreatureScript
 
                 me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
                 me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
-                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
-                me->AddUnitState(UNIT_STAT_STUNNED);
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
+                me->AddUnitState(UNIT_STATE_STUNNED);
                 DoCast(me, SPELL_SHADOW_CAGE_C, true);
             }
 
@@ -334,7 +334,7 @@ class boss_magtheridon : public CreatureScript
 
             void AttackStart(Unit* who)
             {
-                if (!me->HasUnitState(UNIT_STAT_STUNNED))
+                if (!me->HasUnitState(UNIT_STATE_STUNNED))
                     ScriptedAI::AttackStart(who);
             }
 
@@ -388,7 +388,7 @@ class boss_magtheridon : public CreatureScript
                 if (BlastNova_Timer <= diff)
                 {
                     // to avoid earthquake interruption
-                    if (!me->HasUnitState(UNIT_STAT_STUNNED))
+                    if (!me->HasUnitState(UNIT_STATE_STUNNED))
                     {
                         DoScriptText(EMOTE_BLASTNOVA, me);
                         DoCast(me, SPELL_BLASTNOVA);
@@ -431,7 +431,7 @@ class boss_magtheridon : public CreatureScript
 
                 if (!Phase3 && HealthBelowPct(30)
                     && !me->IsNonMeleeSpellCasted(false) // blast nova
-                    && !me->HasUnitState(UNIT_STAT_STUNNED)) // shadow cage and earthquake
+                    && !me->HasUnitState(UNIT_STATE_STUNNED)) // shadow cage and earthquake
                 {
                     Phase3 = true;
                     DoScriptText(SAY_CHAMBER_DESTROY, me);
diff --git a/src/server/scripts/Outland/HellfireCitadel/MagtheridonsLair/instance_magtheridons_lair.cpp b/src/server/scripts/Outland/HellfireCitadel/MagtheridonsLair/instance_magtheridons_lair.cpp
index 9d52a0a..caaedc4 100644
--- a/src/server/scripts/Outland/HellfireCitadel/MagtheridonsLair/instance_magtheridons_lair.cpp
+++ b/src/server/scripts/Outland/HellfireCitadel/MagtheridonsLair/instance_magtheridons_lair.cpp
@@ -223,7 +223,7 @@ class instance_magtheridons_lair : public InstanceMapScript
                         Creature* Magtheridon = instance->GetCreature(MagtheridonGUID);
                         if (Magtheridon && Magtheridon->isAlive())
                         {
-                            Magtheridon->ClearUnitState(UNIT_STAT_STUNNED);
+                            Magtheridon->ClearUnitState(UNIT_STATE_STUNNED);
                             Magtheridon->AI()->AttackStart(Magtheridon->SelectNearestTarget(999));
                         }
                         CageTimer = 0;
diff --git a/src/server/scripts/Outland/TempestKeep/Eye/boss_kaelthas.cpp b/src/server/scripts/Outland/TempestKeep/Eye/boss_kaelthas.cpp
index a45576f..904b285 100644
--- a/src/server/scripts/Outland/TempestKeep/Eye/boss_kaelthas.cpp
+++ b/src/server/scripts/Outland/TempestKeep/Eye/boss_kaelthas.cpp
@@ -397,7 +397,7 @@ class boss_kaelthas : public CreatureScript
 
             void MoveInLineOfSight(Unit* who)
             {
-                if (!me->HasUnitState(UNIT_STAT_STUNNED) && me->canCreatureAttack(who))
+                if (!me->HasUnitState(UNIT_STATE_STUNNED) && me->canCreatureAttack(who))
                 {
                     if (!me->canFly() && me->GetDistanceZ(who) > CREATURE_Z_ATTACK_RANGE)
                         return;
diff --git a/src/server/scripts/Outland/TempestKeep/arcatraz/boss_harbinger_skyriss.cpp b/src/server/scripts/Outland/TempestKeep/arcatraz/boss_harbinger_skyriss.cpp
index 327ca28..de86ec8 100644
--- a/src/server/scripts/Outland/TempestKeep/arcatraz/boss_harbinger_skyriss.cpp
+++ b/src/server/scripts/Outland/TempestKeep/arcatraz/boss_harbinger_skyriss.cpp
@@ -89,7 +89,7 @@ class boss_harbinger_skyriss : public CreatureScript
             void Reset()
             {
                 if (!Intro)
-                    me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                    me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
 
                 IsImage33 = false;
                 IsImage66 = false;
@@ -184,7 +184,7 @@ class boss_harbinger_skyriss : public CreatureScript
                             Intro_Timer = 3000;
                             break;
                         case 3:
-                            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
                             Intro = true;
                             break;
                         }
diff --git a/src/server/scripts/Outland/boss_doomlord_kazzak.cpp b/src/server/scripts/Outland/boss_doomlord_kazzak.cpp
index 4a83181..2f6e082 100644
--- a/src/server/scripts/Outland/boss_doomlord_kazzak.cpp
+++ b/src/server/scripts/Outland/boss_doomlord_kazzak.cpp
@@ -110,7 +110,7 @@ class boss_doomlord_kazzak : public CreatureScript
 
                 _events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = _events.ExecuteEvent())
diff --git a/src/server/scripts/Outland/boss_doomwalker.cpp b/src/server/scripts/Outland/boss_doomwalker.cpp
index 8836016..c4bd232 100644
--- a/src/server/scripts/Outland/boss_doomwalker.cpp
+++ b/src/server/scripts/Outland/boss_doomwalker.cpp
@@ -103,7 +103,7 @@ class boss_doomwalker : public CreatureScript
 
                 _events.Update(diff);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
+                if (me->HasUnitState(UNIT_STATE_CASTING))
                     return;
 
                 while (uint32 eventId = _events.ExecuteEvent())
diff --git a/src/server/scripts/Outland/nagrand.cpp b/src/server/scripts/Outland/nagrand.cpp
index c27ad8e..668db2e 100644
--- a/src/server/scripts/Outland/nagrand.cpp
+++ b/src/server/scripts/Outland/nagrand.cpp
@@ -632,7 +632,7 @@ public:
             if (!UpdateVictim())
                 return;
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             if (ChainLightningTimer <= diff)
diff --git a/src/server/scripts/Outland/netherstorm.cpp b/src/server/scripts/Outland/netherstorm.cpp
index efebf7d..7981106 100644
--- a/src/server/scripts/Outland/netherstorm.cpp
+++ b/src/server/scripts/Outland/netherstorm.cpp
@@ -796,7 +796,7 @@ public:
                 Materialize = true;
             }
 
-            if (me->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED) || me->HasUnitState(UNIT_STAT_ROOT)) // if the mob is rooted/slowed by spells eg.: Entangling Roots, Frost Nova, Hamstring, Crippling Poison, etc. => remove it
+            if (me->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED) || me->HasUnitState(UNIT_STATE_ROOT)) // if the mob is rooted/slowed by spells eg.: Entangling Roots, Frost Nova, Hamstring, Crippling Poison, etc. => remove it
                 DoCast(me, SPELL_PHASE_SLIP);
 
             if (!UpdateVictim())
diff --git a/src/server/scripts/Outland/shadowmoon_valley.cpp b/src/server/scripts/Outland/shadowmoon_valley.cpp
index e4c4e02..19c4754 100644
--- a/src/server/scripts/Outland/shadowmoon_valley.cpp
+++ b/src/server/scripts/Outland/shadowmoon_valley.cpp
@@ -117,7 +117,7 @@ public:
             {
                 bIsEating = true;
                 EatTimer = 7000;
-                me->HandleEmoteCommand(EMOTE_ONESHOT_ATTACKUNARMED);
+                me->HandleEmoteCommand(EMOTE_ONESHOT_ATTACK_UNARMED);
             }
         }
 
@@ -1195,7 +1195,7 @@ public:
             AggroTargetGUID = 0;
             Timers = false;
 
-            me->AddUnitState(UNIT_STAT_ROOT);
+            me->AddUnitState(UNIT_STATE_ROOT);
             me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
             me->SetTarget(0);
         }
@@ -1239,7 +1239,7 @@ public:
                 if (Player* AggroTarget = (Unit::GetPlayer(*me, AggroTargetGUID)))
                 {
                     me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-                    me->ClearUnitState(UNIT_STAT_ROOT);
+                    me->ClearUnitState(UNIT_STATE_ROOT);
 
                     float x, y, z;
                     AggroTarget->GetPosition(x, y, z);
diff --git a/src/server/scripts/Spells/spell_generic.cpp b/src/server/scripts/Spells/spell_generic.cpp
index 3d55290..6fc9373 100644
--- a/src/server/scripts/Spells/spell_generic.cpp
+++ b/src/server/scripts/Spells/spell_generic.cpp
@@ -2041,11 +2041,8 @@ class spell_gen_summon_tournament_mount : public SpellScriptLoader
 
             SpellCastResult CheckIfLanceEquiped()
             {
-                if (GetCaster()->HasAuraType(SPELL_AURA_MOD_SHAPESHIFT))
-                {
-                    SetCustomCastResultMessage(SPELL_CUSTOM_ERROR_CANT_MOUNT_WITH_SHAPESHIFT);
-                    return SPELL_FAILED_CUSTOM_ERROR;
-                }
+                if (GetCaster()->IsInDisallowedMountForm())
+                    GetCaster()->RemoveAurasByType(SPELL_AURA_MOD_SHAPESHIFT);
 
                 if (!GetCaster()->HasAura(SPELL_LANCE_EQUIPPED))
                 {
diff --git a/src/server/scripts/Spells/spell_quest.cpp b/src/server/scripts/Spells/spell_quest.cpp
index d266b42..940e494 100644
--- a/src/server/scripts/Spells/spell_quest.cpp
+++ b/src/server/scripts/Spells/spell_quest.cpp
@@ -223,13 +223,13 @@ public:
         void HandleEffectApply(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*mode*/)
         {
             Unit* target = GetTarget();
-            target->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
-            target->AddUnitState(UNIT_STAT_ROOT);
+            target->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
+            target->AddUnitState(UNIT_STATE_ROOT);
         }
 
         void HandleEffectRemove(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*mode*/)
         {
-            GetTarget()->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            GetTarget()->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
         }
 
         void Register()
diff --git a/src/server/scripts/World/boss_emerald_dragons.cpp b/src/server/scripts/World/boss_emerald_dragons.cpp
index 9deecea..9f652e7 100644
--- a/src/server/scripts/World/boss_emerald_dragons.cpp
+++ b/src/server/scripts/World/boss_emerald_dragons.cpp
@@ -144,7 +144,7 @@ struct emerald_dragonAI : public WorldBossAI
 
         events.Update(diff);
 
-        if (me->HasUnitState(UNIT_STAT_CASTING))
+        if (me->HasUnitState(UNIT_STATE_CASTING))
             return;
 
         while (uint32 eventId = events.ExecuteEvent())
diff --git a/src/server/scripts/World/item_scripts.cpp b/src/server/scripts/World/item_scripts.cpp
index 521e38a..165ef9f 100644
--- a/src/server/scripts/World/item_scripts.cpp
+++ b/src/server/scripts/World/item_scripts.cpp
@@ -242,7 +242,7 @@ public:
         {
             summon->SetVisible(false);
             summon->SetReactState(REACT_PASSIVE);
-            summon->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            summon->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
         }
         return false;
     }
diff --git a/src/server/scripts/World/npcs_special.cpp b/src/server/scripts/World/npcs_special.cpp
index 9227c0c..04e9c05 100644
--- a/src/server/scripts/World/npcs_special.cpp
+++ b/src/server/scripts/World/npcs_special.cpp
@@ -1738,6 +1738,12 @@ public:
             if (!UpdateVictim())
                 return;
 
+            if (me->getVictim()->HasBreakableByDamageCrowdControlAura())
+            {
+                me->InterruptNonMeleeSpells(false);
+                return;
+            }
+
             if (SpellTimer <= diff)
             {
                 if (IsViper) //Viper
@@ -1910,7 +1916,7 @@ public:
             Unit* owner = me->GetCharmerOrOwner();
 
             me->CombatStop(true);
-            if (owner && !me->HasUnitState(UNIT_STAT_FOLLOW))
+            if (owner && !me->HasUnitState(UNIT_STATE_FOLLOW))
             {
                 me->GetMotionMaster()->Clear(false);
                 me->GetMotionMaster()->MoveFollow(owner, PET_FOLLOW_DIST, me->GetFollowAngle(), MOTION_SLOT_ACTIVE);
@@ -2069,7 +2075,7 @@ public:
 
         void Reset()
         {
-            me->SetControlled(true, UNIT_STAT_STUNNED);//disable rotate
+            me->SetControlled(true, UNIT_STATE_STUNNED);//disable rotate
             me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_KNOCK_BACK, true);//imune to knock aways like blast wave
 
             ResetTimer = 5000;
@@ -2101,8 +2107,8 @@ public:
             if (!UpdateVictim())
                 return;
 
-            if (!me->HasUnitState(UNIT_STAT_STUNNED))
-                me->SetControlled(true, UNIT_STAT_STUNNED);//disable rotate
+            if (!me->HasUnitState(UNIT_STATE_STUNNED))
+                me->SetControlled(true, UNIT_STATE_STUNNED);//disable rotate
 
             if (Entry != NPC_ADVANCED_TARGET_DUMMY && Entry != NPC_TARGET_DUMMY)
             {
@@ -2203,7 +2209,7 @@ public:
             if (!UpdateVictim())
                 return;
 
-            if (me->HasUnitState(UNIT_STAT_CASTING))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             if (FireShield_Timer <= diff)
diff --git a/src/server/worldserver/CMakeLists.txt b/src/server/worldserver/CMakeLists.txt
index b3254fe..191bbbf 100644
--- a/src/server/worldserver/CMakeLists.txt
+++ b/src/server/worldserver/CMakeLists.txt
@@ -44,14 +44,12 @@ endif()
 
 include_directories(
   ${CMAKE_BINARY_DIR}
-  ${CMAKE_SOURCE_DIR}/dep/g3dlite/include
   ${CMAKE_SOURCE_DIR}/dep/gsoap
   ${CMAKE_SOURCE_DIR}/dep/sockets/include
   ${CMAKE_SOURCE_DIR}/dep/SFMT
   ${CMAKE_SOURCE_DIR}/dep/mersennetwister
   ${CMAKE_SOURCE_DIR}/src/server/collision
   ${CMAKE_SOURCE_DIR}/src/server/collision/Management
-  ${CMAKE_SOURCE_DIR}/src/server/collision/Models
   ${CMAKE_SOURCE_DIR}/src/server/shared
   ${CMAKE_SOURCE_DIR}/src/server/shared/Configuration
   ${CMAKE_SOURCE_DIR}/src/server/shared/Cryptography
diff --git a/src/tools/vmap3_assembler/CMakeLists.txt b/src/tools/vmap3_assembler/CMakeLists.txt
index 42ffc74..ba5d164 100644
--- a/src/tools/vmap3_assembler/CMakeLists.txt
+++ b/src/tools/vmap3_assembler/CMakeLists.txt
@@ -13,7 +13,6 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/dep/g3dlite/include
   ${CMAKE_SOURCE_DIR}/src/server/shared
   ${CMAKE_SOURCE_DIR}/src/server/shared/Debugging
-  ${CMAKE_SOURCE_DIR}/src/server/collision
   ${CMAKE_SOURCE_DIR}/src/server/collision/Maps
   ${CMAKE_SOURCE_DIR}/src/server/collision/Models
   ${ACE_INCLUDE_DIR}
diff --git a/src/tools/vmap3_extractor/adtfile.cpp b/src/tools/vmap3_extractor/adtfile.cpp
index a966172..58c1bb9 100644
--- a/src/tools/vmap3_extractor/adtfile.cpp
+++ b/src/tools/vmap3_extractor/adtfile.cpp
@@ -1,40 +1,13 @@
-/*
- * Copyright (C) 2005-2011 MaNGOS <http://getmangos.com/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
 #include "vmapexport.h"
 #include "adtfile.h"
 
 #include <algorithm>
 #include <cstdio>
 
-#ifdef WIN32
+#ifdef _WIN32
 #define snprintf _snprintf
 #endif
 
-const char * GetPlainName(const char * FileName)
-{
-    const char * szTemp;
-
-    if((szTemp = strrchr(FileName, '\\')) != NULL)
-        FileName = szTemp + 1;
-    return FileName;
-}
-
 char * GetPlainName(char * FileName)
 {
     char * szTemp;
@@ -70,14 +43,6 @@ void fixname2(char *name, size_t len)
     }
 }
 
-char * GetExtension(char * FileName)
-{
-    char * szTemp;
-    if((szTemp = strrchr(FileName, '.')) != NULL)
-        return szTemp;
-    return NULL;
-}
-
 ADTFile::ADTFile(char* filename): ADT(filename)
 {
     Adtfilename.append(filename);
@@ -142,15 +107,35 @@ bool ADTFile::init(uint32 map_num, uint32 tileX, uint32 tileY)
                 while (p<buf+size)
                 {
                     fixnamen(p,strlen(p));
-                    char* s = GetPlainName(p);
+                    string path(p);
+                    char* s=GetPlainName(p);
                     fixname2(s,strlen(s));
-
+                    p=p+strlen(p)+1;
                     ModelInstansName[t++] = s;
 
-                    string path(p);
-                    ExtractSingleModel(path);
-
-                    p = p+strlen(p)+1;
+                    // < 3.1.0 ADT MMDX section store filename.mdx filenames for corresponded .m2 file
+                    std::string ext3 = path.size() >= 4 ? path.substr(path.size()-4,4) : "";
+                    std::transform( ext3.begin(), ext3.end(), ext3.begin(), ::tolower );
+                    if(ext3 == ".mdx")
+                    {
+                        // replace .mdx -> .m2
+                        path.erase(path.length()-2,2);
+                        path.append("2");
+                    }
+                    // >= 3.1.0 ADT MMDX section store filename.m2 filenames for corresponded .m2 file
+                    // nothing do
+
+                    char szLocalFile[1024];
+                    snprintf(szLocalFile, 1024, "%s/%s", szWorkDirWmo, s);
+                    FILE * output = fopen(szLocalFile,"rb");
+                    if(!output)
+                    {
+                        Model m2(path);
+                        if(m2.open())
+                            m2.ConvertToVMAPModel(szLocalFile);
+                    }
+                    else
+                        fclose(output);
                 }
                 delete[] buf;
             }
diff --git a/src/tools/vmap3_extractor/adtfile.h b/src/tools/vmap3_extractor/adtfile.h
index 0881499..eaf09a9 100644
--- a/src/tools/vmap3_extractor/adtfile.h
+++ b/src/tools/vmap3_extractor/adtfile.h
@@ -1,21 +1,3 @@
-/*
- * Copyright (C) 2005-2011 MaNGOS <http://getmangos.com/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
 #ifndef ADT_H
 #define ADT_H
 
@@ -133,11 +115,7 @@ private:
     string Adtfilename;
 };
 
-const char * GetPlainName(const char * FileName);
-char * GetPlainName(char * FileName);
-char * GetExtension(char * FileName);
 void fixnamen(char *name, size_t len);
-void fixname2(char *name, size_t len);
 //void fixMapNamen(char *name, size_t len);
 
 #endif
diff --git a/src/tools/vmap3_extractor/dbcfile.cpp b/src/tools/vmap3_extractor/dbcfile.cpp
index 2474cea..8b8afe9 100644
--- a/src/tools/vmap3_extractor/dbcfile.cpp
+++ b/src/tools/vmap3_extractor/dbcfile.cpp
@@ -1,21 +1,3 @@
-/*
- * Copyright (C) 2005-2011 MaNGOS <http://getmangos.com/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
 #include "dbcfile.h"
 #include "mpq_libmpq04.h"
 #undef min
diff --git a/src/tools/vmap3_extractor/dbcfile.h b/src/tools/vmap3_extractor/dbcfile.h
index 56cce9a..d405d6f 100644
--- a/src/tools/vmap3_extractor/dbcfile.h
+++ b/src/tools/vmap3_extractor/dbcfile.h
@@ -1,19 +1,19 @@
 /*
- * Copyright (C) 2005-2011 MaNGOS <http://getmangos.com/>
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2010 MaNGOS <http://getmangos.com/>
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
 #ifndef DBCFILE_H
diff --git a/src/tools/vmap3_extractor/gameobject_extract.cpp b/src/tools/vmap3_extractor/gameobject_extract.cpp
deleted file mode 100644
index 8a1f67c..0000000
--- a/src/tools/vmap3_extractor/gameobject_extract.cpp
+++ /dev/null
@@ -1,99 +0,0 @@
-#include "model.h"
-#include "dbcfile.h"
-#include "adtfile.h"
-#include "vmapexport.h"
-
-#include <algorithm>
-#include <stdio.h>
-
-bool ExtractSingleModel(std::string& fname)
-{
-    char * name = GetPlainName((char*)fname.c_str());
-    char * ext = GetExtension(name);
-
-    // < 3.1.0 ADT MMDX section store filename.mdx filenames for corresponded .m2 file
-    if (!strcmp(ext, ".mdx"))
-    {
-        // replace .mdx -> .m2
-        fname.erase(fname.length()-2,2);
-        fname.append("2");
-    }
-    // >= 3.1.0 ADT MMDX section store filename.m2 filenames for corresponded .m2 file
-    // nothing do
-
-    std::string output(szWorkDirWmo);
-    output += "/";
-    output += name;
-
-    if (FileExists(output.c_str()))
-        return true;
-
-    Model mdl(fname);
-    if (!mdl.open())
-        return false;
-
-    return mdl.ConvertToVMAPModel(output.c_str());
-}
-
-void ExtractGameobjectModels()
-{
-    printf("Extracting GameObject models...");
-    DBCFile dbc("DBFilesClient\\GameObjectDisplayInfo.dbc");
-    if(!dbc.open())
-    {
-        printf("Fatal error: Invalid GameObjectDisplayInfo.dbc file format!\n");
-        exit(1);
-    }
-
-    std::string basepath = szWorkDirWmo;
-    basepath += "/";
-    std::string path;
-
-    FILE * model_list = fopen((basepath + "temp_gameobject_models").c_str(), "wb");
-
-    for (DBCFile::Iterator it = dbc.begin(); it != dbc.end(); ++it)
-    {
-        path = it->getString(1);
-
-        if (path.length() < 4)
-            continue;
-
-        fixnamen((char*)path.c_str(), path.size());
-        char * name = GetPlainName((char*)path.c_str());
-        fixname2(name, strlen(name));
-
-        char * ch_ext = GetExtension(name);
-        if (!ch_ext)
-            continue;
-
-        strToLower(ch_ext);
-
-        bool result = false;
-        if (!strcmp(ch_ext, ".wmo"))
-        {
-            result = ExtractSingleWmo(path);
-        }
-        else if (!strcmp(ch_ext, ".mdl"))
-        {
-            // TODO: extract .mdl files, if needed
-            continue;
-        }
-        else //if (!strcmp(ch_ext, ".mdx") || !strcmp(ch_ext, ".m2"))
-        {
-            result = ExtractSingleModel(path);
-        }
-
-        if (result)
-        {
-            uint32 displayId = it->getUInt(0);
-            uint32 path_length = strlen(name);
-            fwrite(&displayId, sizeof(uint32), 1, model_list);
-            fwrite(&path_length, sizeof(uint32), 1, model_list);
-            fwrite(name, sizeof(char), path_length, model_list);
-        }
-    }
-
-    fclose(model_list);
-
-    printf("Done!\n");
-}
diff --git a/src/tools/vmap3_extractor/loadlib/loadlib.h b/src/tools/vmap3_extractor/loadlib/loadlib.h
index 61865c4..bf6c070 100644
--- a/src/tools/vmap3_extractor/loadlib/loadlib.h
+++ b/src/tools/vmap3_extractor/loadlib/loadlib.h
@@ -1,25 +1,7 @@
-/*
- * Copyright (C) 2005-2011 MaNGOS <http://getmangos.com/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
 #ifndef LOAD_LIB_H
 #define LOAD_LIB_H
 
-#ifdef WIN32
+#ifdef _WIN32
 typedef __int64            int64;
 typedef __int32            int32;
 typedef __int16            int16;
diff --git a/src/tools/vmap3_extractor/model.cpp b/src/tools/vmap3_extractor/model.cpp
index 117c594..81e2762 100644
--- a/src/tools/vmap3_extractor/model.cpp
+++ b/src/tools/vmap3_extractor/model.cpp
@@ -1,21 +1,3 @@
-/*
- * Copyright (C) 2005-2011 MaNGOS <http://getmangos.com/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
 #include "vmapexport.h"
 #include "model.h"
 #include "wmo.h"
@@ -24,7 +6,7 @@
 #include <algorithm>
 #include <cstdio>
 
-Model::Model(std::string &filename) : filename(filename), vertices(0), indices(0)
+Model::Model(std::string &filename) : filename(filename)
 {
 }
 
@@ -41,8 +23,6 @@ bool Model::open()
         return false;
     }
 
-    _unload();
-
     memcpy(&header, f.getBuffer(), sizeof(ModelHeader));
     if(header.nBoundingTriangles > 0)
     {
@@ -69,7 +49,7 @@ bool Model::open()
     return true;
 }
 
-bool Model::ConvertToVMAPModel(const char * outfilename)
+bool Model::ConvertToVMAPModel(char * outfilename)
 {
     int N[12] = {0,0,0,0,0,0,0,0,0,0,0,0};
     FILE * output=fopen(outfilename,"wb");
@@ -78,7 +58,7 @@ bool Model::ConvertToVMAPModel(const char * outfilename)
         printf("Can't create the output file '%s'\n",outfilename);
         return false;
     }
-    fwrite(szRawVMAPMagic,8,1,output);
+    fwrite("VMAP003",8,1,output);
     uint32 nVertices = 0;
     nVertices = header.nBoundingVertices;
     fwrite(&nVertices, sizeof(int), 1, output);
@@ -112,16 +92,24 @@ bool Model::ConvertToVMAPModel(const char * outfilename)
     {
         for(uint32 vpos=0; vpos <nVertices; ++vpos)
         {
-            std::swap(vertices[vpos].y, vertices[vpos].z);
+            float sy = vertices[vpos].y;
+            vertices[vpos].y = vertices[vpos].z;
+            vertices[vpos].z = sy;
         }
         fwrite(vertices, sizeof(float)*3, nVertices, output);
     }
 
+    delete[] vertices;
+    delete[] indices;
+
     fclose(output);
 
     return true;
 }
 
+Model::~Model()
+{
+}
 
 Vec3D fixCoordSystem(Vec3D v)
 {
@@ -166,7 +154,7 @@ ModelInstance::ModelInstance(MPQFile &f,const char* ModelInstName, uint32 mapID,
 
     uint16 adtId = 0;// not used for models
     uint32 flags = MOD_M2;
-	if(tileX == 65 && tileY == 65) flags |= MOD_WORLDSPAWN;
+    if(tileX == 65 && tileY == 65) flags |= MOD_WORLDSPAWN;
     //write mapID, tileX, tileY, Flags, ID, Pos, Rot, Scale, name
     fwrite(&mapID, sizeof(uint32), 1, pDirfile);
     fwrite(&tileX, sizeof(uint32), 1, pDirfile);
diff --git a/src/tools/vmap3_extractor/model.h b/src/tools/vmap3_extractor/model.h
index a6f4e27..c131645 100644
--- a/src/tools/vmap3_extractor/model.h
+++ b/src/tools/vmap3_extractor/model.h
@@ -1,21 +1,3 @@
-/*
- * Copyright (C) 2005-2011 MaNGOS <http://getmangos.com/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
 #ifndef MODEL_H
 #define MODEL_H
 
@@ -41,21 +23,14 @@ public:
     size_t nIndices;
 
     bool open();
-    bool ConvertToVMAPModel(const char * outfilename);
+    bool ConvertToVMAPModel(char * outfilename);
 
     bool ok;
 
     Model(std::string &filename);
-    ~Model() {_unload();}
+    ~Model();
 
 private:
-    void _unload()
-    {
-        delete[] vertices;
-        delete[] indices;
-        vertices = NULL;
-        indices = NULL;
-    }
     std::string filename;
     char outfilename;
 };
diff --git a/src/tools/vmap3_extractor/modelheaders.h b/src/tools/vmap3_extractor/modelheaders.h
index d859fd3..776a981 100644
--- a/src/tools/vmap3_extractor/modelheaders.h
+++ b/src/tools/vmap3_extractor/modelheaders.h
@@ -1,21 +1,3 @@
-/*
- * Copyright (C) 2005-2011 MaNGOS <http://getmangos.com/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
 #ifndef MODELHEADERS_H
 #define MODELHEADERS_H
 
diff --git a/src/tools/vmap3_extractor/mpq_libmpq04.h b/src/tools/vmap3_extractor/mpq_libmpq04.h
index 4b0a246..f32f09b 100644
--- a/src/tools/vmap3_extractor/mpq_libmpq04.h
+++ b/src/tools/vmap3_extractor/mpq_libmpq04.h
@@ -1,6 +1,3 @@
-#define _CRT_SECURE_NO_DEPRECATE
-#define _CRT_SECURE_NO_WARNINGS
-
 #ifndef MPQ_H
 #define MPQ_H
 
@@ -24,14 +21,14 @@ public:
     void close();
 
     void GetFileListTo(vector<string>& filelist) {
-    	uint32 filenum;
-    	if(libmpq__file_number(mpq_a, "(listfile)", &filenum)) return;
-    	libmpq__off_t size, transferred;
-		libmpq__file_unpacked_size(mpq_a, filenum, &size);
+        uint32 filenum;
+        if(libmpq__file_number(mpq_a, "(listfile)", &filenum)) return;
+        libmpq__off_t size, transferred;
+        libmpq__file_unpacked_size(mpq_a, filenum, &size);
 
         char *buffer = new char[size];
 
-		libmpq__file_read(mpq_a, filenum, (unsigned char*)buffer, size, &transferred);
+        libmpq__file_read(mpq_a, filenum, (unsigned char*)buffer, size, &transferred);
 
         char seps[] = "\n";
         char *token;
diff --git a/src/tools/vmap3_extractor/vmapexport.cpp b/src/tools/vmap3_extractor/vmapexport.cpp
index 91e50b9..689691e 100644
--- a/src/tools/vmap3_extractor/vmapexport.cpp
+++ b/src/tools/vmap3_extractor/vmapexport.cpp
@@ -1,21 +1,3 @@
-/*
- * Copyright (C) 2005-2011 MaNGOS <http://getmangos.com/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
 #define _CRT_SECURE_NO_DEPRECATE
 #include <cstdio>
 #include <iostream>
@@ -23,7 +5,7 @@
 #include <list>
 #include <errno.h>
 
-#ifdef WIN32
+#ifdef _WIN32
     #include <Windows.h>
     #include <sys/stat.h>
     #include <direct.h>
@@ -47,8 +29,6 @@
 #include "wmo.h"
 #include "mpq_libmpq04.h"
 
-#include "vmapexport.h"
-
 //------------------------------------------------------------------------------
 // Defines
 
@@ -76,18 +56,12 @@ bool preciseVectorData = false;
 
 //static const char * szWorkDirMaps = ".\\Maps";
 const char * szWorkDirWmo = "./Buildings";
-const char * szRawVMAPMagic = "VMAP003";
 
 // Local testing functions
 
-bool FileExists(const char * file)
+static void clreol()
 {
-    if (FILE * n = fopen(file, "rb"))
-    {
-        fclose(n);
-        return true;
-    }
-    return false;
+    printf("\r                                                                              \r");
 }
 
 void strToLower(char* str)
@@ -99,6 +73,15 @@ void strToLower(char* str)
     }
 }
 
+static const char * GetPlainName(const char * szFileName)
+{
+    const char * szTemp;
+
+    if((szTemp = strrchr(szFileName, '\\')) != NULL)
+        szFileName = szTemp + 1;
+    return szFileName;
+}
+
 // copied from contrib/extractor/System.cpp
 void ReadLiquidTypeTableDBC()
 {
@@ -121,9 +104,10 @@ void ReadLiquidTypeTableDBC()
     printf("Done! (%u LiqTypes loaded)\n", (unsigned int)LiqType_count);
 }
 
-bool ExtractWmo()
+int ExtractWmo()
 {
-    bool success = true;
+    char   szLocalFile[1024] = "";
+    bool success=true;
 
     //const char* ParsArchiveNames[] = {"patch-2.MPQ", "patch.MPQ", "common.MPQ", "expansion.MPQ"};
 
@@ -132,98 +116,99 @@ bool ExtractWmo()
         vector<string> filelist;
 
         (*ar_itr)->GetFileListTo(filelist);
-        for (vector<string>::iterator fname = filelist.begin(); fname != filelist.end() && success; ++fname)
+        for (vector<string>::iterator fname=filelist.begin(); fname != filelist.end() && success; ++fname)
         {
+            bool file_ok=true;
             if (fname->find(".wmo") != string::npos)
-                success = ExtractSingleWmo(*fname);
+            {
+                // Copy files from archive
+                //std::cout << "found *.wmo file " << *fname << std::endl;
+                sprintf(szLocalFile, "%s/%s", szWorkDirWmo, GetPlainName(fname->c_str()));
+                fixnamen(szLocalFile,strlen(szLocalFile));
+                FILE * n;
+                if ((n = fopen(szLocalFile, "rb"))== NULL)
+                {
+                    int p = 0;
+                    //Select root wmo files
+                    const char * rchr = strrchr(GetPlainName(fname->c_str()),0x5f);
+                    if(rchr != NULL)
+                    {
+                        char cpy[4];
+                        strncpy((char*)cpy,rchr,4);
+                        for (int i=0;i<4; ++i)
+                        {
+                            int m = cpy[i];
+                            if(isdigit(m))
+                                p++;
+                        }
+                    }
+                    if(p != 3)
+                    {
+                        std::cout << "Extracting " << *fname << std::endl;
+                        WMORoot * froot = new WMORoot(*fname);
+                        if(!froot->open())
+                        {
+                            printf("Couldn't open RootWmo!!!\n");
+                            delete froot;
+                            continue;
+                        }
+                        FILE *output=fopen(szLocalFile,"wb");
+                        if(!output)
+                        {
+                            printf("couldn't open %s for writing!\n", szLocalFile);
+                            success=false;
+                        }
+                        froot->ConvertToVMAPRootWmo(output);
+                        int Wmo_nVertices = 0;
+                        //printf("root has %d groups\n", froot->nGroups);
+                        if(froot->nGroups !=0)
+                        {
+                            for (uint32 i=0; i<froot->nGroups; ++i)
+                            {
+                                char temp[1024];
+                                strcpy(temp, fname->c_str());
+                                temp[fname->length()-4] = 0;
+                                char groupFileName[1024];
+                                sprintf(groupFileName,"%s_%03d.wmo",temp, i);
+                                //printf("Trying to open groupfile %s\n",groupFileName);
+                                string s = groupFileName;
+                                WMOGroup * fgroup = new WMOGroup(s);
+                                if(!fgroup->open())
+                                {
+                                    printf("Could not open all Group file for: %s\n",GetPlainName(fname->c_str()));
+                                    file_ok=false;
+                                    break;
+                                }
+
+                                Wmo_nVertices += fgroup->ConvertToVMAPGroupWmo(output, froot, preciseVectorData);
+                                delete fgroup;
+                            }
+                        }
+                        fseek(output, 8, SEEK_SET); // store the correct no of vertices
+                        fwrite(&Wmo_nVertices,sizeof(int),1,output);
+                        fclose(output);
+                        delete froot;
+                    }
+                }
+                else
+                {
+                    fclose(n);
+                }
+            }
+            // Delete the extracted file in the case of an error
+            if(!file_ok)
+                remove(szLocalFile);
         }
     }
 
-    if (success)
+    if(success)
         printf("\nExtract wmo complete (No (fatal) errors)\n");
 
     return success;
 }
 
-bool ExtractSingleWmo(std::string& fname)
+void ExtractMapsFromMpq()
 {
-    // Copy files from archive
-
-    char szLocalFile[1024];
-    const char * plain_name = GetPlainName(fname.c_str());
-    sprintf(szLocalFile, "%s/%s", szWorkDirWmo, plain_name);
-    fixnamen(szLocalFile,strlen(szLocalFile));
-
-    if (FileExists(szLocalFile))
-        return true;
-
-    int p = 0;
-    //Select root wmo files
-    const char * rchr = strrchr(plain_name, '_');
-    if(rchr != NULL)
-    {
-        char cpy[4];
-        strncpy((char*)cpy,rchr,4);
-        for (int i=0;i < 4; ++i)
-        {
-            int m = cpy[i];
-            if(isdigit(m))
-                p++;
-        }
-    }
-
-    if (p == 3)
-        return true;
-
-    bool file_ok = true;
-    std::cout << "Extracting " << fname << std::endl;
-    WMORoot froot(fname);
-    if(!froot.open())
-    {
-        printf("Couldn't open RootWmo!!!\n");
-        return true;
-    }
-    FILE *output = fopen(szLocalFile,"wb");
-    if(!output)
-    {
-        printf("couldn't open %s for writing!\n", szLocalFile);
-        return false;
-    }
-    froot.ConvertToVMAPRootWmo(output);
-    int Wmo_nVertices = 0;
-    //printf("root has %d groups\n", froot->nGroups);
-    if (froot.nGroups !=0)
-    {
-        for (uint32 i = 0; i < froot.nGroups; ++i)
-        {
-            char temp[1024];
-            strcpy(temp, fname.c_str());
-            temp[fname.length()-4] = 0;
-            char groupFileName[1024];
-            sprintf(groupFileName,"%s_%03d.wmo",temp, i);
-            //printf("Trying to open groupfile %s\n",groupFileName);
-
-            string s = groupFileName;
-            WMOGroup fgroup(s);
-            if(!fgroup.open())
-            {
-                printf("Could not open all Group file for: %s\n", plain_name);
-                file_ok = false;
-                break;
-            }
-
-            Wmo_nVertices += fgroup.ConvertToVMAPGroupWmo(output, &froot, preciseVectorData);
-        }
-    }
-
-    fseek(output, 8, SEEK_SET); // store the correct no of vertices
-    fwrite(&Wmo_nVertices,sizeof(int),1,output);
-    fclose(output);
-
-    // Delete the extracted file in the case of an error
-    if (!file_ok)
-        remove(szLocalFile);
-    return true;
 }
 
 void ParsMapFiles()
@@ -266,9 +251,8 @@ void getGamePath()
     LONG l;
     s = sizeof(input_path);
     memset(input_path,0,s);
-    l = RegOpenKeyEx(HKEY_LOCAL_MACHINE,"SOFTWARE\\Blizzard Entertainment\\World of Warcraft",0,KEY_QUERY_VALUE,&key);
-    //l = RegOpenKeyEx(HKEY_LOCAL_MACHINE,"SOFTWARE\\Blizzard Entertainment\\Burning Crusade Closed Beta",0,KEY_QUERY_VALUE,&key);
-    l = RegQueryValueEx(key,"InstallPath",0,&t,(LPBYTE)input_path,&s);
+    l = RegOpenKeyExA(HKEY_LOCAL_MACHINE,"SOFTWARE\\Blizzard Entertainment\\World of Warcraft",0,KEY_QUERY_VALUE,&key);
+    l = RegQueryValueExA(key,"InstallPath",0,&t,(LPBYTE)input_path,&s);
     RegCloseKey(key);
     if (strlen(input_path) > 0)
     {
@@ -395,17 +379,16 @@ bool processArgv(int argc, char ** argv, const char *versionString)
 {
     bool result = true;
     hasInputPathParam = false;
-    bool preciseVectorData = false;
 
-    for(int i=1; i< argc; ++i)
+    for (int i=1; i < argc; ++i)
     {
-        if(strcmp("-s",argv[i]) == 0)
+        if (strcmp("-s", argv[i]) == 0)
         {
             preciseVectorData = false;
         }
-        else if(strcmp("-d",argv[i]) == 0)
+        else if (strcmp("-d", argv[i]) == 0)
         {
-            if((i+1)<argc)
+            if ((i + 1) < argc)
             {
                 hasInputPathParam = true;
                 strcpy(input_path, argv[i+1]);
@@ -418,11 +401,11 @@ bool processArgv(int argc, char ** argv, const char *versionString)
                 result = false;
             }
         }
-        else if(strcmp("-?",argv[1]) == 0)
+        else if (strcmp("-?", argv[1]) == 0)
         {
             result = false;
         }
-        else if(strcmp("-l",argv[i]) == 0)
+        else if (strcmp("-l", argv[i]) == 0)
         {
             preciseVectorData = true;
         }
@@ -444,7 +427,6 @@ bool processArgv(int argc, char ** argv, const char *versionString)
     return result;
 }
 
-
 //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
 // Main
 //
@@ -483,7 +465,7 @@ int main(int argc, char ** argv)
     //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
     // Create the working directory
     if(mkdir(szWorkDirWmo
-#ifdef __linux__
+#ifdef _XOPEN_UNIX
                     , 0711
 #endif
                     ))
@@ -535,11 +517,9 @@ int main(int argc, char ** argv)
         ParsMapFiles();
         delete [] map_ids;
         //nError = ERROR_SUCCESS;
-        // Extract models, listed in DameObjectDisplayInfo.dbc
-        ExtractGameobjectModels();
     }
 
-    printf("\n");
+    clreol();
     if(!success)
     {
         printf("ERROR: Extract %s. Work NOT complete.\n   Precise vector data=%d.\nPress any key.\n",versionString, preciseVectorData);
diff --git a/src/tools/vmap3_extractor/vmapexport.h b/src/tools/vmap3_extractor/vmapexport.h
index b407e7a..e8a55fb 100644
--- a/src/tools/vmap3_extractor/vmapexport.h
+++ b/src/tools/vmap3_extractor/vmapexport.h
@@ -1,42 +1,13 @@
-/*
- * Copyright (C) 2005-2011 MaNGOS <http://getmangos.com/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
 #ifndef VMAPEXPORT_H
 #define VMAPEXPORT_H
 
-#include <string>
-
 enum ModelFlags
 {
-	MOD_M2 = 1,
-	MOD_WORLDSPAWN = 1<<1,
+    MOD_M2 = 1,
+    MOD_WORLDSPAWN = 1<<1,
     MOD_HAS_BOUND = 1<<2
 };
 
 extern const char * szWorkDirWmo;
-extern const char * szRawVMAPMagic;                         // vmap magic string for extracted raw vmap data
-
-bool FileExists(const char * file);
-void strToLower(char* str);
-
-bool ExtractSingleWmo(std::string& fname);
-bool ExtractSingleModel(std::string& fname);
-
-void ExtractGameobjectModels();
 
 #endif
diff --git a/src/tools/vmap3_extractor/wdtfile.cpp b/src/tools/vmap3_extractor/wdtfile.cpp
index e3ee545..cd24ef0 100644
--- a/src/tools/vmap3_extractor/wdtfile.cpp
+++ b/src/tools/vmap3_extractor/wdtfile.cpp
@@ -1,21 +1,3 @@
-/*
- * Copyright (C) 2005-2011 MaNGOS <http://getmangos.com/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
 #include "vmapexport.h"
 #include "wdtfile.h"
 #include "adtfile.h"
diff --git a/src/tools/vmap3_extractor/wmo.cpp b/src/tools/vmap3_extractor/wmo.cpp
index 58957e0..216a224 100644
--- a/src/tools/vmap3_extractor/wmo.cpp
+++ b/src/tools/vmap3_extractor/wmo.cpp
@@ -1,21 +1,3 @@
-/*
- * Copyright (C) 2005-2011 MaNGOS <http://getmangos.com/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
 #include "vmapexport.h"
 #include "wmo.h"
 #include "vec3d.h"
@@ -124,7 +106,7 @@ bool WMORoot::ConvertToVMAPRootWmo(FILE *pOutfile)
 {
     //printf("Convert RootWmo...\n");
 
-    fwrite(szRawVMAPMagic,1,8,pOutfile);
+    fwrite("VMAP003",1,8,pOutfile);
     unsigned int nVectors = 0;
     fwrite(&nVectors,sizeof(nVectors),1,pOutfile); // will be filled later
     fwrite(&nGroups,4,1,pOutfile);
diff --git a/src/tools/vmap3_extractor/wmo.h b/src/tools/vmap3_extractor/wmo.h
index d1f7b82..12979bc 100644
--- a/src/tools/vmap3_extractor/wmo.h
+++ b/src/tools/vmap3_extractor/wmo.h
@@ -1,21 +1,3 @@
-/*
- * Copyright (C) 2005-2011 MaNGOS <http://getmangos.com/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
 #ifndef WMO_H
 #define WMO_H
 #define TILESIZE (533.33333f)
